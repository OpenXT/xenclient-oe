################################################################################
SHORT DESCRIPTION: 
################################################################################
ACPI PM feature for battery/AC/lid management for guests.

################################################################################
LONG DESCRIPTION: 
################################################################################
This feature provides enhanced PM capabilities for batteries, AC adapters and
laptop lids. It also supports power and sleep button even injection. It depends
on the acpi-pm-feature.patch in the Xen firmware patch queue. The two parts work
in conjunction to surface various PM related devices in the PM SSDT. There is a
partial version of this in upstream Xen.

################################################################################
CHANGELOG 
################################################################################
Original Author: Kamala Narasimhan, kamala.narasimhan@citrix.com
Second Incarnation: Nicolas DI PRIMA, nicolas.diprima@citrix.com
Latest Rework: Ross Philipson, philipsonr@ainfosec.com, 05/05/2015
Port to QEMU 2.6.2: Ross Philipson, philipsonr@ainfosec.com, 10/13/2016

################################################################################
REMOVAL 
################################################################################
Removal will disable the ACPI PM features.

################################################################################
UPSTREAM PLAN
################################################################################
This patch should be upstreamed.

################################################################################
INTERNAL DEPENDENCIES 
################################################################################

################################################################################
PATCHES 
################################################################################
--- a/hw/acpi/core.c
+++ b/hw/acpi/core.c
@@ -738,15 +738,24 @@ void acpi_send_gpe_event(ACPIREGS *ar, q
 
 void acpi_update_sci(ACPIREGS *regs, qemu_irq irq)
 {
-    int sci_level, pm1a_sts;
+    int pm1a_level, gpe_level, pm1a_sts;
 
     pm1a_sts = acpi_pm1_evt_get_sts(regs);
 
-    sci_level = ((pm1a_sts &
-                  regs->pm1.evt.en & ACPI_BITMASK_PM1_COMMON_ENABLED) != 0) ||
-                ((regs->gpe.sts[0] & regs->gpe.en[0]) != 0);
+    pm1a_level = ((pm1a_sts &
+                   regs->pm1.evt.en & ACPI_BITMASK_PM1_COMMON_ENABLED) != 0);
 
-    qemu_set_irq(irq, sci_level);
+    /*
+     * The OSPM sets the EN bits depending on the _Lxx methods (there are no
+     * _Exx methods) it finds in the GPE scope.
+     */
+    gpe_level = (((regs->gpe.sts[0] & regs->gpe.en[0]) != 0) ||
+                 ((regs->gpe.sts[1] & regs->gpe.en[1]) != 0));
+
+    if (pm1a_level || gpe_level)
+        qemu_irq_raise(irq);
+    else
+        qemu_irq_lower(irq);
 
     /* schedule a timer interruption if needed */
     acpi_pm_tmr_update(regs,
--- a/hw/acpi/piix4.c
+++ b/hw/acpi/piix4.c
@@ -39,6 +39,7 @@
 #include "hw/acpi/memory_hotplug.h"
 #include "hw/acpi/acpi_dev_interface.h"
 #include "hw/xen/xen.h"
+#include "hw/xen/xen_acpi_pm.h"
 #include "qom/cpu.h"
 
 //#define DEBUG
@@ -509,6 +510,11 @@ static void piix4_pm_realize(PCIDevice *
     /* APM */
     apm_init(dev, &s->apm, apm_ctrl_changed, s);
 
+    /* OpenXT: battery/AC/lid devices */
+    if (xen_enabled() && xen_acpi_pm_get_enabled()) {
+        xen_acpi_pm_create(pci_address_space_io(dev), s);
+    }
+
     /* OpenXT: Enable ACPI, QEMU doesn't enable it by default */
     apm_ctrl_changed(ACPI_ENABLE, s);
 
@@ -603,6 +609,7 @@ static void gpe_writeb(void *opaque, hwa
     PIIX4PMState *s = opaque;
 
     acpi_gpe_ioport_writeb(&s->ar, addr, val);
+    xen_acpi_pm_gpe_ioport_writeb(s->ar.gpe.len, addr, val);
     acpi_update_sci(&s->ar, s->irq);
 
     PIIX4_DPRINTF("gpe write %" HWADDR_PRIx " <== %" PRIu64 "\n", addr, val);
@@ -638,6 +645,32 @@ static void piix4_set_cpu_hotplug_legacy
     s->cpu_hotplug_legacy = value;
 }
 
+void piix4_pm_set_gpe_sts_raise_sci(void *opaque, uint8_t bit)
+{
+    PIIX4PMState *s = opaque;
+    bool update = false;
+
+    /* N. B. concerning the mechanism for asserting and de-asserting the SCI.
+     * When GPE or PM1 STS bits are set, acpi_update_sci() will raise an SCI (in
+     * these cases level interrupt). The OSPM will then clear the particular
+     * STS bits which is effectively EOI. Subsequent calls to acpi_update_sci()
+     * with no STS bits set, e.g. after the bits are written in gpe_writeb(),
+     * will lower the SCI. */
+    if ((bit < 8)&&(s->ar.gpe.en[0] & (1 << bit))) {
+        s->ar.gpe.sts[0] |= (1 << bit);
+        update = true;
+    }
+    else if ((bit < 16)&&(s->ar.gpe.en[1] & (1 << (bit - 8)))) {
+        s->ar.gpe.sts[1] |= (1 << (bit - 8));
+        update = true;
+    }
+
+    if (update)
+        acpi_update_sci(&s->ar, s->irq);
+
+    PIIX4_DPRINTF("sts raise sci %x\n", bits);
+}
+
 static void piix4_acpi_system_hot_add_init(MemoryRegion *parent,
                                            PCIBus *bus, PIIX4PMState *s)
 {
--- a/hw/xen/Makefile.objs
+++ b/hw/xen/Makefile.objs
@@ -6,3 +6,4 @@ obj-$(CONFIG_XEN_PCI_PASSTHROUGH) += xen
 obj-$(CONFIG_XEN_PCI_PASSTHROUGH) += xen_pt.o xen_pt_config_init.o xen_pt_graphics.o xen_pt_msi.o
 obj-$(CONFIG_XEN_PCI_PASSTHROUGH) += xen_pt_load_rom.o
 obj-$(CONFIG_XEN) += xenmou.o
+obj-$(CONFIG_XEN) += xen_acpi_pm.o
--- /dev/null
+++ b/hw/xen/xen_acpi_pm.c
@@ -0,0 +1,1127 @@
+/*
+ * APCI PM feature for battery/AC/lid management for OpenXT guests.
+ *
+ * Copyright (C) 2014 Citrix Systems Ltd
+ * Copyright (c) 2015, Assured Information Security, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/* TODO
+ * Use ACQR/REL to make a common status port - is it feasible?
+ * _BIF is deprecated in ACPI 4.0: See ACPI spec (chap 10.2.2.1), add the _BIX.
+ */
+
+#include <stdint.h>
+#include "qemu/osdep.h"
+#include "include/qemu-common.h"
+#include "hw/sysbus.h"
+#include "hw/xen/xen_backend.h"
+#include "hw/xen/xen.h"
+#include "pci/pci.h"
+#include "hw/i386/pc.h"
+#include "hw/xen/xen_acpi_pm.h"
+
+/* Uncomment the following line to have debug messages about
+ * Battery Management */
+/* #define XEN_BATTERY_DEBUG */
+
+#ifdef XEN_BATTERY_DEBUG
+# define XBM_DPRINTF(fmt, ...)                            \
+    do {                                                  \
+        fprintf(stderr, "[BATTERY][%s(%d)]: " fmt,        \
+                __func__, __LINE__, ## __VA_ARGS__);      \
+    } while (0)
+#else
+# define XBM_DPRINTF(fmt, ...)                            \
+    { }
+#endif
+
+# define XBM_ERROR_MSG(fmt, ...)                          \
+    do {                                                  \
+        fprintf(stderr, "[BATTERY][ERROR][%s(%d)]: " fmt, \
+                __func__, __LINE__, ## __VA_ARGS__);      \
+    } while (0)
+
+#define MAX_BATTERIES              2
+
+#define BATTERY_PORT_1             0xb4 /* Battery command port */
+#define BATTERY_PORT_2             0x86 /* Battery data port */
+#define BATTERY_PORT_3             0x88 /* Battery 1 (BAT0) status port */
+#define BATTERY_PORT_4             0x84 /* Battery 2 (BAT1) status port */
+#define BATTERY_PORT_5             0xb5 /* Battery selector port */
+
+#define BATTERY_OP_INIT            0x7b /* Battery operation init */
+#define BATTERY_OP_SET_INFO_TYPE   0x7c /* Battery operation type */
+#define BATTERY_OP_GET_DATA_LENGTH 0x79 /* Battery operation data length */
+#define BATTERY_OP_GET_DATA        0x7d /* Battery operation data read */
+
+#define BATTERY_PRESENT            0x01 /* Battery in slot is present */
+#define BATTERY_INFO_UPDATE        0x80 /* Battery information updated */
+
+#define ACPI_PM_STATUS_PORT        0x9c /* General ACPI PM status port */
+
+#define ACPI_PM_STATUS_ENABLED     0x01 /* Bit indicates Xen ACPI PM enbled */
+#define ACPI_PM_STATUS_LID_OPEN    0x02 /* Bit indicates lid current open */
+#define ACPI_PM_STATUS_AC_ON       0x04 /* Bit indicates AC power plugged */
+#define ACPI_PM_STATUS_NOT_PRESENT 0x80 /* Bit indicates AC/battery devices
+                                           not present */
+
+#define ACPI_POWER_BUTTON_PORT     0x200 /* SLP/WAK button status port */
+#define ACPI_SLP_BIT               0x01  /* SLP bit for status port (1 << 0) */
+#define ACPI_WAK_BIT               0x02  /* WAK bit for status port (1 << 1) */
+
+/* GPE EN/STS bits for Xen ACPI PM */
+#define ACPI_PM_SLEEP_BUTTON       0x05 /* _LO5 0x0020 is (1 << 5) */
+#define ACPI_PM_POWER_BUTTON       0x06 /* _LO6 0x0040 is (1 << 6) */
+#define ACPI_PM_LID_STATUS         0x07 /* _LO7 0x0080 is (1 << 7) */
+#define ACPI_PM_AC_POWER_STATUS    0x0C /* _LOC 0x1000 is (1 << 12) */
+#define ACPI_PM_BATTERY_STATUS     0x0D /* _LOD 0x2000 is (1 << 13) */
+#define ACPI_PM_BATTERY_INFO       0x0E /* _LOE 0x4000 is (1 << 14) */
+
+/* Describes the different type of MODE managed by this module */
+enum xen_battery_mode {
+    XEN_BATTERY_MODE_NONE = 0,
+    XEN_BATTERY_MODE_PT,
+    XEN_BATTERY_MODE_HVM
+};
+
+enum xen_battery_selector {
+    XEN_BATTERY_TYPE_NONE = 0,
+    XEN_BATTERY_TYPE_BIF,
+    XEN_BATTERY_TYPE_BST
+};
+
+/* From each battery, xenstore provides the Battery Status (_bst) and the
+ * battery informatiom (_bif).
+ *
+ */
+struct battery_buffer {
+    char *_bst;           /* _BST */
+    char *_bif;           /* _BIF */
+    uint8_t port_b4_val;  /* Variable to manage BATTERY_PORT_1 */
+    uint8_t port_86_val;  /* Variable to manage BATTERY_PORT_2 */
+    uint8_t index;        /* Index inside the _BST or _BIF string */
+    uint8_t bif_changed;
+    /* Selector to mark which buffer we should use */
+    enum xen_battery_selector _selector;
+};
+
+struct xen_battery_manager {
+    enum xen_battery_mode mode; /* /[...]/xen_extended_power_mgmt */
+    uint8_t battery_present;    /* /pm/battery_present */
+    struct battery_buffer batteries[MAX_BATTERIES]; /* Battery array */
+    uint8_t index;              /* Battery selector */
+    MemoryRegion mr[5];         /* MemoryRegion to register IO ops */
+};
+
+typedef struct XenACPIPMState {
+    SysBusDevice busdev;
+
+    void *space_io;                  /* MemoryRegion */
+    void *piix4_dev;
+
+    struct xen_battery_manager xbm;
+
+    uint8_t ac_adapter_present;      /* /pm/ac_adapter */
+    uint8_t lid_state_open;          /* /pm/lid_state */
+    uint8_t not_present_mode;        /* AC/battery not present mode */
+    MemoryRegion mr;                 /* General ACPI MemoryRegion to register IO ops */
+    uint8_t button_status;           /* SLP/WAK status of button */
+    MemoryRegion bmr;                /* ACPI MemoryRegion for button ops */
+} XenACPIPMState;
+
+#define XEN_ACPI_PM(obj) OBJECT_CHECK(XenACPIPMState, (obj), TYPE_XEN_ACPI_PM)
+
+/* -------/ Enable /-------------------------------------------------------- */
+
+static bool xen_acpi_pm_enabled = false;
+
+void xen_acpi_pm_set_enabled(bool enable)
+{
+    xen_acpi_pm_enabled = enable;
+}
+
+bool xen_acpi_pm_get_enabled(void)
+{
+    return xen_acpi_pm_enabled;
+}
+
+/* -------/ Xenstore /------------------------------------------------------ */
+
+/* Read a string from the /pm/'key'
+ * set the result in 'return_value'
+ * retun 0 in success */
+static int32_t xen_pm_read_str(char const *key, char **return_value)
+{
+    char path[XEN_BUFSIZE];
+    char *value = NULL;
+
+    if (0 > snprintf(path, sizeof(path), "/pm/%s", key)) {
+        XBM_ERROR_MSG("snprintf failed\n");
+        return -1;
+    }
+
+    value = xs_read(xenstore, XBT_NULL, path, NULL);
+
+    if (NULL == value) {
+        XBM_DPRINTF("unable to read the content of \"%s\"\n", path);
+        return -1;
+    }
+
+    if (NULL != return_value)
+        *return_value = value;
+    else
+        free(value);
+
+    return 0;
+}
+
+/* Read a signed integer from the /pm/'key'
+ * set the result in 'return_value'
+ * retun 0 in success */
+static int32_t xen_pm_read_int(char const *key, int32_t default_value,
+                               int32_t *return_value)
+{
+    char path[XEN_BUFSIZE];
+    char *value = NULL;
+
+    if (0 > snprintf(path, sizeof(path), "/pm/%s", key)) {
+        XBM_ERROR_MSG("snprintf failed\n");
+        return -1;
+    }
+
+    value = xs_read(xenstore, XBT_NULL, path, NULL);
+    if (NULL == value) {
+        XBM_DPRINTF("unable to read the content of \"%s\"\n", path);
+        *return_value = default_value;
+        return 0;
+    }
+
+    *return_value = strtoull(value, NULL, 10);
+
+    free(value);
+
+    return 0;
+}
+
+/* -------/ Battery /------------------------------------------------------- */
+
+static int32_t xen_battery_update_battery_present(struct xen_battery_manager *xbm)
+{
+    int32_t value;
+
+    if (0 != xen_pm_read_int("battery_present", 0, &value)) {
+        XBM_ERROR_MSG("unable to update the battery present status\"\n");
+        /* in error case, it's preferable to show the worst situation */
+        xbm->battery_present = 0;
+        return -1;
+    }
+
+    xbm->battery_present = value;
+
+    return 0;
+}
+
+static int32_t xen_battery_update_bst(struct battery_buffer *battery,
+                                      int32_t battery_num)
+{
+    char *value = NULL;
+    char *old_value = NULL;
+    char key[6];
+    int32_t rc;
+
+    old_value = battery->_bst;
+
+    if (battery_num == 0) {
+        rc = xen_pm_read_str("bst", &value);
+    }
+    else {
+        memset(key, 0, sizeof(key));
+
+        if (0 > snprintf(key, sizeof(key) - 1, "bst%d", battery_num)) {
+            XBM_ERROR_MSG("snprintf failed\n");
+            return -1;
+        }
+
+        rc = xen_pm_read_str(key, &value);
+    }
+
+    if (0 != rc) {
+        XBM_DPRINTF("unable to read the content of \"/pm/bst%d\"\n",
+                    battery_num);
+        battery->_bst = old_value;
+        if (NULL != value) {
+            free(value);
+        }
+        return -1;
+    }
+
+    battery->_bst = value;
+
+    if (NULL != old_value) {
+        free(old_value);
+    }
+    return 0;
+}
+
+static int32_t xen_battery_update_bif(struct battery_buffer *battery,
+                                      int32_t battery_num)
+{
+    char *value = NULL;
+    char *old_value = NULL;
+    char key[6];
+    int32_t rc;
+
+    old_value = battery->_bif;
+
+    if (battery_num == 0) {
+        rc = xen_pm_read_str("bif", &value);
+    }
+    else {
+        memset(key, 0, sizeof(key));
+
+        if (0 > snprintf(key, sizeof(key) - 1, "bif%d", battery_num)) {
+            XBM_ERROR_MSG("snprintf failed\n");
+            return -1;
+        }
+
+        rc = xen_pm_read_str(key, &value);
+    }
+
+    if (0 != rc) {
+        XBM_DPRINTF("unable to read the content of \"/pm/bif%d\"\n",
+                    battery_num);
+        battery->_bif = old_value;
+        if (NULL != value) {
+            free(value);
+        }
+        return -1;
+    }
+
+    if ((NULL != old_value) && (NULL != value) &&
+        (strncmp(old_value, value, 70) != 0)) {
+        battery->bif_changed = 1;
+    }
+
+    battery->_bif = value;
+    if (NULL != old_value) {
+        free(old_value);
+    }
+    return 0;
+}
+
+static int32_t xen_battery_update_status_info(struct xen_battery_manager *xbm)
+{
+    int32_t index;
+
+    for (index = 0; index < MAX_BATTERIES; index++) {
+        xen_battery_update_bif(&(xbm->batteries[index]), index);
+        xen_battery_update_bst(&(xbm->batteries[index]), index);
+    }
+
+    return 0;
+}
+
+/* This function initializes the mode of the power management. */
+static int32_t xen_battery_init_mode(struct xen_battery_manager *xbm)
+{
+    char dompath[XEN_BUFSIZE];
+    char *value = NULL;
+
+    /* xen_extended_power_mgmt xenstore entry indicates whether or not extended
+     * power management support is requested for the hvm guest.  Extended power
+     * management support includes power management support beyond S3, S4, S5.
+     * A value of 1 indicates pass-through pm support where upon pm resources
+     * are mapped to the guest as appropriate where as a value of 2 as set in
+     * non pass-through mode, requires qemu to take the onus of responding to
+     * relevant pm port reads/writes. */
+    if (0 > snprintf(dompath, sizeof(dompath),
+                     "device-model/%d/xen_extended_power_mgmt",
+                     xen_domid)) {
+        XBM_ERROR_MSG("snprintf failed\n");
+        return -1;
+    }
+
+    value = xs_read(xenstore, XBT_NULL, dompath, NULL);
+
+    if (NULL == value) {
+        XBM_ERROR_MSG("unable to read the content of \"%s\"\n", dompath);
+        return -1;
+    }
+
+    xbm->mode = strtoull(value, NULL, 10);
+
+    free(value);
+
+    return 0;
+}
+
+/* -------/ Battery IO /---------------------------------------------------- */
+
+static void battery_port_1_write_op_init(struct battery_buffer *bb)
+{
+    if (NULL != bb->_bif) {
+        free(bb->_bif);
+        bb->_bif = NULL;
+    }
+    if (NULL != bb->_bst) {
+        free(bb->_bst);
+        bb->_bst = NULL;
+    }
+
+    bb->_selector = XEN_BATTERY_TYPE_NONE;
+    bb->index = 0;
+}
+
+static void battery_port_1_write_op_set_type(struct battery_buffer *bb,
+                                             struct xen_battery_manager *xbm)
+{
+    if (XEN_BATTERY_TYPE_NONE == bb->_selector) {
+        switch (bb->port_86_val) {
+        case XEN_BATTERY_TYPE_BIF:
+            bb->_selector = XEN_BATTERY_TYPE_BIF;
+            xen_battery_update_bif(bb, xbm->index);
+            XBM_DPRINTF("BATTERY_OP_SET_INFO_TYPE (BIF)\n");
+            break;
+        case XEN_BATTERY_TYPE_BST:
+            bb->_selector = XEN_BATTERY_TYPE_BST;
+            xen_battery_update_bst(bb, xbm->index);
+            XBM_DPRINTF("BATTERY_OP_SET_INFO_TYPE (BST)\n");
+            break;
+        case XEN_BATTERY_TYPE_NONE:
+            /* NO BREAK HERE: fallthrough */
+        default:
+            XBM_ERROR_MSG("unknown type: %d\n", bb->port_86_val);
+        }
+    }
+}
+
+/*
+ * Command option helper to get the next data byte.
+ *
+ * To understand this function, the format of the data passed in the xenstore
+ * nodes for BIF and BST must be understood. Both the BIF and BST are defined
+ * in the ACPI specification (see 10.2.2.1 and 10.2.2.6 in the version 5.0
+ * spec).
+ *
+ * The BIF starts with 9 fixed DWORD fields followed by 4 variable length
+ * ASCII fields. All of this is flattened out in into a string in xenstore by
+ * xcpmd. Length specifiers and DWORD bytes are represented by 2 hex chars.
+ * The first byte pair is the length of the entire block (see below). The next
+ * 36 bytes pairs are the DWORD fields. At the end are the four ASCII strings
+ * each starting with a length byte pair then the string then a trailing \n.
+ *
+ * This is an example of a BIF:
+ *
+ * 440100000050140000d7110000010000005c2b0000000000000000000001000000010000000dDELL NH6K927\n04189\n05LION\n06Sanyo\n
+ * ^ |           9 DWORDS * 4 bytes each * 2 chars each = 72 bytes          |^ |  string 1  | ...                   |
+ * |                                                                         |                                      |
+ * +--- D-LENGTH of entire data                   S-LENGTH of first sting ---+                                      |
+ *   |                                                                       |                                      |
+ *   |      Hex digit pairs counted as 1 byte in the D-LENGTH = 36 bytes     |  Hex digit pairs + char + \n = 32    |
+ *   |                       D-LENGTH is total length 36 + 32 = 68 or 0x44                                          |
+ *
+ * This layout is where the magic number BIF_DATA_BOUNDARY (74) comes from. It
+ * it the switch over point from reading the D-LENGTH + DWORD block to
+ * reading the ASCII strings. Each read of the byte pair data is a read of 2
+ * where the reading of the ASCII chars is a 1 byte read. S-LENGTH is pretty
+ * simple, it is the string length (and \n is 1 char). D-LENGTH is more
+ * complicated. For byte pairs, it counts each as one byte but chars are each
+ * 1 byte (with \n as one char). So 0x44 (68) is the entire length of data as
+ * shown above.
+ *
+ * Now compared to that, the BST is simple. It is a structure of 4 DWORDs.
+ * This is flattened out the same way as the BIF and it is clear why the
+ * reading algorithm below works on it the same way.
+ *
+ * This is an example BST:
+ *
+ * 1000000000010000009222000045320000
+ * ^ | 4 DWORDS ... = 32 bytes      |
+ * |
+ * +--- D-LENGTH of DWORD block
+ *
+ */
+static void battery_port_1_op_get_data(struct battery_buffer *bb,
+                                       struct xen_battery_manager *xbm)
+{
+#define BIF_DATA_BOUNDARY 74
+    char *data = NULL;
+    char buf[3];
+
+    if (XEN_BATTERY_TYPE_BST == bb->_selector) {
+       data = bb->_bst;
+    }
+    else if (XEN_BATTERY_TYPE_BIF == bb->_selector) {
+       data = bb->_bif;
+    }
+    else {
+       XBM_ERROR_MSG("unknown _selector: %d\n", bb->_selector);
+       return;
+    }
+
+    data += bb->index;
+    if ((bb->index <= BIF_DATA_BOUNDARY) ||
+        ((bb->index > BIF_DATA_BOUNDARY) && ((*(data - 1)) == '\n'))) {
+        snprintf(buf, sizeof(buf), "%s", data);
+        bb->port_86_val = (uint8_t)strtoull(buf, NULL, 0x10);
+        bb->index += 2;
+    }
+    else {
+       if (*data == '\n') {
+           bb->port_86_val = 0;
+       }
+       else {
+           bb->port_86_val = *data;
+       }
+       bb->index++;
+    }
+}
+
+/*
+ * Battery command IO port write.
+ *
+ * Writes to the command ports select the operations including
+ * reads on the data port.
+ */
+static void battery_port_1_write(void *opaque, hwaddr addr,
+                                 uint64_t val, uint32_t size)
+{
+    struct xen_battery_manager *xbm = opaque;
+    struct battery_buffer *bb;
+
+    bb = &(xbm->batteries[xbm->index]);
+
+    switch (val) {
+    case BATTERY_OP_INIT:
+    {
+        battery_port_1_write_op_init(bb);
+        XBM_DPRINTF("BATTERY_OP_INIT\n");
+        break;
+    }
+    case BATTERY_OP_SET_INFO_TYPE:
+    {
+        battery_port_1_write_op_set_type(bb, xbm);
+        break;
+    }
+    case BATTERY_OP_GET_DATA_LENGTH:
+    {
+        /*
+         * Length read comes first and the length is the first byte of the
+         * data so fallthrough.
+         */
+    }
+    case BATTERY_OP_GET_DATA:
+    {
+        XBM_DPRINTF("BATTERY_OP_GET_DATA\n");
+        battery_port_1_op_get_data(bb, xbm);
+        break;
+    }
+    default:
+        XBM_ERROR_MSG("unknown cmd: %llu", val);
+        break;
+    }
+
+    bb->port_b4_val = 0;
+}
+
+/*
+ * Battery command IO port read.
+ */
+static uint64_t battery_port_1_read(void *opaque, hwaddr addr, uint32_t size)
+{
+    struct xen_battery_manager *xbm = opaque;
+    XBM_DPRINTF("port_b4 == 0x%02x\n", xbm->batteries[xbm->index].port_b4_val);
+    return xbm->batteries[xbm->index].port_b4_val;
+}
+
+struct MemoryRegionOps port_1_ops = {
+    .read = battery_port_1_read,
+    .write = battery_port_1_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = {
+        .min_access_size = 1,
+        .max_access_size = 1,
+    },
+};
+
+/*
+ * Battery data IO port write.
+ */
+static void battery_port_2_write(void *opaque, hwaddr addr,
+                                 uint64_t val, uint32_t size)
+{
+    struct xen_battery_manager *xbm = opaque;
+    xbm->batteries[xbm->index].port_86_val = val;
+    XBM_DPRINTF("port_86 := 0x%x\n", xbm->batteries[xbm->index].port_86_val);
+}
+
+/*
+ * Battery data IO port read.
+ *
+ * For get data command ops, each byte is read sequentially from this port.
+ */
+static uint64_t battery_port_2_read(void *opaque, hwaddr addr, uint32_t size)
+{
+    struct xen_battery_manager *xbm = opaque;
+    XBM_DPRINTF("port_86 == 0x%x\n", xbm->batteries[xbm->index].port_86_val);
+    return xbm->batteries[xbm->index].port_86_val;
+}
+
+struct MemoryRegionOps port_2_ops = {
+    .read = battery_port_2_read,
+    .write = battery_port_2_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = {
+        .min_access_size = 1,
+        .max_access_size = 1,
+    },
+};
+
+/*
+ * Battery 1 (BAT0) status IO port write.
+ *
+ * Returns BATTERY_PRESENT (0x01) if battery present.
+ *         BATTERY_INFO_UPDATE (0x80) if battery information is updated.
+ */
+static uint64_t battery_port_3_read(void *opaque, hwaddr addr, uint32_t size)
+{
+    struct xen_battery_manager *xbm = opaque;
+    uint64_t system_state = 0x0000000000000000ULL;
+
+    xen_battery_update_battery_present(xbm);
+
+    xen_battery_update_bif(&(xbm->batteries[0]), 0);
+
+    if (NULL != xbm->batteries[0]._bif) {
+        system_state |= BATTERY_PRESENT;
+    }
+
+    if (1 == xbm->batteries[0].bif_changed) {
+        xbm->batteries[0].bif_changed = 0;
+        system_state |= BATTERY_INFO_UPDATE;
+    }
+
+    XBM_DPRINTF("BAT0 system_state == 0x%02llx\n", system_state);
+    return system_state;
+}
+
+struct MemoryRegionOps port_3_ops = {
+    .read = battery_port_3_read,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = {
+        .min_access_size = 1,
+        .max_access_size = 1,
+    },
+};
+
+/*
+ * Battery 2 (BAT1) status IO port write.
+ *
+ * Returns BATTERY_PRESENT (0x01) if battery present.
+ *         BATTERY_INFO_UPDATE (0x80) if battery information is updated.
+ */
+static uint64_t battery_port_4_read(void *opaque, hwaddr addr, uint32_t size)
+{
+    struct xen_battery_manager *xbm = opaque;
+    uint64_t system_state = 0x0000000000000000ULL;
+
+    xen_battery_update_battery_present(xbm);
+
+    xen_battery_update_bif(&(xbm->batteries[1]), 1);
+
+    if (NULL != xbm->batteries[1]._bif) {
+        system_state |= BATTERY_PRESENT;
+    }
+
+    if (1 == xbm->batteries[1].bif_changed) {
+        xbm->batteries[1].bif_changed = 0;
+        system_state |= BATTERY_INFO_UPDATE;
+    }
+
+    XBM_DPRINTF("BAT1 system_state == 0x%02llx\n", system_state);
+    return system_state;
+}
+
+struct MemoryRegionOps port_4_ops = {
+    .read = battery_port_4_read,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = {
+        .min_access_size = 1,
+        .max_access_size = 1,
+    },
+};
+
+static void battery_port_5_write(void *opaque, hwaddr addr,
+                                 uint64_t val, uint32_t size)
+{
+    struct xen_battery_manager *xbm = opaque;
+
+    XBM_DPRINTF("opaque(%p) addr(0x%x) val(%llu) size(%u)\n",
+                opaque, (uint32_t)addr, val, size);
+
+    if ((val > 0) && (val <= MAX_BATTERIES)) {
+        xbm->index = ((uint8_t)val) - 1;
+        XBM_DPRINTF("Current battery is %u\n", xbm->index);
+    }
+}
+
+struct MemoryRegionOps port_5_ops = {
+    .write = battery_port_5_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = {
+        .min_access_size = 1,
+        .max_access_size = 1,
+    },
+};
+
+struct {
+    struct MemoryRegionOps const *ops;
+    hwaddr base;
+    char const *name;
+    uint64_t size;
+} opsTab[] = {
+    { .ops = &port_1_ops,
+      .base = BATTERY_PORT_1,
+      .name = "acpi-xbm1",
+      .size = 1, },
+    { .ops = &port_2_ops,
+      .base = BATTERY_PORT_2,
+      .name = "acpi-xbm2",
+      .size = 1, },
+    { .ops = &port_3_ops,
+      .base = BATTERY_PORT_3,
+      .name = "acpi-xbm3",
+      .size = 1, },
+    { .ops = &port_4_ops,
+      .base = BATTERY_PORT_4,
+      .name = "acpi-xbm4",
+      .size = 1, },
+    { .ops = &port_5_ops,
+      .base = BATTERY_PORT_5,
+      .name = "acpi-xbm5",
+      .size = 1, },
+    /* /!\ END OF ARRAY */
+    { .ops = NULL, .base =  0, .name = NULL, },
+};
+
+static void xen_battery_register_ports(XenACPIPMState *s)
+{
+    int i;
+
+    for (i = 0; (NULL != opsTab[i].name); i++) {
+        memory_region_init_io(&s->xbm.mr[i], OBJECT(s), opsTab[i].ops,
+                              &s->xbm, opsTab[i].name, opsTab[i].size);
+        memory_region_add_subregion(s->space_io, opsTab[i].base,
+                                    &s->xbm.mr[i]);
+    }
+}
+
+/* -------/ Support/AC/lid /------------------------------------------------ */
+
+/*
+ * Update the AC adapter state.
+ *
+ * Note the default is 1 since the ac_adapter values is not written on
+ * non-portable systems like desktops. But they have an AC adapter or they
+ * could not start.
+ */
+static void xen_pm_update_ac_adapter(XenACPIPMState *s)
+{
+    int32_t value;
+
+    if (0 != xen_pm_read_int("ac_adapter", 1, &value)) {
+        XBM_DPRINTF("[note] unable to update the ac_adapter present status\n");
+        s->ac_adapter_present = 1;
+        return;
+    }
+
+    s->ac_adapter_present = value;
+}
+
+/*
+ * Update the AC lid state.
+ *
+ * Note the default is 1 since the lid_state_open is not written on systems
+ * that do not have an attached panel. This is for consistency.
+ */
+static void xen_pm_update_lid_state(XenACPIPMState *s)
+{
+    int32_t value;
+
+    if (0 != xen_pm_read_int("lid_state", 1, &value)) {
+        XBM_DPRINTF("[note] unable to update the lid_state status\"\n");
+        s->lid_state_open = 1;
+        return;
+    }
+
+    s->lid_state_open = value;
+}
+
+/*
+ * General ACPI PM status register.
+ *
+ * Reports whether the Xen APCI PM device model is operational; if we are even
+ * here then that it true so it always returnst that bit. The current AC
+ * (plugged in or not) and lid (open or closed) states are also reported.
+ *
+ * Returns 0x01 - Xen ACPI PM device model present and enabled.
+ *         0x02 - Lid open
+ *         0x04 - AC power on
+ *         0x80 - Not present mode (no other bits set)
+ */
+static uint64_t acpi_pm_port_sts_read(void *opaque, hwaddr addr, uint32_t size)
+{
+    XenACPIPMState *s = opaque;
+    uint64_t system_state = 0x0000000000000000ULL;
+
+    system_state |= ACPI_PM_STATUS_ENABLED;
+
+    if (s->not_present_mode) {
+        /* Report disabled devices through _STA and lid open through _LID */
+        return (system_state | ACPI_PM_STATUS_NOT_PRESENT | ACPI_PM_STATUS_LID_OPEN);
+    }
+
+    xen_pm_update_ac_adapter(s);
+    xen_pm_update_lid_state(s);
+
+    system_state |= (s->lid_state_open ? ACPI_PM_STATUS_LID_OPEN : 0);
+    system_state |= (s->ac_adapter_present ? ACPI_PM_STATUS_AC_ON : 0);
+
+    return system_state;
+}
+
+struct MemoryRegionOps port_sts_ops = {
+    .read = acpi_pm_port_sts_read,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = {
+        .min_access_size = 1,
+        .max_access_size = 1,
+    },
+};
+
+static void xen_acpi_pm_register_port(XenACPIPMState *s)
+{
+    memory_region_init_io(&s->mr, OBJECT(s), &port_sts_ops, s, "acpi-pm-sts", 1);
+    memory_region_add_subregion(s->space_io, ACPI_PM_STATUS_PORT, &s->mr);
+}
+
+/* -------/ Power Button Status /------------------------------------------- */
+
+/*
+ * Report SLP/WAK bits for power and sleep buttons.
+ *
+ * Returns bits set
+ */
+static uint64_t acpi_button_sts_read(void *opaque, hwaddr addr, uint32_t size)
+{
+    XenACPIPMState *s = opaque;
+    if (addr == 0) {
+        return s->button_status;
+    }
+
+    return 0xff;
+}
+
+/*
+ * Track state of SLP/WAK bits for power and sleep buttons.  The fields
+ * are WriteAsZero, writing 1 clears the bit.
+ */
+static void acpi_button_sts_write(void * opaque, hwaddr addr,
+                                  uint64_t val, uint32_t size)
+{
+    XenACPIPMState *s = opaque;
+
+    if (addr == 0) {
+        s->button_status &= ~val;
+    }
+}
+
+struct MemoryRegionOps port_button_sts_ops = {
+    .read = acpi_button_sts_read,
+    .write = acpi_button_sts_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .impl = {
+        .min_access_size = 1,
+        .max_access_size = 1,
+    },
+};
+
+static void xen_acpi_register_button_ports(XenACPIPMState *s)
+{
+    memory_region_init_io(&s->bmr, OBJECT(s), &port_button_sts_ops, s,
+                          "acpi-button-status", 1);
+    memory_region_add_subregion(s->space_io, ACPI_POWER_BUTTON_PORT, &s->bmr);
+}
+
+/* -------/ Xenstore watches /---------------------------------------------- */
+
+static void sleep_button_changed_cb(void *opaque)
+{
+    XenACPIPMState *s = opaque;
+
+    s->button_status |= ACPI_SLP_BIT;
+    piix4_pm_set_gpe_sts_raise_sci(s->piix4_dev, ACPI_PM_SLEEP_BUTTON);
+}
+
+static void power_button_changed_cb(void *opaque)
+{
+    XenACPIPMState *s = opaque;
+
+    s->button_status |= ACPI_SLP_BIT;
+    piix4_pm_set_gpe_sts_raise_sci(s->piix4_dev, ACPI_PM_POWER_BUTTON);
+}
+
+#define MAKE_ACPI_PM_CALLBACK(pfx, bit)                \
+static void pfx##_changed_cb(void *opaque)             \
+{                                                      \
+    XenACPIPMState *s = opaque;                        \
+    piix4_pm_set_gpe_sts_raise_sci(s->piix4_dev, bit); \
+}
+
+MAKE_ACPI_PM_CALLBACK(lid_status, ACPI_PM_LID_STATUS)
+MAKE_ACPI_PM_CALLBACK(ac_power_status, ACPI_PM_AC_POWER_STATUS)
+MAKE_ACPI_PM_CALLBACK(battery_status, ACPI_PM_BATTERY_STATUS)
+MAKE_ACPI_PM_CALLBACK(battery_info, ACPI_PM_BATTERY_INFO)
+
+struct {
+    char const *base;
+    char const *node;
+    xenstore_watch_cb_t cb;
+    uint8_t not_present_mode;
+    uint8_t set;
+} watchTab[] = {
+    { .base = "/pm/events",
+      .node = "sleepbuttonpressed",
+      .cb = sleep_button_changed_cb,
+      .not_present_mode = 1,
+      .set = 0, },
+    { .base = "/pm/events",
+      .node = "powerbuttonpressed",
+      .cb = power_button_changed_cb,
+      .not_present_mode = 1,
+      .set = 0, },
+    { .base = "/pm",
+      .node = "lid_state",
+      .cb = lid_status_changed_cb,
+      .not_present_mode = 0,
+      .set = 0, },
+    { .base = "/pm",
+      .node = "ac_adapter",
+      .cb = ac_power_status_changed_cb,
+      .not_present_mode = 0,
+      .set = 0, },
+    { .base = "/pm/events",
+      .node = "batterystatuschanged",
+      .cb = battery_status_changed_cb,
+      .not_present_mode = 0,
+      .set = 0, },
+    { .base = "/pm",
+      .node = "battery_present",
+      .cb = battery_info_changed_cb,
+      .not_present_mode = 0,
+      .set = 0, },
+    /* /!\ END OF ARRAY */
+    { .base =  NULL, .node = NULL, .cb = NULL, .not_present_mode = 0, .set = 0},
+};
+
+static int xen_acpi_pm_init_gpe_watches(XenACPIPMState *s)
+{
+    int i, err;
+
+    for (i = 0; (NULL != watchTab[i].base); i++) {
+        if (s->not_present_mode && !watchTab[i].not_present_mode) {
+            continue;
+        }
+
+        err = xenstore_add_watch(watchTab[i].base, watchTab[i].node,
+                                 watchTab[i].cb, s);
+        if (err) {
+             XBM_ERROR_MSG("failed to register watch for %s/%s err: %d\n",
+                           watchTab[i].base, watchTab[i].node, err);
+             return -1;
+        }
+        watchTab[i].set = 1;
+    }
+
+    return 0;
+}
+
+/* -------/ Guest Shutdown /------------------------------------------------ */
+
+static int xen_acpi_domain_pm_watch(XenACPIPMState *s)
+{
+   char base[XEN_BUFSIZE];
+   int err;
+
+   snprintf(base, sizeof(base), "/local/domain/%d/control", xen_domid);
+
+   err = xenstore_add_watch(base, "hvm-shutdown", power_button_changed_cb, s);
+
+   if (err) {
+        XBM_ERROR_MSG("failed to register watch for %s/%s err: %d\n",
+                      base, "hvm-shutdown", err);
+        return -1;
+   }
+   return 0;
+}
+
+void xen_acpi_pm_gpe_ioport_writeb(uint8_t gpe_len, uint32_t addr,
+				   uint32_t val)
+{
+    char base[XEN_BUFSIZE];
+    int err;
+
+    if ((addr < gpe_len / 2)||(addr >= gpe_len)) {
+       /* GPE_STS or invalid, don't care */
+	 	return;
+    }
+
+    /*
+     * GPE_EN - the power button bit _L06 is in the first byte of the enable
+     * register bank, which is addr == 0.
+     */
+    if (((addr - (gpe_len / 2)) == 0) && (val & (1 << ACPI_PM_POWER_BUTTON))) {
+        snprintf(base, sizeof(base), "/local/domain/%d/control", xen_domid);
+
+        err = xenstore_write_int(base, "hvm-powerbutton-enable", 1);
+        if (err) {
+            XBM_ERROR_MSG("failed to write xs for %s/%s err: %d\n",
+                          base, "hvm-powerbutton-enable", err);
+        }
+    }
+}
+
+/* -------/ Initialization /------------------------------------------------ */
+
+static int xen_acpi_pm_initfn(SysBusDevice *sbd)
+{
+    XenACPIPMState *s = XEN_ACPI_PM(sbd);
+    int i;
+
+    /*
+     * First check if there are any /pm nodes to even work with. If not then
+     * use not present mode. This allows the sleep and power buttons to still
+     * fucntion without batteries or AC present. This is done by having the
+     * _STA methods for battery and AC device report not present.
+     */
+    s->not_present_mode = 0;
+    if ( (0 != xen_pm_read_str("battery_present", NULL)) &&
+         (0 != xen_pm_read_str("ac_adapter", NULL)) ) {
+        fprintf(stdout, "Xen ACPI PM AC/battery not present mode\n");
+        s->not_present_mode = 1;
+    }
+
+    memset(&s->xbm, 0, sizeof(struct xen_battery_manager));
+    for (i = 0; i < MAX_BATTERIES; i++) {
+        s->xbm.batteries[i].bif_changed = 1;
+    }
+
+    if (0 != xen_battery_init_mode(&s->xbm)) {
+        goto error_init;
+    }
+
+    if (!s->not_present_mode) {
+        if (0 != xen_battery_update_battery_present(&s->xbm)) {
+            goto error_init;
+        }
+
+        if (0 != xen_battery_update_status_info(&s->xbm)) {
+            goto error_init;
+        }
+    }
+
+    switch (s->xbm.mode) {
+    case XEN_BATTERY_MODE_HVM:
+        XBM_DPRINTF("Emulated mode\n");
+        xen_battery_register_ports(s);
+        break;
+    case XEN_BATTERY_MODE_PT:
+        XBM_ERROR_MSG("Mode Pass Through no longer supported for security reasons\n");
+        goto error_init;
+        break;
+    case XEN_BATTERY_MODE_NONE:
+    default:
+        XBM_ERROR_MSG("Mode (0x%02x) unsupported\n", s->xbm.mode);
+        goto error_init;
+    }
+
+    if (!s->not_present_mode) {
+        xen_pm_update_ac_adapter(s);
+        xen_pm_update_lid_state(s);
+    }
+
+    xen_acpi_pm_register_port(s);
+    xen_acpi_register_button_ports(s);
+    s->button_status = 0;
+
+    if (0 != xen_acpi_pm_init_gpe_watches(s)) {
+        goto error_init;
+    }
+
+    if (0 != xen_acpi_domain_pm_watch(s)) {
+        goto error_init;
+    }
+
+    fprintf(stdout, "Xen ACPI PM initialized\n");
+
+    return 0;
+
+error_init:
+    XBM_ERROR_MSG("Unable to initialize the Xen ACPI PM feature\n");
+    return -1;
+}
+
+void xen_acpi_pm_create(MemoryRegion *space_io, void *opaque)
+{
+    DeviceState *dev;
+
+    dev = qdev_create(NULL, TYPE_XEN_ACPI_PM);
+    qdev_prop_set_ptr(dev, "space_io", space_io);
+    qdev_prop_set_ptr(dev, "piix4_dev", opaque);
+    qdev_init_nofail(dev);
+}
+
+static Property xen_acpi_pm_properties[] = {
+    DEFINE_PROP_PTR("space_io", XenACPIPMState, space_io),
+    DEFINE_PROP_PTR("piix4_dev", XenACPIPMState, piix4_dev),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void xen_acpi_pm_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
+
+    k->init = xen_acpi_pm_initfn;
+    dc->props = xen_acpi_pm_properties;
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+    dc->desc = "Xen ACPI PM device";
+}
+
+static const TypeInfo xen_acpi_pm_info = {
+    .name = TYPE_XEN_ACPI_PM,
+    .parent = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(XenACPIPMState),
+    .class_init = xen_acpi_pm_class_init,
+};
+
+static void xen_acpi_pm_register_types(void)
+{
+    type_register_static(&xen_acpi_pm_info);
+}
+
+type_init(xen_acpi_pm_register_types)
--- a/include/hw/i386/pc.h
+++ b/include/hw/i386/pc.h
@@ -240,6 +240,7 @@ int cmos_get_fd_drive_type(FloppyDriveTy
 I2CBus *piix4_pm_init(PCIBus *bus, int devfn, uint32_t smb_io_base,
                       qemu_irq sci_irq, qemu_irq smi_irq,
                       int smm_enabled, DeviceState **piix4_pm);
+void piix4_pm_set_gpe_sts_raise_sci(void *opaque, uint8_t bit);
 
 /* hpet.c */
 extern int no_hpet;
--- /dev/null
+++ b/include/hw/xen/xen_acpi_pm.h
@@ -0,0 +1,43 @@
+/*
+ * APCI PM feature for battery/AC/lid management for OpenXT guests.
+ *
+ * Copyright (C) 2014 Citrix Systems Ltd
+ * Copyright (c) 2015, Assured Information Security, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef XEN_ACPI_PM_H_
+#define XEN_ACPI_PM_H_
+
+#define TYPE_XEN_ACPI_PM "xen-acpi-pm"
+
+/*
+ * This function is use for the initialization of the battery/AC/lid devices.
+ * These device are linked to the ACPI devices in the ssdt_pm.asl module.
+ */
+void xen_acpi_pm_create(MemoryRegion *space_io, void *opaque);
+
+/* Set to enable the Xen ACPI PM device support */
+void xen_acpi_pm_set_enabled(bool enable);
+
+/* Get enabled/disable state of the ACPI PM device support */
+bool xen_acpi_pm_get_enabled(void);
+
+/* Inform Xen ACPI PM model of update to GPE registers */
+void xen_acpi_pm_gpe_ioport_writeb(uint8_t gpe_len, uint32_t addr,
+				   uint32_t val);
+
+#endif /* !XEN_ACPI_PM_H_ */
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -3415,6 +3415,9 @@ DEF("xen-domid-restrict", 0, QEMU_OPTION
     "                        to specified domain id. (Does not affect\n"
     "                        xenpv machine type).\n",
     QEMU_ARCH_ALL)
+DEF("xen-acpi-pm", 0, QEMU_OPTION_xen_acpi_pm,
+    "-xen-acpi-pm     use the Xen ACPI PM emulated battery/AC/lid feature\n",
+    QEMU_ARCH_ALL)
 STEXI
 @item -xen-domid @var{id}
 @findex -xen-domid
@@ -3429,6 +3432,9 @@ Attach to existing xen domain.
 xend will use this when starting QEMU (XEN only).
 @findex -xen-domid-restrict
 Restrict set of available xen operations to specified domain id (XEN only).
+@item -xen-acpi-pm
+@findex -xen-acpi-pm
+Use the Xen ACPI PM emulated battery/AC/lid feature.
 ETEXI
 
 DEF("no-reboot", 0, QEMU_OPTION_no_reboot, \
--- a/vl.c
+++ b/vl.c
@@ -132,6 +132,7 @@ int main(int argc, char **argv)
 #include "qapi/qapi-commands-ui.h"
 #include "qapi/qmp/qerror.h"
 #include "sysemu/iothread.h"
+#include "hw/xen/xen_acpi_pm.h"
 
 #define MAX_VIRTIO_CONSOLES 1
 
@@ -3865,6 +3866,15 @@ int main(int argc, char **argv, char **e
                 }
                 xen_domid_restrict = true;
                 break;
+            case QEMU_OPTION_xen_acpi_pm:
+                /* Use the OpenXT emulated battery/AC/lid devices */
+                if (!(xen_available())) {
+                    printf("Option %s not supported for this target\n",
+                           popt->name);
+                    exit(1);
+                }
+                xen_acpi_pm_set_enabled(true);
+                break;
             case QEMU_OPTION_trace:
                 g_free(trace_file);
                 trace_file = trace_opt_parse(optarg);
