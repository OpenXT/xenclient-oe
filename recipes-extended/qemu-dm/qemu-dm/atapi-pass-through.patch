--------------------------------------------------------------------------------
SHORT DESCRIPTION:
--------------------------------------------------------------------------------

Provide hardware passthrough capability for CD/DVD drives.

--------------------------------------------------------------------------------
LONG DESCRIPTION:
--------------------------------------------------------------------------------

Added to protocols for use with qemu -drive: atapi-pt-argo and atapi-pt-local

Invocation for non-stubdom qemu:
* -drive file=atapi-pt-local:<dom0 bsg dev path>,if=atapi-pt,media=cdrom
   [,format=raw][,readonly=on|off]

Invocation for stubdom qemu:
* -drive file=atapi-pt-argo:<dom0 bsg dev path>,if=atapi-pt,media=cdrom
   [,format=raw][,readonly=on|off]

Example:
  -drive file=atapi-pt-argo:/dev/bsg/1:0:0:0,if=atapi-pt,
   media=cdrom,format=raw,readonly=on

Logging:
* Watch is setup on /xenclient/bsgdev/<a>_<b>_<c>_<d>/loglevel
  where a,b,c,d refer to /dev/bsg/a:b:c:d
* To set standard informational logging (default):
  xenstore-write /xenclient/bsgdev/<a>_<b>_<c>_<d>/loglevel 0
* To set verbose logging:
  xenstore-write /xenclient/bsgdev/<a>_<b>_<c>_<d>/loglevel 1
* To set debug-level logging:
  xenstore-write /xenclient/bsgdev/<a>_<b>_<c>_<d>/loglevel 2

Toolstack device assignment:
* Command line APIs that control assignment:
 - xec -o /host [list-cd-devices|assign-cd-device|
                 get-cd-device-assignment|eject-cd-device]
* The toolstack notifies qemu that it may attempt to grab lock using xenstore:
 - /local/domain/<domid>/bsgdev-req/<a>_<b>_<c>_<d>/req-assign <= 1
* The toolstack notifies qemu that it is losing the lock using xenstore:
 - /local/domain/<domid>/bsgdev/<a>_<b>_<c>_<d>/lock <= (xenstore-rm)
 - /local/domain/<domid>/bsgdev-req/<a>_<b>_<c>_<d>/req-assign <= 1
 - /local/domain/<domid>/bsgdev-req/<a>_<b>_<c>_<d>/req-eject <= 1
* Qemu must respond to assignment requests with:
 - /local/domain/<domid>/bsgdev-req/<a>_<b>_<c>_<d>/req-assign <= (xenstore-rm)
 - /local/domain/<domid>/bsgdev-req/<a>_<b>_<c>_<d>/req-eject <= (xenstore-rm)
* When device lock successfully obtained, Qemu must notify with:
 - /local/domain/<domid>/bsgdev/<a>_<b>_<c>_<d>/lock <= 1

Autolock:
* Command line APIs that control autolock:
 - xec get autolock-cd-drives | xec set autolock-cd-drives [true|false]
* autolock: a VM may attempt to grab exclusive lock of a DVD if it has focus.
If obtained, lock will be given up when disk is ejected or VM shuts down.
* No autolock: only specified VM may be given lock.

Global media state:
* Global media state is available, per device with the following xenstore key:
 - /xenclient/bsgdev/<a>_<b>_<c>_<d>/media <= [0|1]
* atapi pt instance with lock will update global media state when detecting
changes to the state. It's not guaranteed to be correct, as there are cases
where state isn't detected correctly by toolstack.  But in general it's just
used for notifications to a guest if it obtains lock after initial boot.

Exclusive device lock:
* Device locking is held exclusively /var/log/xen-atapi-pt-lock-<a>_<b>_<c>_<d>
using the fnctl() control.  If VM does not hold this lock, it will not be given
full access to the drive.
* In addition to the fcntl()-based lock to guarantee exclusivity, the qemu
instance obtaining the lock will inform the toolstack/system as specified
above in assignment discussion.

--------------------------------------------------------------------------------
UPSTREAM PLAN
--------------------------------------------------------------------------------

Unlikely to upstream.  They have a SCSI passthrough capability
and the current "host_cdrom" support is limited.

--------------------------------------------------------------------------------
KNOWN ISSUES
--------------------------------------------------------------------------------

1) Specific commands always allowed through to drive
   with policy-cd-access=true but w/o lock

* There are a number of commands that are allowed to go to the drive, even if the
VM sending them does not own the exclusive lock.  There are a number of reasons
which make this necessary in the current approach for atapi-pt (notably, 
allowing quick dynamic "hotplug"-esque usage across VMs without affecting
functionality. Commands include:
 - GPCMD_GET_CONFIGURATION
 - GPCMD_GET_EVENT_STATUS_NOTIFICATION
 - GPCMD_TEST_UNIT_READY
 - GPCMD_GET_PERFORMANCE
 - GPCMD_MECHANISM_STATUS
 - GPCMD_MODE_SENSE_10
 - GPCMD_REPORT_KEY
 - GPCMD_READ_CDVD_CAPACITY
 - GPCMD_READ_FORMAT_CAPACITIES
** Data could possibly be discovered by VMs that the user does not expect to be
able to access the drive, with the above commands.
** VMs without lock could be sending these commands to the drive during
critical times (e.g. user is burning a DVD), perhaps causing an error.

2) Certain commands are blocked regardless of lock

* There are a number of commands that are blocked regardless of exclusive lock,
to ensure the device state is consistent for all VMs.  (e.g. VM cannot issue
command to prevent ejecting the tray, but then loses lock before releasing).
Commands include:
 - GPCMD_START_STOP_UNIT / stop motor command
 - GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL

--------------------------------------------------------------------------------
FUTURE WORK
--------------------------------------------------------------------------------

In my opinion, a lot of the complexity comes from allowing autolock & hotplug
style functionality without a true hotplug solution.  It would make the most
sense to require a DVD be assigned to a specific VM at boot time, or get proper
hotplugging of the device into the VM.  Then once a disk is released from a VM,
the mediator could clean up the state of the device to be ready for the next VM.
This could address both issues #1 and #2, but would restrict present
functionality.

--------------------------------------------------------------------------------
DEPENDENCIES
--------------------------------------------------------------------------------

generic-xenstore-extensions

--------------------------------------------------------------------------------
CHANGELOG
--------------------------------------------------------------------------------

OpenXT, Citrix, Initial Commit.

Chris Patterson, <pattersonc@ainfosec.com>, 03/02/2015

* use protocol instead of format specifiers:
 - atapi-pt created a two protocols: atapi-pt-argo and atapi-pt-local.
 - example invocation:
 -- -drive file=atapi-pt-local:/dev/bsg/1:0:0:0,if=atapi-pt,media=cdrom[,format=raw]
* build options
 - to build, two config options added to control feature inclusion:
 -- --enable-atapi-pt to enable local pt functionality
 -- --enable-atapi-pt-argo to further enable argo remoting
 - Activate patches according to those switches, as well
   as work on vanilla qemu outside of xt using atapi-pt-local.
* drop "xenclient" references (sufficiently indicated with CONFIG_ATAPI_PT)
* some formatting (indent'd) for consistency within files (tabs to spaces, etc)
* dropped pt.c
* added some TODOs for open questions/concerns
* close argo socket on disconnect

Chris Patterson, <pattersonc@ainfosec.com>, 03/31/2015

* removed shared memory interfaces in favor of exclusive usage of xenstore-based
communication mechanisms and fnctl-based lock in dom0
* added xenstore watches for all applicable xenstore communicated flag keys
  - xenstore reads now occur only on initialization
* implemented device locking for both autolock and no-autolock
* re-wrote protocol to communicate between atapi_pt_helper and stubdom
  - well defined message structures, added significant error checking
  - added atapi_pt_argo.h to be the common interface with atapi_pt_helper
  - strictly defined SG_IO message passing to dom0
* modified logging interfaces to support runtime log level specification, as
well as be consistent across all atapi-pt components.
* use readonly= flag to specify whether or not write commands are allowed
(for policy-cd-recording)
* formatting refactoring, consistent C style
* added lots of comments where I found them to be useful
* simplified eject/insert notification mechanisms
* (re)added fake_inquiry that seemed to be dropped in original qemu 14 port
* simplified atapi_pt_cmd handling to be more consistent
* drop changes to struct BlockDriver, and hijack usage of ioctl for comms
  - added atapi_pt_ioctl.h to define interfaces between atapi_pt backend
    and protocol level

Signed-off-by: Chris Patterson <pattersonc@ainfosec.com>

Ross Philipson, <philipsonr@ainfosec.com>, 10/13/2016

--- a/block.c
+++ b/block.c
@@ -5493,3 +5493,21 @@ bool bdrv_can_store_new_dirty_bitmap(Blo
 
     return drv->bdrv_can_store_new_dirty_bitmap(bs, name, granularity, errp);
 }
+
+/* OpenXT: direct IOCTL delivery for ATAPI PT.
+ *
+ * This adds back the synchronous bdrv_ioctl that existed in 1.4. It is not
+ * clear the current implementation of the ATAPI PT code will currently work
+ * using the AIO method.
+ *
+ * TODO look into refactoring ATAPI PT to use bdrv_aio_ioctl.
+ * See OXT-772
+ */
+int bdrv_direct_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
+{
+    BlockDriver *drv = bs->drv;
+
+    if (drv && drv->bdrv_direct_ioctl)
+        return drv->bdrv_direct_ioctl(bs, req, buf);
+    return -ENOTSUP;
+}
--- a/block/Makefile.objs
+++ b/block/Makefile.objs
@@ -18,6 +18,7 @@ block-obj-y += block-backend.o snapshot.
 block-obj-$(CONFIG_WIN32) += file-win32.o win32-aio.o
 block-obj-$(CONFIG_POSIX) += file-posix.o
 block-obj-$(CONFIG_LINUX_AIO) += linux-aio.o
+block-obj-$(CONFIG_ATAPI_PT) += atapi-pt-protocol.o
 block-obj-y += null.o mirror.o commit.o io.o create.o
 block-obj-y += throttle-groups.o
 block-obj-$(CONFIG_LINUX) += nvme.o
--- /dev/null
+++ b/block/atapi-pt-protocol.c
@@ -0,0 +1,1503 @@
+/*
+ * ATAPI guest commands translation.
+ *
+ * Copyright (C) 2015 Assured Information Security, Chris Patterson <pattersonc@ainfosec.com>
+ * Copyright (C) 2014 Citrix Systems Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "qapi/error.h"
+#include "qapi/qmp/qdict.h"
+#include "qapi/qmp/qstring.h"
+#include "qemu/module.h"
+#include "qemu/option.h"
+#include "block/block_int.h"
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/param.h>
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <linux/cdrom.h>
+#include <linux/fd.h>
+#include <linux/fs.h>
+#include <linux/cdrom.h>
+#include <linux/bsg.h>
+#include <scsi/sg.h>
+#include "hw/xen/xen_backend.h"
+
+
+#ifdef CONFIG_ATAPI_PT_ARGO
+#include <libargo.h>
+#endif
+
+#include "block/atapi_pt_ioctl.h"
+#include "block/atapi_pt_argo.h"
+
+typedef struct AtapiPtDeviceInfo {
+    /* /dev/bsg/a:b:c:d */
+    char device_path[256];
+
+    char xenstore_domain_base[256];
+    char xenstore_bsgdev_base[256];
+    char xenstore_bsgdevreq_base[256];
+    char xenstore_global_base[256];
+
+    /* a:b:c:d */
+    int device_addr_a;
+    int device_addr_b;
+    int device_addr_c;
+    int device_addr_d;
+
+    /* associated IDEState pointer */
+    void *ide_state;
+
+    /* xenstore-tied flags */
+    int lock_state;
+    int media_state;
+    int have_focus;
+    int autolock;
+    int assigned;
+
+    bool readonly;
+    BlockDriverState *bs;
+} AtapiPtDeviceInfo;
+
+int pt_log_level = 0;
+
+/**
+ * PT_LOG: information to always log (errors & important low-volume events)
+ * @param fmt,... printf style arguments
+ */
+#define PT_LOG(fmt, ...)                                                   \
+    do {                                                                   \
+            fprintf(stdout, "[%s:%s:%d] " fmt,                             \
+                    __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__);      \
+    } while (0)
+
+/**
+ * PT_VERBOSE: verbose level
+ * @param fmt,... printf style arguments
+ */
+#define PT_VERBOSE(fmt, ...)                                              \
+    do {                                                                  \
+        if (pt_log_level >= 1)                                            \
+            PT_LOG(fmt, ## __VA_ARGS__);                                  \
+    } while (0)
+
+/**
+ * PT_DEBUG: debug level
+ * @param fmt,... printf style arguments
+ */
+#define PT_DEBUG(fmt, ...)                                               \
+    do {                                                                 \
+        if (pt_log_level >= 2)                                           \
+            PT_LOG(fmt, ## __VA_ARGS__);                                 \
+    } while (0)
+
+typedef struct BDRVPosixPassThroughState {
+    /* device descriptor */
+    int fd;
+    int open_flags;
+
+    /* fcntl lock */
+    int lock_fd;
+    char lock_file_name[1024];
+
+    AtapiPtDeviceInfo dev_info;
+} BDRVPosixPassThroughState;
+
+static QemuOptsList runtime_opts = {
+    .name = "atapi-pt",
+    .head = QTAILQ_HEAD_INITIALIZER(runtime_opts.head),
+    .desc = {
+        {
+            .name = "filename",
+            .type = QEMU_OPT_STRING,
+            .help = "ATAPI PT file name",
+        },
+        { /* end of list */ }
+    },
+};
+
+/**
+ * Notify xenstore about local locking status.
+ * @param[in] info
+ * @param[in] locked: true if locking, false if unlocking
+ */
+static void notify_xs_lock_state(AtapiPtDeviceInfo *info, bool locked)
+{
+    /* write change */
+    if (locked) {
+       xenstore_write_str(info->xenstore_bsgdev_base, "lock", "1");
+    } else {
+       xenstore_rm(info->xenstore_bsgdev_base, "lock");
+    }
+}
+
+/**
+ * Xenstore callback for global media state.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void glob_mediastate_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+
+    if (xenstore_read_int(info->xenstore_global_base, "media",
+                          &info->media_state) != 0) {
+        info->media_state = 0;
+    }
+
+    PT_LOG("media state change detected %s = %d\n",
+            info->device_path, info->media_state);
+
+    /* if autolock is enabled and media is ejected - release lock */
+    if (info->autolock && !info->media_state) {
+        info->assigned = 0;
+        bdrv_direct_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+}
+
+/**
+ * Xenstore callback for log level changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void loglevel_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+
+    if (xenstore_read_int(info->xenstore_global_base,
+                          "loglevel", &pt_log_level) != 0) {
+        pt_log_level = 0;
+    }
+
+    PT_LOG("loglevel change detected %s = %d\n",
+           info->device_path, pt_log_level);
+}
+
+/**
+ * Xenstore callback for lock changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void lock_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int lock = 0;
+
+    if (xenstore_read_int(info->xenstore_bsgdev_base, "lock", &lock) != 0) {
+        /* toolstack rm'd the lock key - we are losing the lock */
+        lock = -1;
+    }
+
+    PT_LOG("lock change detected %s = %d\n", info->device_path, lock);
+
+    /* release the lock if we are losing assignment */
+    if (lock == -1) {
+        info->assigned = 0;
+        bdrv_direct_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+}
+
+/**
+ * Xenstore callback for autolock changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void autolock_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int saved_autolock = info->autolock;
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "autolock",
+                          &info->autolock) != 0) {
+        info->autolock = -1;
+    }
+
+    /* to reduce spurious autolock "changes", log only actual changes */
+    if (saved_autolock != info->autolock) {
+        PT_LOG("autolock change detected %s: %d->%d\n",
+               info->device_path, saved_autolock, info->autolock);
+    }
+}
+
+/**
+ * Xenstore callback for switcher's have_focus changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void have_focus_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+
+    if (xenstore_read_int(info->xenstore_domain_base, "switcher/have_focus",
+                          &info->have_focus) != 0) {
+        /* if have_focus key does not exist - we don't have focus */
+        info->have_focus = 0;
+    }
+
+    PT_LOG("focus change detected %s = %d\n",
+            info->device_path, info->have_focus);
+}
+
+/**
+ * Xenstore callback for req-eject changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void eject_req_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int eject = 0;
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "req-eject",
+                          &eject) != 0) {
+        /* probably just catching the rm */
+        return;
+    }
+
+    PT_LOG("eject request detected %s = %d\n", info->device_path, eject);
+
+    if (eject) {
+        info->assigned = 0;
+        bdrv_direct_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+
+    /* ack receipt of request */
+    xenstore_rm(info->xenstore_bsgdevreq_base, "req-eject");
+}
+
+/**
+ * Xenstore callback for req-assign changes.
+ * @param[in] opaque: AtapiPtDeviceInfo *
+ */
+static void assign_req_cb(void *opaque)
+{
+    AtapiPtDeviceInfo *info = (AtapiPtDeviceInfo *) opaque;
+    int assign = 0;
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "req-assign",
+                          &assign) != 0) {
+        /* probably just catching the rm */
+        return;
+    }
+
+    PT_LOG("assign_req_cb: assign detected %s = %d\n",
+           info->device_path, assign);
+
+    info->assigned = assign;
+
+    if (assign) {
+        bdrv_direct_ioctl(info->bs, ATAPI_PT_ACQUIRE_LOCK, NULL);
+
+        /* print a warning if we fail to get lock after assignment */
+        if (info->lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+            PT_LOG("warning: device assigned but unable to grab lock for %s\n",
+                   info->device_path);
+            PT_LOG("autolock=%d media_state=%d lock_state=%d assigned=%d\n",
+                   info->autolock, info->media_state,
+                   info->lock_state, info->assigned);
+        }
+    } else {
+        bdrv_direct_ioctl(info->bs, ATAPI_PT_RELEASE_LOCK, NULL);
+    }
+
+    /* ack receipt of request */
+    xenstore_rm(info->xenstore_bsgdevreq_base, "req-assign");
+}
+
+
+/**
+ * Checks to see if the device is in a lockable state (or already locked).
+ * @param[in] info
+ */
+static bool is_lockable(AtapiPtDeviceInfo *info)
+{
+    /* it is "lockable" if we currently have the lock */
+    if (info->lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        return true;
+    }
+
+    /* if assigned, assume lockable */
+    if (info->assigned) {
+        return true;
+    }
+
+    /* if autolock is enabled, lockable only if we have focus & cd is present */
+    if (info->autolock && info->have_focus && info->media_state) {
+       return true;
+    }
+
+    return false;
+}
+
+/**
+ * Sets global media state, and releases lock if held and media is not present.
+ * @param[in] info
+ * @param[in] media_present: 1 if media is present, 0 otherwise
+ */
+static void set_global_media_state(AtapiPtDeviceInfo *info, int media_present)
+{
+    info->media_state = media_present;
+
+    PT_LOG("set_global_media_state: %d\n", info->media_state);
+
+    if (xenstore_write_int(info->xenstore_global_base, "media",
+                           info->media_state) != 0) {
+        PT_LOG("failed to set media state\n");
+    }
+}
+
+/**
+ * Set up AtapiPtDeviceInfo structure and init xenstore watches.
+ * @param[in] info
+ * @param[in] filename: device path (format=/dev/bsg/a:b:c:d)
+ * @param[in] bs
+ * @returns true if init OK, otherwise false.
+ */
+static bool atapi_pt_device_info_init(AtapiPtDeviceInfo *info,
+                                      const char *filename,
+                                      BlockDriverState *bs)
+{
+    char path[256];
+
+    memset(info, 0, sizeof(*info));
+
+    info->bs = bs;
+
+    if (sscanf(filename, "/dev/bsg/%d:%d:%d:%d", &info->device_addr_a,
+                                                &info->device_addr_b,
+                                                &info->device_addr_c,
+                                                &info->device_addr_d) != 4) {
+        PT_LOG("error: failed to parse device\n");
+        return false;
+    }
+
+    strncpy(info->device_path, filename, sizeof(info->device_path) - 1);
+    info->device_path[sizeof(info->device_path) - 1] = 0;
+
+    snprintf(info->xenstore_domain_base, sizeof(info->xenstore_domain_base),
+             "/local/domain/%d", xen_domid);
+
+    snprintf(info->xenstore_bsgdev_base, sizeof(info->xenstore_bsgdev_base),
+             "/local/domain/%d/bsgdev/%d_%d_%d_%d",
+             xen_domid,
+             info->device_addr_a,
+             info->device_addr_b,
+             info->device_addr_c,
+             info->device_addr_d);
+
+    snprintf(info->xenstore_bsgdevreq_base,
+             sizeof(info->xenstore_bsgdevreq_base),
+             "/local/domain/%d/bsgdev-req/%d_%d_%d_%d",
+             xen_domid,
+             info->device_addr_a,
+             info->device_addr_b,
+             info->device_addr_c,
+             info->device_addr_d);
+
+    snprintf(info->xenstore_global_base, sizeof(info->xenstore_global_base),
+             "/xenclient/bsgdev/%d_%d_%d_%d",
+             info->device_addr_a,
+             info->device_addr_b,
+             info->device_addr_c,
+             info->device_addr_d);
+
+    /* make sure we can talk to xenstore */
+    xenstore_generic_init();
+
+    /* register xenstore watches */
+    if (xenstore_add_watch(info->xenstore_bsgdevreq_base, "req-eject",
+                            eject_req_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_bsgdevreq_base, "req-assign",
+                            assign_req_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_bsgdevreq_base, "autolock",
+                            autolock_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_global_base, "media",
+                            glob_mediastate_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_global_base, "loglevel",
+                            loglevel_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_bsgdev_base, "lock",
+                            lock_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_add_watch(info->xenstore_domain_base, "switcher/have_focus",
+                            have_focus_cb, info) != 0) {
+        PT_LOG("error: failed to register watch for %p\n", path);
+        return false;
+    }
+
+    if (xenstore_read_int(info->xenstore_bsgdevreq_base, "autolock",
+                          &info->autolock) != 0) {
+        info->autolock = 0;
+    }
+
+    if (xenstore_read_int(info->xenstore_global_base, "media",
+                          &info->media_state) != 0) {
+        info->media_state = 0;
+    }
+
+    if (xenstore_read_int(info->xenstore_domain_base,
+                          "switcher/have_focus", &info->have_focus) != 0) {
+        info->have_focus = 0;
+    }
+
+    if (xenstore_read_int(info->xenstore_bsgdev_base,
+                          "lock", &info->lock_state) != 0) {
+        info->lock_state = 0;
+    }
+
+    /* trigger assign callback in case we have already been issued assignment */
+    assign_req_cb(info);
+    loglevel_cb(info);
+
+    PT_LOG("autolock=%d media_state=%d lock_state=%d assigned=%d\n",
+           info->autolock, info->media_state, info->lock_state, info->assigned);
+
+    return true;
+}
+
+/**
+ * Convert open flags appropriately for pt local device.
+ * @param[in] bdrv_flags: block driver flags from qemu
+ * @param[in] open_flags: device open flags
+ * @returns updated open flags
+ */
+static int pt_local_parse_open_flags(int bdrv_flags, int open_flags)
+{
+    open_flags |= O_BINARY;
+    open_flags &= ~O_ACCMODE;
+    if (bdrv_flags & BDRV_O_RDWR) {
+        open_flags |= O_RDWR;
+    } else {
+        open_flags |= O_RDONLY;
+    }
+
+    /* Use O_DSYNC for write-through caching, no flags for write-back caching,
+     * and O_DIRECT for no caching. */
+    if ((bdrv_flags & BDRV_O_NOCACHE)) {
+        open_flags |= O_DIRECT;
+    }
+
+    return open_flags;
+}
+
+/**
+ * If protocol matches, opens local device.
+ * @param[in] bs
+ * @param[in] filename: device path (e.g. /dev/bsg/a:b:c:d)
+ * @param[in] bdrv_flags: block driver flags from qemu
+ * @param[in] flags: device open flags
+ * @returns 0 if opened successfully, -1 otherwise
+ */
+static int pt_local_open_device(BlockDriverState *bs, const char *filename,
+                       int bdrv_flags, int open_flags)
+{
+    BDRVPosixPassThroughState *s = bs->opaque;
+    int fd;
+
+    PT_LOG("opening %s\n", filename);
+
+    s->open_flags = open_flags;
+    s->open_flags = pt_local_parse_open_flags(bdrv_flags, s->open_flags);
+
+    s->fd = -1;
+    fd = qemu_open(filename, s->open_flags, 0644);
+
+    if (fd < 0) {
+        PT_LOG("failed to open %s (%s)\n", filename, strerror(errno));
+        if (errno == EROFS) {
+            return -EACCES;
+        }
+        return -errno;
+    }
+    s->fd = fd;
+
+    PT_LOG("opened %s (%d)\n", filename, fd);
+
+    return 0;
+}
+
+/**
+ * Close device descriptor and cleanup.
+ * @param[in] bs
+ */
+static void pt_local_close(BlockDriverState * bs)
+{
+    BDRVPosixPassThroughState *s = bs->opaque;
+
+    PT_LOG("closing device %d\n", s->fd);
+
+    if (s->fd >= 0) {
+        qemu_close(s->fd);
+        s->fd = -1;
+    }
+}
+
+/**
+ * Probes device and matches if it looks to be a valid atapi-pt-local.
+ * @param[in] filename: format "atapi-pt-local:/dev/bsg/a:b:c:d"
+ * @returns 0 if invalid, 100 if valid (probe priority)
+ */
+static int pt_local_probe_device(const char *filename)
+{
+    int fd;
+    struct stat st;
+
+    if (strncmp(filename, "atapi-pt-local:", strlen("atapi-pt-local:")) != 0) {
+        PT_DEBUG("not a pt device %s\n", filename);
+        return -1;
+    }
+
+    filename += strlen("atapi-pt-local:");
+
+    PT_DEBUG("probing: %s\n", filename);
+
+    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);
+
+    if (fd < 0) {
+        PT_LOG("failed to open %s\n", filename);
+        return -1;
+    }
+
+    if (fstat(fd, &st) < 0) {
+        PT_LOG("failed to validate %s - fstat failed\n", filename);
+        qemu_close(fd);
+        return -1;
+    }
+
+    if (S_ISBLK(st.st_mode)) {
+        PT_LOG("failed to validate %s - not a block device\n", filename);
+        qemu_close(fd);
+        return -1;
+    }
+
+    qemu_close(fd);
+    return 100;
+}
+
+/**
+ * Parse the PT local file name.
+ * @param[in] filename: format "atapi-pt-local:/dev/bsg/a:b:c:d"
+ * @param[in] options: QDict options dictionary to fill in.
+ * @param[in] errp: Error object to use on failure.
+ */
+static void pt_local_parse_filename(const char *filename, QDict *options,
+                                    Error **errp)
+{
+    if (strncmp(filename, "atapi-pt-local:", strlen("atapi-pt-local:")) != 0) {
+        error_setg(errp, "File name string must start with 'atapi-pt-local:'");
+        return;
+    }
+
+    filename += strlen("atapi-pt-local:");
+    qdict_put(options, "filename", qstring_from_str(filename));
+}
+
+/**
+ * If protocol matches, opens local device and lock file.
+ * @param[in] bs
+ * @param[in] options: QDict options dictionary to fill in.
+ * @param[in] flags: device open flags
+ * @param[in] errp: Error object to use on failure.
+ * @returns 0 if opened successfully, -errno otherwise
+ */
+static int pt_local_open(BlockDriverState *bs, QDict *options, int flags,
+                         Error **errp)
+{
+    BDRVPosixPassThroughState *pts = bs->opaque;
+    QemuOpts *opts;
+    Error *local_err = NULL;
+    const char *filename;
+    int ret = 0;
+
+    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
+    qemu_opts_absorb_qdict(opts, options, &local_err);
+    if (local_err) {
+        error_propagate(errp, local_err);
+        ret = -EINVAL;
+        goto out;
+    }
+
+    filename = qemu_opt_get(opts, "filename");
+    if (!filename) {
+        error_setg(errp, "ATAPI_PT local block driver requires a 'filename' option");
+        ret = -EINVAL;
+        goto out;
+    }
+
+    if (pt_local_open_device(bs, filename, flags, O_NONBLOCK | O_RDWR) != 0) {
+        error_setg(errp, "ATAPI_PT failed to open device %s\n", filename);
+        ret = -ENOENT;
+        goto out;
+    }
+
+    PT_LOG("init for device=%s\n", filename);
+
+    atapi_pt_device_info_init(&pts->dev_info, filename, bs);
+
+    snprintf(pts->lock_file_name, sizeof(pts->lock_file_name),
+          "/var/lock/xen-atapi-pt-lock-%d_%d_%d_%d",
+          pts->dev_info.device_addr_a,
+          pts->dev_info.device_addr_b,
+          pts->dev_info.device_addr_c,
+          pts->dev_info.device_addr_d);
+
+    pts->lock_fd = open(pts->lock_file_name, O_RDWR | O_CREAT, 0666);
+
+    PT_LOG("opened: %s - readonly=%d\n", filename, bdrv_is_read_only(bs));
+
+out:
+    qemu_opts_del(opts);
+    return ret;
+}
+
+/**
+ * Grabs global exclusive lock.
+ * @param[in] pts
+ * @returns 1 if lock held, 0 otherwise
+ */
+static int pt_local_acquire_global_lock(BDRVPosixPassThroughState *pts)
+{
+    struct flock lock = {0};
+
+    if (pts->dev_info.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* already have lock */
+        return 1;
+    }
+
+    if (!is_lockable(&pts->dev_info)) {
+        /* currently not allowed to lock - do not attempt */
+        return 0;
+    }
+
+    lock.l_type = F_WRLCK;
+    lock.l_whence = SEEK_SET;
+    lock.l_start = 0;
+    lock.l_len = 0;
+
+    if (fcntl(pts->lock_fd, F_SETLK, &lock) == 0) {
+        PT_LOG("locked by me: %s\n", pts->dev_info.device_path);
+        pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_LOCKED_BY_ME;
+        notify_xs_lock_state(&pts->dev_info, 1);
+
+        /* signal that medium changed */
+        atapi_pt_notify_medium_maybe_changed(pts->dev_info.ide_state);
+        return 1;
+    }
+
+    PT_LOG("locked by other: %s\n", pts->dev_info.device_path);
+    pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER;
+    notify_xs_lock_state(&pts->dev_info, 0);
+    return 0;
+}
+
+/**
+ * Releases global exclusive lock.
+ * @param[in] pts
+ */
+static void pt_local_release_global_lock(BDRVPosixPassThroughState *pts)
+{
+    struct flock lock = {0};
+
+    if (pts->dev_info.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* we don't have the lock, nothing to do */
+        return;
+    }
+
+    lock.l_type = F_UNLCK;
+    lock.l_whence = SEEK_SET;
+    lock.l_start = 0;
+    lock.l_len = 0;
+
+    fcntl(pts->lock_fd, F_SETLK, &lock);
+
+    pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_UNLOCKED;
+
+    notify_xs_lock_state(&pts->dev_info, 0);
+
+    /* signal that medium has ejected */
+    atapi_pt_notify_medium_ejected(pts->dev_info.ide_state);
+
+    PT_LOG("released lock: %s\n", pts->dev_info.device_path);
+}
+
+/**
+ * Handles "ioctls" from atapi pt driver for atapi-pt-local devices.
+ * @param[in] bs
+ * @param[in] req: ioctl command from atapi_pt_cmd_t enum
+ * @param[inout] buf: pointer to in/out data
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_local_ioctl(BlockDriverState * bs, unsigned long int req,
+                          void *buf)
+{
+    BDRVPosixPassThroughState *pts = bs->opaque;
+    AtapiPtDeviceInfo *info = &pts->dev_info;
+    int ret = 0;
+
+    switch(req)
+    {
+        case ATAPI_PT_OPEN:
+            PT_DEBUG("ATAPI_PT_OPEN: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            info->ide_state = buf;
+            break;
+        case ATAPI_PT_SET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_SET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            set_global_media_state(info, *(uint32_t *)buf);
+            break;
+        case ATAPI_PT_GET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_GET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            *(uint32_t *)buf = info->media_state;
+            break;
+        case ATAPI_PT_ACQUIRE_LOCK:
+            PT_DEBUG("ATAPI_PT_ACQUIRE_LOCK: %s\n", info->device_path);
+            pt_local_acquire_global_lock(pts);
+            if (buf) {
+                *(uint32_t *)buf = info->lock_state;
+            }
+            break;
+        case ATAPI_PT_RELEASE_LOCK:
+            PT_DEBUG("ATAPI_PT_RELEASE_LOCK: %s\n", info->device_path);
+            pt_local_release_global_lock(pts);
+            break;
+        case ATAPI_PT_SG_IO:
+            PT_DEBUG("ATAPI_PT_SG_IO: %s\n", info->device_path);
+            ret = ioctl(pts->fd, SG_IO, buf);
+            if (ret < 0) {
+                PT_DEBUG("SG_IO ioctl() failed (%s).\n", strerror(errno));
+            } else {
+                ret = 0;
+            }
+            break;
+        case ATAPI_PT_SG_GET_RESERVED_SIZE:
+            PT_DEBUG("ATAPI_PT_SG_GET_RESERVED_SIZE: %s\n", info->device_path);
+            ret = ioctl(pts->fd, SG_GET_RESERVED_SIZE, buf);
+            if (ret < 0) {
+                PT_DEBUG("SG_GET_RESERVED_SIZE ioctl() failed: %s\n", strerror(errno));
+            } else {
+                ret = 0;
+            }
+            break;
+        default:
+            return -ENOTSUP;
+    }
+
+    return ret;
+}
+
+static BlockDriver bdrv_host_pt_local = {
+    .format_name         = "atapi-pt-fmt",
+    .protocol_name       = "atapi-pt-local",
+    .instance_size       = sizeof(BDRVPosixPassThroughState),
+    .bdrv_needs_filename = true,
+    .bdrv_probe_device   = pt_local_probe_device,
+    .bdrv_parse_filename = pt_local_parse_filename,
+    .bdrv_file_open      = pt_local_open,
+    .bdrv_direct_ioctl   = pt_local_ioctl,
+    .bdrv_close          = pt_local_close,
+};
+
+#ifdef CONFIG_ATAPI_PT_ARGO
+
+#define ARGO_TYPE 'W'
+#define ARGOIOCSETRINGSIZE       _IOW (ARGO_TYPE,  1, uint32_t)
+
+#define XEN_ARGO_MSG_SLOT_SIZE 0x10
+#define XEN_ARGO_ROUNDUP(a) roundup((a), XEN_ARGO_MSG_SLOT_SIZE)
+
+#define ATAPI_CDROM_PORT 5000
+#define ARGO_ATAPI_PT_RING_SIZE \
+  (XEN_ARGO_ROUNDUP((((4096)*64) - sizeof(xen_argo_ring_t)-XEN_ARGO_ROUNDUP(1))))
+
+#define MAX_ARGO_MSG_SIZE (ARGO_ATAPI_PT_RING_SIZE)
+
+typedef struct BDRVStubdomPassThroughState {
+    int argo_fd;
+    xen_argo_addr_t remote_addr;
+    xen_argo_addr_t local_addr;
+    uint8_t device_id;
+    AtapiPtDeviceInfo dev_info;
+} BDRVStubdomPassThroughState;
+
+/**
+ * Sends argo message to atapi-pt-helper.
+ * @param[in] hs
+ * @param[in] buf: message to send
+ * @param[in] size: size of buf
+ * @returns true if message sent successfully, false otherwise.
+ */
+static bool pt_argo_send_message(BDRVStubdomPassThroughState *pts, void *buf,
+                                size_t size)
+{
+    int ret;
+
+    ret = argo_sendto(pts->argo_fd, buf, size, 0, &pts->remote_addr);
+
+    if (ret != size) {
+        PT_LOG("error: argo_sendto() failed (%s) - %d %d.\n",
+                strerror(errno), ret, (int)size);
+        return false;
+    }
+
+    PT_DEBUG("pt_argo_send_message: cmd = %d - bytes = %d\n", *(char *)buf, ret);
+
+    return true;
+}
+
+/**
+ * Receive argo message to atapi-pt-helper.
+ * @param[in] hs
+ * @param[out] buf: message to send
+ * @param[in] size: expected size of message
+ * @returns true if message received successfully, false otherwise.
+ */
+static bool pt_argo_recv_message(BDRVStubdomPassThroughState *pts, void *buf,
+                                size_t size)
+{
+    int ret;
+
+    ret = argo_recvfrom(pts->argo_fd, buf, size, 0, &pts->remote_addr);
+
+    if (ret != size) {
+        PT_LOG("error: argo_sendto() failed (%s) - %d %d.\n",
+                strerror(errno), ret, (int)size);
+        return false;
+    }
+
+    PT_DEBUG("pt_argo_recv_message: cmd = %d - bytes = %d\n", *(char *)buf, ret);
+
+    return true;
+}
+
+/**
+ * Close argo device descriptor.
+ * @param[in] bs
+ */
+static void pt_argo_close(BlockDriverState* bs)
+{
+    BDRVStubdomPassThroughState* pts = bs->opaque;
+
+    if (pts->argo_fd == -1) {
+        PT_LOG("argo connection not initialized.");
+    }
+
+    argo_close(pts->argo_fd);
+    pts->argo_fd = -1;
+}
+
+/**
+ * Open argo descriptor for atapi-pt-argo device.
+ * @param[in] pts
+ * @param[in] filename: dom0 device path e.g. /dev/bsg/a:b:c:d
+ * Returns: 0 on success, -1 on failure
+ */
+static int pt_argo_open_common(BDRVStubdomPassThroughState *pts,
+                              const char *filename)
+{
+    pt_argocmd_open_request_t request;
+    pt_argocmd_open_response_t response;
+    uint32_t argo_ring_size = ARGO_ATAPI_PT_RING_SIZE;
+
+    PT_DEBUG("opening argo socket...\n");
+    pts->argo_fd = argo_socket(SOCK_DGRAM);
+    if (pts->argo_fd < 0) {
+        PT_DEBUG("argo_socket() failed (%s).\n", strerror(errno));
+        return -1;
+    }
+
+    pts->local_addr.aport = XEN_ARGO_PORT_NONE;
+    pts->local_addr.domain_id = XEN_ARGO_DOMID_ANY;
+
+    pts->remote_addr.aport = ATAPI_CDROM_PORT;
+    pts->remote_addr.domain_id = 0;
+
+    PT_DEBUG("setting argo ring size...\n");
+    ioctl(pts->argo_fd, ARGOIOCSETRINGSIZE, &argo_ring_size);
+
+    PT_DEBUG("bind argo socket with remote...\n");
+    if (argo_bind(pts->argo_fd, &pts->local_addr, 0)) {
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        PT_DEBUG("error: argo_bind() failed (%s).\n", strerror(errno));
+        return -1;
+    }
+
+    PT_DEBUG("sending ATAPI_PTARGO_OPEN...\n");
+
+    request.cmd = ATAPI_PTARGO_OPEN;
+    strncpy(&request.device_path[0], filename, sizeof(request.device_path) - 1);
+    request.device_path[sizeof(request.device_path) - 1] = 0;
+
+    if (!pt_argo_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_argo_send_message() failed\n");
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        return -1;
+    }
+
+    if (!pt_argo_recv_message(pts, &response, sizeof(response))) {
+        PT_LOG("error: pt_argo_recv_message failed\n");
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        return -1;
+    }
+
+    if (response.cmd != ATAPI_PTARGO_OPEN) {
+        PT_LOG("error: code mismatch - %d\n", response.cmd);
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        return -1;
+    }
+
+    pts->device_id = response.device_id;
+    return 0;
+}
+
+/**
+ * Parse the PT Argo file name.
+ * @param[in] filename: format "atapi-pt-argo:/dev/bsg/a:b:c:d"
+ * @param[in] options: QDict options dictionary to fill in.
+ * @param[in] errp: Error object to use on failure.
+ */
+static void pt_argo_parse_filename(const char *filename, QDict *options,
+                                  Error **errp)
+{
+    if (strncmp(filename, "atapi-pt-argo:", strlen("atapi-pt-argo:")) != 0) {
+        error_setg(errp, "File name string must start with 'atapi-pt-argo:'");
+        return;
+    }
+
+    filename += strlen("atapi-pt-argo:");
+    qdict_put(options, "filename", qstring_from_str(filename));
+}
+
+/**
+ * If protocol matches, opens argo passthrough device to atapi-dm-helper.
+ * @param[in] bs
+ * @param[in] options: QDict options dictionary to fill in.
+ * @param[in] flags: device open flags
+ * @param[in] errp: Error object to use on failure.
+ * @returns 0 if opened successfully, -errno otherwise
+ */
+static int pt_argo_open(BlockDriverState *bs, QDict *options, int flags,
+                       Error **errp)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+    QemuOpts *opts;
+    Error *local_err = NULL;
+    const char *filename;
+    int ret = 0;
+
+    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
+    qemu_opts_absorb_qdict(opts, options, &local_err);
+    if (local_err) {
+        error_propagate(errp, local_err);
+        ret = -EINVAL;
+        goto out;
+    }
+
+    filename = qemu_opt_get(opts, "filename");
+    if (!filename) {
+        error_setg(errp, "ATAPI_PT local block driver requires a 'filename' option");
+        ret = -EINVAL;
+        goto out;
+    }
+
+    PT_LOG("opening: %s - readonly=%d\n", filename, bdrv_is_read_only(bs));
+
+    atapi_pt_device_info_init(&pts->dev_info, filename, bs);
+
+    ret =  pt_argo_open_common(pts, filename);
+
+out:
+    qemu_opts_del(opts);
+    return ret;
+}
+
+/**
+ * Probes device and matches if it looks to be a valid atapi-pt-argo.
+ * @param[in] filename: format "atapi-pt-local:/dev/bsg/a:b:c:d"
+ * @returns 0 if invalid, 100 if valid (probe priority)
+ */
+static int pt_argo_probe_device(const char *filename)
+{
+    BDRVStubdomPassThroughState pts;
+
+    memset(&pts, 0, sizeof(BDRVStubdomPassThroughState));
+
+    /* check protocol */
+    if (strncmp(filename, "atapi-pt-argo:", strlen("atapi-pt-argo:")) != 0) {
+        PT_DEBUG("not a pt device %s\n", filename);
+        return -1;
+    }
+
+    filename += strlen("atapi-pt-argo:");
+
+    /* try to open argo device given filename */
+    if (pt_argo_open_common(&pts, filename) == -1) {
+        PT_DEBUG("cannot open %s\n", filename);
+        return -1;
+    }
+
+    argo_close(pts.argo_fd);
+    PT_DEBUG("argo probe device ok: %s", filename);
+    return 100;
+}
+
+/**
+ * Grabs global exclusive lock.
+ * @param[in] pts
+ * @returns 1 if lock held, 0 otherwise
+ */
+static int pt_argo_acquire_global_lock(BDRVStubdomPassThroughState *pts)
+{
+    pt_argocmd_acquire_lock_request_t request;
+    pt_argocmd_acquire_lock_response_t response;
+
+    if (pts->dev_info.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* already have lock */
+        return 1;
+    }
+
+    if (!is_lockable(&pts->dev_info)) {
+        /* currently not allowed to lock - do not attempt */
+        return 0;
+    }
+
+    PT_LOG("sending ATAPI_PTARGO_ACQUIRE_LOCK...\n");
+
+    request.cmd = ATAPI_PTARGO_ACQUIRE_LOCK;
+    request.device_id = pts->device_id;
+
+    if (!pt_argo_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_argo_send_message() failed\n");
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        return 0;
+    }
+
+    if (!pt_argo_recv_message(pts, &response, sizeof(response))) {
+        PT_LOG("error: pt_argo_recv_message failed\n");
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        return 0;
+    }
+
+    /* validate received packet header */
+    if (response.cmd != ATAPI_PTARGO_ACQUIRE_LOCK) {
+        PT_LOG("error: invalid packet data\n");
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        return 0;
+    }
+
+    pts->dev_info.lock_state = response.lock_state;
+
+    if (pts->dev_info.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        notify_xs_lock_state(&pts->dev_info, 1);
+
+        /* signal that medium is changing */
+        atapi_pt_notify_medium_maybe_changed(pts->dev_info.ide_state);
+        return 1;
+    }
+
+    PT_LOG("warning: failed to grab lock for %s - lock_state = %d\n",
+           pts->dev_info.device_path, pts->dev_info.lock_state);
+
+    notify_xs_lock_state(&pts->dev_info, 0);
+    return 0;
+}
+
+/**
+ * Releases global exclusive lock.
+ * @param[in] pts
+ */
+static void pt_argo_release_global_lock(BDRVStubdomPassThroughState *pts)
+{
+    pt_argocmd_release_lock_request_t request;
+
+    if (pts->dev_info.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        /* we don't have the lock, nothing to do */
+        return;
+    }
+
+    PT_DEBUG("sending ATAPI_PTARGO_RELEASE_LOCK...\n");
+
+    request.cmd = ATAPI_PTARGO_RELEASE_LOCK;
+    request.device_id = pts->device_id;
+
+    if (!pt_argo_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_argo_send_message() failed\n");
+        argo_close(pts->argo_fd);
+        pts->argo_fd = -1;
+        return;
+    }
+
+    pts->dev_info.lock_state = ATAPI_PT_LOCK_STATE_UNLOCKED;
+    notify_xs_lock_state(&pts->dev_info, 0);
+
+    /* signal that medium is ejected */
+    atapi_pt_notify_medium_ejected(pts->dev_info.ide_state);
+
+    PT_LOG("released lock: %s\n", pts->dev_info.device_path);
+}
+
+
+
+/**
+ * Handles pass-through ioctls from atapi pt driver for atapi-pt-argo devices
+ * @param[in] bs
+ * @param[out] size: reserved size response - must not be NULL.
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_argo_sg_get_reserved_size(BlockDriverState *bs, uint32_t *size)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+
+    pt_argocmd_sg_get_reserved_size_request_t request;
+    pt_argocmd_sg_get_reserved_size_response_t response;
+
+    PT_DEBUG("sending ATAPI_PTARGO_SG_GET_RESERVED_SIZE...\n");
+
+    assert(size != NULL);
+
+    *size = 0;
+
+    request.cmd = ATAPI_PTARGO_SG_GET_RESERVED_SIZE;
+    request.device_id = pts->device_id;
+
+    if (!pt_argo_send_message(pts, &request, sizeof(request))) {
+        PT_LOG("error: pt_argo_send_message() failed\n");
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    if (!pt_argo_recv_message(pts, &response, sizeof(response))) {
+        PT_LOG("error: pt_argo_recv_message failed\n");
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* validate received packet header */
+    if (response.cmd != ATAPI_PTARGO_SG_GET_RESERVED_SIZE) {
+        PT_LOG("error: invalid packet data\n");
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    *size = response.size;
+    return 0;
+}
+
+/**
+ * Handles pass-through ioctls from atapi pt driver for atapi-pt-argo devices
+ * @param[in] bs
+ * @param[in] req: sg ioctl command
+ * @param[inout] buf: pointer to in/out data
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_argo_sg_ioctl(BlockDriverState *bs, unsigned long int req,
+                           void *buf)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+
+    struct sg_io_v4 *cmd = (struct sg_io_v4 *)buf;
+    struct request_sense *sense;
+
+    /* sgio_v4 tracks pointers with u64 */
+    uint64_t req_xferp = 0;
+    uint64_t dout_xferp = 0;
+    uint64_t din_xferp = 0;
+    uint32_t din_xfer_len = 0;
+
+    uint8_t buf_out[sizeof(pt_argocmd_sg_io_request_t) + cmd->dout_xfer_len];
+    pt_argocmd_sg_io_request_t *request = (pt_argocmd_sg_io_request_t *)buf_out;
+
+    uint8_t buf_in[sizeof(pt_argocmd_sg_io_response_t) + cmd->din_xfer_len];
+    pt_argocmd_sg_io_response_t *response = (pt_argocmd_sg_io_response_t *)buf_in;
+
+    int len;
+
+    PT_DEBUG("sending ATAPI_PTARGO_SG_IO...\n");
+
+    if (sizeof(buf_out) > MAX_ARGO_MSG_SIZE) {
+        PT_LOG("error: dout_data too large - cannot complete command\n");
+        return -1;
+    }
+    memset(buf_out, 0, sizeof(buf_out));
+
+    if (sizeof(buf_in) > MAX_ARGO_MSG_SIZE) {
+        PT_LOG("error: din_data too large - cannot complete command\n");
+        return -1;
+    }
+    memset(buf_in, 0, sizeof(buf_in));
+
+    if (pts->argo_fd == -1) {
+        PT_LOG("error: argo connection not initialized.");
+        return -1;
+    }
+
+    request->cmd = ATAPI_PTARGO_SG_IO;
+    request->device_id = pts->device_id;
+
+    /* make sure dout_xfer_len will fit in request */
+    if (sizeof(buf_out) < sizeof(request) + cmd->dout_xfer_len) {
+        PT_LOG("error: bad dout_xfer_len %d", cmd->dout_xfer_len);
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* make sure din_xfer_len will fit in response */
+    if (sizeof(buf_in) < sizeof(response) + cmd->din_xfer_len) {
+        PT_LOG("error: bad din_xfer_len %d", cmd->din_xfer_len);
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* populate sgio */
+    memcpy(&request->sgio, cmd, sizeof(struct sg_io_v4));
+
+    /* make sure request data is sized properly */
+    if (cmd->request_len != sizeof(request->request_data)) {
+        PT_LOG("error: bad request_len %d", cmd->request_len);
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* validate outgoing sense ("response") data len */
+    if (cmd->max_response_len != sizeof(response->sense_data)) {
+        PT_LOG("error: invalid max_response_len! %d\n", cmd->max_response_len);
+        return -1;
+    }
+
+    /* copy atapi packet request */
+    memcpy(&request->request_data[0], (void *)(uintptr_t)cmd->request, cmd->request_len);
+
+    if (cmd->dout_xfer_len > 0) {
+        /* this is dout, update request with dout_xfer data */
+        memcpy(&request->dout_data[0], (void *)(uintptr_t)cmd->dout_xferp, cmd->dout_xfer_len);
+        request->dout_data_len = cmd->dout_xfer_len;
+    } else {
+        /* this is din, nothing else to do with request, just copy din state */
+        din_xfer_len = cmd->din_xfer_len;
+        din_xferp = cmd->din_xferp;
+    }
+
+    /* save off pointers */
+    dout_xferp = cmd->dout_xferp;
+    req_xferp = cmd->request;
+    sense = (struct request_sense *)(uintptr_t) cmd->response;
+
+    /* calculate packet len and fire away */
+    len = sizeof(*request) + request->dout_data_len;
+    if (!pt_argo_send_message(pts, request, len)) {
+        PT_LOG("error: pt_argo_send_message() failed\n");
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* response coming back should be sizeof reply plus expected din data len */
+    len = sizeof(*response) + din_xfer_len;
+    if (!pt_argo_recv_message(pts, response, len)) {
+        PT_LOG("error: pt_argo_recv_message failed\n");
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* validate correct command code */
+    if (response->cmd != ATAPI_PTARGO_SG_IO) {
+        PT_LOG("error: command response bad = %d\n", response->cmd);
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* validate that din_xfer_data_len matches */
+    if (response->din_data_len != din_xfer_len) {
+        PT_LOG("error: mismatch din_xfer_len! 0x%x 0%x\n",
+                response->din_data_len, din_xfer_len);
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* copy sg_io_v4 struct back out as there are some output fields */
+    memcpy(cmd, &response->sgio, sizeof(struct sg_io_v4));
+
+    /* restore sgio pointers */
+    cmd->dout_xferp = dout_xferp;
+    cmd->din_xferp = din_xferp;
+    cmd->response = (uint64_t)(uintptr_t)sense;
+    cmd->request = req_xferp;
+
+    /* validate that din_xfer_data_len matches inside sgio packet */
+    if (cmd->din_xfer_len != din_xfer_len) {
+        PT_LOG("error: mismatch cmd->din_xfer_len! 0x%x 0%x\n",
+                cmd->din_xfer_len, din_xfer_len);
+        pt_argo_close(bs);
+        return -1;
+    }
+
+    /* validate incoming sense ("response") data len */
+    if (cmd->max_response_len != sizeof(response->sense_data)) {
+        PT_LOG("error: invalid max_response_len! %d\n", cmd->max_response_len);
+        return -1;
+    }
+
+    /* copy sense data back out */
+    memcpy(sense, &response->sense_data, sizeof(*sense));
+
+    if (din_xfer_len > 0) {
+        /* this is a din packet - copy din data back out */
+        memcpy((void *)(uintptr_t)din_xferp, &response->din_data[0],
+               din_xfer_len);
+    }
+
+    return 0;
+}
+
+/**
+ * Handles "ioctls" from atapi pt driver for atapi-pt-argo devices.
+ * @param[in] bs
+ * @param[in] req: ioctl command from atapi_pt_cmd_t enum
+ * @param[inout] buf: pointer to in/out data
+ * Returns: 0 on success, non-zero on failure.
+ */
+static int pt_argo_ioctl(BlockDriverState *bs, unsigned long int req, void *buf)
+{
+    BDRVStubdomPassThroughState *pts = bs->opaque;
+    AtapiPtDeviceInfo *info = &pts->dev_info;
+
+    switch(req)
+    {
+        case ATAPI_PT_OPEN:
+            PT_DEBUG("ATAPI_PT_OPEN: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            info->ide_state = buf;
+            break;
+        case ATAPI_PT_SET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_SET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            set_global_media_state(info, *(uint32_t *)buf);
+            break;
+        case ATAPI_PT_GET_GLOB_MEDIA_STATE:
+            PT_DEBUG("ATAPI_PT_GET_GLOB_MEDIA_STATE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            *(uint32_t *)buf = info->media_state;
+            break;
+        case ATAPI_PT_ACQUIRE_LOCK:
+            PT_DEBUG("ATAPI_PT_ACQUIRE_LOCK: %s\n", info->device_path);
+            pt_argo_acquire_global_lock(pts);
+            if (buf) {
+                *(uint32_t *)buf = info->lock_state;
+            }
+            break;
+        case ATAPI_PT_RELEASE_LOCK:
+            PT_DEBUG("ATAPI_PT_RELEASE_LOCK: %s\n", info->device_path);
+            pt_argo_release_global_lock(pts);
+            break;
+        case ATAPI_PT_SG_IO:
+            PT_DEBUG("ATAPI_PT_SG_IO: %s\n", info->device_path);
+            if (pt_argo_sg_ioctl(bs, SG_IO, buf) < 0) {
+                PT_DEBUG("SG_IO ioctl() failed (%s).\n", strerror(errno));
+                return -1;
+            }
+            break;
+        case ATAPI_PT_SG_GET_RESERVED_SIZE:
+            PT_DEBUG("ATAPI_PT_SG_GET_RESERVED_SIZE: %s\n", info->device_path);
+            if (!buf) {
+                return -ENOTSUP;
+            }
+            if (pt_argo_sg_get_reserved_size(bs, buf) != 0) {
+                PT_DEBUG("SG_GET_RESERVED_SIZE ioctl() failed: %s\n",
+                         strerror(errno));
+                return -1;
+            }
+            break;
+        default:
+            return -ENOTSUP;
+    }
+
+    return 0;
+}
+
+static BlockDriver bdrv_host_pt_argo = {
+    .format_name         = "atapi-pt-fmt",
+    .protocol_name       = "atapi-pt-argo",
+    .instance_size       = sizeof(BDRVStubdomPassThroughState),
+    .bdrv_needs_filename = true,
+    .bdrv_probe_device   = pt_argo_probe_device,
+    .bdrv_parse_filename = pt_argo_parse_filename,
+    .bdrv_file_open      = pt_argo_open,
+    .bdrv_direct_ioctl   = pt_argo_ioctl,
+    .bdrv_close          = pt_argo_close,
+};
+
+#endif //CONFIG_ATAPI_PT_ARGO
+
+static void bdrv_pt_init(void)
+{
+    /*
+     * Register all the drivers.  Note that order is important, the driver
+     * registered last will get probed first.
+     */
+#ifdef CONFIG_STUBDOM
+# ifdef CONFIG_ATAPI_PT_ARGO
+    (void)bdrv_host_pt_local;
+    bdrv_register(&bdrv_host_pt_argo);
+# endif
+#else
+    (void)bdrv_host_pt_argo;
+    bdrv_register(&bdrv_host_pt_local);
+#endif
+}
+
+block_init(bdrv_pt_init);
--- a/blockdev.c
+++ b/blockdev.c
@@ -82,6 +82,9 @@ static const char *const if_name[IF_COUN
     [IF_SD] = "sd",
     [IF_VIRTIO] = "virtio",
     [IF_XEN] = "xen",
+#ifdef CONFIG_ATAPI_PT
+    [IF_ATAPI_PT] = "atapi-pt",
+#endif
 };
 
 static int if_max_devs[IF_COUNT] = {
@@ -770,6 +773,9 @@ DriveInfo *drive_new(QemuOpts *all_opts,
     QemuOpts *legacy_opts;
     DriveMediaType media = MEDIA_DISK;
     BlockInterfaceType type;
+#ifdef CONFIG_ATAPI_PT
+    bool atapi_pt = false;
+#endif
     int max_devs, bus_id, unit_id, index;
     const char *werror, *rerror;
     bool read_only = false;
@@ -860,7 +866,9 @@ DriveInfo *drive_new(QemuOpts *all_opts,
             media = MEDIA_DISK;
         } else if (!strcmp(value, "cdrom")) {
             media = MEDIA_CDROM;
+#ifndef CONFIG_ATAPI_PT
             read_only = true;
+#endif
         } else {
             error_setg(errp, "'%s' invalid media", value);
             goto fail;
@@ -894,6 +902,13 @@ DriveInfo *drive_new(QemuOpts *all_opts,
         type = block_default_type;
     }
 
+#ifdef CONFIG_ATAPI_PT
+    if (IF_ATAPI_PT == type) {
+        type = IF_IDE;
+        atapi_pt = true;
+    }
+#endif
+
     /* Device address specified by bus/unit or index.
      * If none was specified, try to find the first free one. */
     bus_id  = qemu_opt_get_number(legacy_opts, "bus", 0);
@@ -1011,11 +1026,19 @@ DriveInfo *drive_new(QemuOpts *all_opts,
     blk_set_legacy_dinfo(blk, dinfo);
 
     switch(type) {
+#ifdef CONFIG_ATAPI_PT
+    case IF_ATAPI_PT:
+#endif
     case IF_IDE:
     case IF_SCSI:
     case IF_XEN:
     case IF_NONE:
         dinfo->media_cd = media == MEDIA_CDROM;
+#ifdef CONFIG_ATAPI_PT
+        if (atapi_pt) {
+            dinfo->atapi_pt = true;
+        }
+#endif
         break;
     default:
         break;
--- a/configure
+++ b/configure
@@ -452,6 +452,8 @@ crypto_afalg="no"
 seccomp=""
 glusterfs=""
 stubdom="no"
+atapipt="no"
+atapiptargo="no"
 glusterfs_xlator_opt="no"
 glusterfs_discard="no"
 glusterfs_fallocate="no"
@@ -1357,6 +1359,14 @@ for opt do
   ;;
   --enable-glusterfs) glusterfs="yes"
   ;;
+  --enable-atapi-pt) atapipt="yes"
+  ;;
+  --disable-atapi-pt) atapipt="no"
+  ;;
+  --enable-atapi-pt-argo) atapiptargo="yes" && atapipt="yes"
+  ;;
+  --disable-atapi-pt-argo) atapiptargo="no"
+  ;;
   --disable-virtio-blk-data-plane|--enable-virtio-blk-data-plane)
       echo "$0: $opt is obsolete, virtio-blk data-plane is always on" >&2
   ;;
@@ -6128,6 +6138,8 @@ echo "GlusterFS support $glusterfs"
 echo "gcov              $gcov_tool"
 echo "gcov enabled      $gcov"
 echo "OpenXT stubdomain support $stubdom"
+echo "ATAPI PT support  $atapipt"
+echo "ATAPI PT Argo support  $atapiptargo"
 echo "TPM support       $tpm"
 echo "libssh2 support   $libssh2"
 echo "TPM passthrough   $tpm_passthrough"
@@ -6802,6 +6814,14 @@ if test "$stubdom" = "yes" ; then
   echo "CONFIG_STUBDOM=y" >> $config_host_mak
 fi
 
+if test "$atapipt" = "yes" ; then
+  echo "CONFIG_ATAPI_PT=y" >> $config_host_mak
+fi
+
+if test "$atapiptargo" = "yes" ; then
+  echo "CONFIG_ATAPI_PT_ARGO=y" >> $config_host_mak
+fi
+
 if test "$tpm" = "yes"; then
   echo 'CONFIG_TPM=$(CONFIG_SOFTMMU)' >> $config_host_mak
   # TPM passthrough support?
--- a/hw/ide/Makefile.objs
+++ b/hw/ide/Makefile.objs
@@ -12,3 +12,4 @@ common-obj-$(CONFIG_AHCI) += ahci.o
 common-obj-$(CONFIG_AHCI) += ich.o
 common-obj-$(CONFIG_ALLWINNER_A10) += ahci-allwinner.o
 common-obj-$(CONFIG_IDE_SII3112) += sii3112.o
+common-obj-$(CONFIG_ATAPI_PT) += atapi_pt.o
--- a/hw/ide/atapi.c
+++ b/hw/ide/atapi.c
@@ -320,7 +320,10 @@ void ide_atapi_cmd_reply_end(IDEState *s
 }
 
 /* send a reply of 'size' bytes in s->io_buffer to an ATAPI command */
-static void ide_atapi_cmd_reply(IDEState *s, int size, int max_size)
+#ifndef CONFIG_ATAPI_PT
+static
+#endif
+void ide_atapi_cmd_reply(IDEState *s, int size, int max_size)
 {
     if (size > max_size)
         size = max_size;
--- /dev/null
+++ b/hw/ide/atapi_pt.c
@@ -0,0 +1,2044 @@
+/*
+ * ATAPI guest commands translation.
+ *
+ * Copyright (C) 2015 Assured Information Security, Chris Patterson <pattersonc@ainfosec.com>
+ * Copyright (C) 2014 Citrix Systems Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <sys/mman.h>
+#include <scsi/sg.h>
+
+#include "qemu/osdep.h"
+#include "scsi/constants.h"
+#include "hw/ide/internal.h"
+#include "hw/atapi_pt.h"
+#include "block/block.h"
+#include "block/block_int.h"
+#include "sysemu/block-backend.h"
+#include "block/atapi_pt_ioctl.h"
+#include "block/atapi_pt_argo.h"
+
+extern int pt_log_level;
+
+/**
+ * PT_LOG: information to always log (errors & important low-volume events)
+ * @param fmt,... printf style arguments
+ */
+#define PT_LOG(fmt, ...)                                           \
+    do {                                                           \
+            fprintf(stdout, "[%s:%s:%d] " fmt,                     \
+                    __FILE__, __FUNCTION__, __LINE__, ##__VA_ARGS__);      \
+    } while (0)
+
+/**
+ * PT_VERBOSE: verbose level
+ * @param fmt,... printf style arguments
+ */
+#define PT_VERBOSE(fmt, ...)                                           \
+    do {                                                               \
+        if (pt_log_level >= 1)                                         \
+            PT_LOG(fmt, ## __VA_ARGS__);                                  \
+    } while (0)
+
+/**
+ * PT_DEBUG: debug level
+ * @param fmt,... printf style arguments
+ */
+#define PT_DEBUG(fmt, ...)                                             \
+    do {                                                               \
+        if (pt_log_level >= 2)                                         \
+            PT_LOG(fmt, ## __VA_ARGS__);                                  \
+    } while (0)
+
+/**
+ * PT_DEBUG_SENSE: debug sense data
+ * @param key
+ * @param asc
+ * @param ascq
+ */
+#define PT_DEBUG_SENSE(key, asc, ascq) \
+    do {\
+        PT_DEBUG("sense key=0x%02x asc=0x%02x ascq=0x%02x str=%s\n", \
+                      key, asc, ascq, atapi_sense_to_str(key, asc, ascq)); \
+    } while (0)
+
+/* From Table 459 of the SFF8090 Ver. 4 (Mt. Fuji) draft standard.
+ * Code is (key << 16) | (asc << 8) | ascq
+ * Mask is a bit mask, since some codes span ranges of values. */
+
+static const struct {
+    uint32_t code;
+    uint32_t mask;
+    char const *const text;
+} sense_data_texts[] = {
+    { 0x080000, 0xFF0000, "BLANK CHECK"},
+    { 0x000000, 0xFFFFFF, "NO ADDITIONAL SENSE INFORMATION"},
+    { 0x000001, 0xFFFFFF, "FILEMARK DETECTED"},
+    { 0x000002, 0xFFFFFF, "END-OF-PARTITION/MEDIUM DETECTED"},
+    { 0x000003, 0xFFFFFF, "SETMARK DETECTED"},
+    { 0x000004, 0xFFFFFF, "BEGINNING-OF-PARTITION/MEDIUM DETECTED"},
+    { 0x000005, 0xFFFFFF, "END-OF-DATA DETECTED"},
+    { 0x0B0006, 0xFFFFFF, "I/O PROCESS TERMINATED, PLAY OPERATION ABORTED"},
+    { 0x000011, 0xFFFFFF, "AUDIO PLAY OPERATION IN PROGRESS"},
+    { 0x000012, 0xFFFFFF, "AUDIO PLAY OPERATION PAUSED"},
+    { 0x000013, 0xFFFFFF, "AUDIO PLAY OPERATION SUCCESSFULLY COMPLETED"},
+    { 0x000014, 0xFFFFFF, "AUDIO PLAY OPERATION STOPPED DUE TO ERROR"},
+    { 0x000015, 0xFFFFFF, "NO CURRENT AUDIO STATUS TO RETURN"},
+    { 0x000016, 0xFFFFFF, "OPERATION IN PROGRESS"},
+    { 0x040017, 0xFFFFFF, "CLEANING REQUESTED"},
+    { 0x040100, 0xFFFFFF, "NO INDEX/SECTOR SIGNAL"},
+    { 0x030200, 0xFFFFFF, "NO SEEK COMPLETE"},
+    { 0x030300, 0xFFFFFF, "PERIPHERAL DEVICE WRITE FAULT"},
+    { 0x030301, 0xFFFFFF, "NO WRITE CURRENT"},
+    { 0x030302, 0xFFFFFF, "EXCESSIVE WRITE ERRORS"},
+    { 0x020400, 0xFFFFFF, "LOGICAL UNIT NOT READY, CAUSE NOT REPORTABLE"},
+    { 0x020401, 0xFFFFFF, "LOGICAL UNIT IS IN PROCESS OF BECOMING READY"},
+    { 0x020402, 0xFFFFFF, "LOGICAL UNIT NOT READY, INITIALIZING CMD. REQUIRED"},
+    { 0x020403, 0xFFFFFF, "LOGICAL UNIT NOT READY, MANUAL INTERVENTION REQUIRED"},
+    { 0x020404, 0xFFFFFF, "LOGICAL UNIT NOT READY, FORMAT IN PROGRESS"},
+    { 0x020405, 0xFFFFFF, "LOGICAL UNIT NOT READY, REBUILD IN PROGRESS"},
+    { 0x020406, 0xFFFFFF, "LOGICAL UNIT NOT READY, RECALCULATION IN PROGRESS"},
+    { 0x020407, 0xFFFFFF, "LOGICAL UNIT NOT READY, OPERATION IN PROGRESS"},
+    { 0x020408, 0xFFFFFF, "LOGICAL UNIT NOT READY, LONG WRITE IN PROGRESS"},
+    { 0x020500, 0xFFFFFF, "LOGICAL UNIT DOES NOT RESPOND TO SELECTION"},
+    { 0x020600, 0xFFFFFF, "NO REFERENCE POSITION FOUND (medium may be upside down)"},
+    { 0x050700, 0xFFFFFF, "MULTIPLE PERIPHERAL DEVICES SELECTED"},
+    { 0x040800, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION FAILURE"},
+    { 0x040801, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION TIME-OUT"},
+    { 0x040802, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION PARITY ERROR"},
+    { 0x040803, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION CRC ERROR (ULTRA-DMA/32)"},
+    { 0x040900, 0xFFFFFF, "TRACK FOLLOWING ERROR"},
+    { 0x040901, 0xFFFFFF, "TRACKING SERVO FAILURE"},
+    { 0x040902, 0xFFFFFF, "FOCUS SERVO FAILURE"},
+    { 0x040903, 0xFFFFFF, "SPINDLE SERVO FAILURE"},
+    { 0x040904, 0xFFFFFF, "HEAD SELECT FAULT"},
+    { 0x060A00, 0xFFFFFF, "ERROR LOG OVERFLOW"},
+    { 0x010B00, 0xFFFFFF, "WARNING"},
+    { 0x010B01, 0xFFFFFF, "WARNING - SPECIFIED TEMPERATURE EXCEEDED"},
+    { 0x010B02, 0xFFFFFF, "WARNING - ENCLOSURE DEGRADED"},
+    { 0x030C00, 0xFFFFFF, "WRITE ERROR"},
+    { 0x030C01, 0xFFFFFF, "WRITE ERROR - RECOVERED WITH AUTO REALLOCATION"},
+    { 0x030C02, 0xFFFFFF, "WRITE ERROR - AUTO REALLOCATION FAILED"},
+    { 0x030C03, 0xFFFFFF, "WRITE ERROR - RECOMMEND REASSIGNMENT"},
+    { 0x030C04, 0xFFFFFF, "COMPRESSION CHECK MISCOMPARE ERROR"},
+    { 0x030C05, 0xFFFFFF, "DATA EXPANSION OCCURRED DURING COMPRESSION"},
+    { 0x030C06, 0xFFFFFF, "BLOCK NOT COMPRESSIBLE"},
+    { 0x030C07, 0xFFFFFF, "WRITE ERROR - RECOVERY NEEDED"},
+    { 0x030C08, 0xFFFFFF, "WRITE ERROR - RECOVERY FAILED"},
+    { 0x030C09, 0xFFFFFF, "WRITE ERROR - LOSS OF STREAMING"},
+    { 0x010C0A, 0xFFFFFF, "WRITE ERROR - PADDING BLOCKS ADDED"},
+    { 0x000D00, 0x00FFFF, "Reserved"},
+    { 0x000E00, 0x00FFFF, "Reserved"},
+    { 0x000F00, 0x00FFFF, "Reserved"},
+    { 0x031000, 0xFFFFFF, "ID CRC OR ECC ERROR"},
+    { 0x031100, 0xFFFFFF, "UNRECOVERED READ ERROR"},
+    { 0x031101, 0xFFFFFF, "READ RETRIES EXHAUSTED"},
+    { 0x031102, 0xFFFFFF, "ERROR TOO LONG TO CORRECT"},
+    { 0x031103, 0xFFFFFF, "MULTIPLE READ ERRORS"},
+    { 0x031104, 0xFFFFFF, "UNRECOVERED READ ERROR - AUTO REALLOCATE FAILED"},
+    { 0x031105, 0xFFFFFF, "L-EC UNCORRECTABLE ERROR"},
+    { 0x031106, 0xFFFFFF, "CIRC UNRECOVERED ERROR"},
+    { 0x031107, 0xFFFFFF, "RE-SYNCHRONIZATION ERROR"},
+    { 0x031108, 0xFFFFFF, "INCOMPLETE BLOCK READ"},
+    { 0x031109, 0xFFFFFF, "NO GAP FOUND"},
+    { 0x03110A, 0xFFFFFF, "MISCORRECTED ERROR"},
+    { 0x03110B, 0xFFFFFF, "UNRECOVERED READ ERROR - RECOMMEND REASSIGNMENT"},
+    { 0x03110C, 0xFFFFFF, "UNRECOVERED READ ERROR - RECOMMEND REWRITE THE DATA"},
+    { 0x03110D, 0xFFFFFF, "DE-COMPRESSION CRC ERROR"},
+    { 0x03110E, 0xFFFFFF, "CANNOT DECOMPRESS USING DECLARED ALGORITHM"},
+    { 0x03110F, 0xFFFFFF, "ERROR READING UPC/EAN NUMBER"},
+    { 0x031110, 0xFFFFFF, "ERROR READING ISRC NUMBER"},
+    { 0x0B1111, 0xFFFFFF, "READ ERROR - LOSS OF STREAMING"},
+    { 0x031200, 0xFFFFFF, "ADDRESS MARK NOT FOUND FOR ID FIELD"},
+    { 0x031300, 0xFFFFFF, "ADDRESS MARK NOT FOUND FOR DATA FIELD"},
+    { 0x031400, 0xFFFFFF, "RECORDED ENTITY NOT FOUND"},
+    { 0x031401, 0xFFFFFF, "RECORD NOT FOUND"},
+    { 0x031402, 0xFFFFFF, "FILEMARK OR SETMARK NOT FOUND"},
+    { 0x031403, 0xFFFFFF, "END-OF-DATA NOT FOUND"},
+    { 0x031404, 0xFFFFFF, "BLOCK SEQUENCE ERROR"},
+    { 0x031405, 0xFFFFFF, "RECORD NOT FOUND - RECOMMEND REASSIGNMENT"},
+    { 0x031406, 0xFFFFFF, "RECORD NOT FOUND - DATA AUTO-REALLOCATED"},
+    { 0x041500, 0xFFFFFF, "RANDOM POSITIONING ERROR"},
+    { 0x041501, 0xFFFFFF, "MECHANICAL POSITIONING ERROR"},
+    { 0x031502, 0xFFFFFF, "POSITIONING ERROR DETECTED BY READ OF MEDIUM"},
+    { 0x031600, 0xFFFFFF, "DATA SYNCHRONIZATION MARK ERROR"},
+    { 0x031601, 0xFFFFFF, "DATA SYNC ERROR - DATA REWRITTEN"},
+    { 0x031602, 0xFFFFFF, "DATA SYNC ERROR - RECOMMEND REWRITE"},
+    { 0x031603, 0xFFFFFF, "DATA SYNC ERROR - DATA AUTO-REALLOCATED"},
+    { 0x031604, 0xFFFFFF, "DATA SYNC ERROR - RECOMMEND REASSIGNMENT"},
+    { 0x011700, 0xFFFFFF, "RECOVERED DATA WITH NO ERROR CORRECTION APPLIED"},
+    { 0x011701, 0xFFFFFF, "RECOVERED DATA WITH RETRIES"},
+    { 0x011702, 0xFFFFFF, "RECOVERED DATA WITH POSITIVE HEAD OFFSET"},
+    { 0x011703, 0xFFFFFF, "RECOVERED DATA WITH NEGATIVE HEAD OFFSET"},
+    { 0x011704, 0xFFFFFF, "RECOVERED DATA WITH RETRIES AND/OR CIRC APPLIED"},
+    { 0x011705, 0xFFFFFF, "RECOVERED DATA USING PREVIOUS SECTOR ID"},
+    { 0x011706, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - DATA AUTO-REALLOCATED"},
+    { 0x011707, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - RECOMMEND REASSIGNMENT"},
+    { 0x011708, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - RECOMMEND REWRITE"},
+    { 0x011709, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - DATA REWRITTEN"},
+    { 0x011800, 0xFFFFFF, "RECOVERED DATA WITH ERROR CORRECTION APPLIED"},
+    { 0x011801, 0xFFFFFF, "RECOVERED DATA WITH ERROR CORR. & RETRIES APPLIED"},
+    { 0x011802, 0xFFFFFF, "RECOVERED DATA - DATA AUTO-REALLOCATED"},
+    { 0x011803, 0xFFFFFF, "RECOVERED DATA WITH CIRC"},
+    { 0x011804, 0xFFFFFF, "RECOVERED DATA WITH L-EC"},
+    { 0x011805, 0xFFFFFF, "RECOVERED DATA - RECOMMEND REASSIGNMENT"},
+    { 0x011806, 0xFFFFFF, "RECOVERED DATA - RECOMMEND REWRITE"},
+    { 0x011807, 0xFFFFFF, "RECOVERED DATA WITH ECC - DATA REWRITTEN"},
+    { 0x011808, 0xFFFFFF, "RECOVERED DATA WITH LINKING"},
+    { 0x031900, 0xFFFFFF, "DEFECT LIST ERROR"},
+    { 0x031901, 0xFFFFFF, "DEFECT LIST NOT AVAILABLE"},
+    { 0x031902, 0xFFFFFF, "DEFECT LIST ERROR IN PRIMARY LIST"},
+    { 0x031903, 0xFFFFFF, "DEFECT LIST ERROR IN GROWN LIST"},
+    { 0x051A00, 0xFFFFFF, "PARAMETER LIST LENGTH ERROR"},
+    { 0x041B00, 0xFFFFFF, "SYNCHRONOUS DATA TRANSFER ERROR"},
+    { 0x041C00, 0xFFFFFF, "DEFECT LIST NOT FOUND"},
+    { 0x041C01, 0xFFFFFF, "PRIMARY DEFECT LIST NOT FOUND"},
+    { 0x041C02, 0xFFFFFF, "GROWN DEFECT LIST NOT FOUND"},
+    { 0x0E1D00, 0xFFFFFF, "MISCOMPARE DURING VERIFY OPERATION"},
+    { 0x011E00, 0xFFFFFF, "RECOVERED ID WITH ECC CORRECTION"},
+    { 0x031F00, 0xFFFFFF, "PARTIAL DEFECT LIST TRANSFER"},
+    { 0x052000, 0xFFFFFF, "INVALID COMMAND OPERATION CODE"},
+    { 0x052100, 0xFFFFFF, "LOGICAL BLOCK ADDRESS OUT OF RANGE"},
+    { 0x052101, 0xFFFFFF, "INVALID ELEMENT ADDRESS"},
+    { 0x052102, 0xFFFFFF, "INVALID ADDRESS FOR WRITE"},
+    { 0x052200, 0xFFFFFF, "ILLEGAL FUNCTION (USE 20 00, 24 00, OR 26 00)"},
+    { 0x002300, 0x00FFFF, "Reserved"},
+    { 0x052400, 0xFFFFFF, "INVALID FIELD IN CDB"},
+    { 0x052500, 0xFFFFFF, "LOGICAL UNIT NOT SUPPORTED"},
+    { 0x052600, 0xFFFFFF, "INVALID FIELD IN PARAMETER LIST"},
+    { 0x052601, 0xFFFFFF, "PARAMETER NOT SUPPORTED"},
+    { 0x052602, 0xFFFFFF, "PARAMETER VALUE INVALID"},
+    { 0x052603, 0xFFFFFF, "THRESHOLD PARAMETERS NOT SUPPORTED"},
+    { 0x052604, 0xFFFFFF, "INVALID RELEASE OF ACTIVE PERSISTENT RESERVATION"},
+    { 0x072700, 0xFFFFFF, "WRITE PROTECTED"},
+    { 0x072701, 0xFFFFFF, "HARDWARE WRITE PROTECTED"},
+    { 0x072702, 0xFFFFFF, "LOGICAL UNIT SOFTWARE WRITE PROTECTED"},
+    { 0x072703, 0xFFFFFF, "ASSOCIATED WRITE PROTECT"},
+    { 0x072704, 0xFFFFFF, "PERSISTENT WRITE PROTECT"},
+    { 0x072705, 0xFFFFFF, "PERMANENT WRITE PROTECT"},
+    { 0x072706, 0xFFFFFF, "CONDITIONAL WRITE PROTECT"},
+    { 0x062800, 0xFFFFFF, "NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED"},
+    { 0x062801, 0xFFFFFF, "IMPORT OR EXPORT ELEMENT ACCESSED"},
+    { 0x062900, 0xFFFFFF, "POWER ON, RESET, OR BUS DEVICE RESET OCCURRED"},
+    { 0x062901, 0xFFFFFF, "POWER ON OCCURRED"},
+    { 0x062902, 0xFFFFFF, "SCSI BUS RESET OCCURRED"},
+    { 0x062903, 0xFFFFFF, "BUS DEVICE RESET FUNCTION OCCURRED"},
+    { 0x062904, 0xFFFFFF, "DEVICE INTERNAL RESET"},
+    { 0x062A00, 0xFFFFFF, "PARAMETERS CHANGED"},
+    { 0x062A01, 0xFFFFFF, "MODE PARAMETERS CHANGED"},
+    { 0x062A02, 0xFFFFFF, "LOG PARAMETERS CHANGED"},
+    { 0x062A03, 0xFFFFFF, "RESERVATIONS PREEMPTED"},
+    { 0x052B00, 0xFFFFFF, "COPY CANNOT EXECUTE SINCE HOST CANNOT DISCONNECT"},
+    { 0x052C00, 0xFFFFFF, "COMMAND SEQUENCE ERROR"},
+    { 0x052C01, 0xFFFFFF, "TOO MANY WINDOWS SPECIFIED"},
+    { 0x052C02, 0xFFFFFF, "INVALID COMBINATION OF WINDOWS SPECIFIED"},
+    { 0x052C03, 0xFFFFFF, "CURRENT PROGRAM AREA IS NOT EMPTY"},
+    { 0x052C04, 0xFFFFFF, "CURRENT PROGRAM AREA IS EMPTY"},
+    { 0x052C05, 0xFFFFFF, "PERSISTENT PREVENT CONFLICT"},
+    { 0x032D00, 0xFFFFFF, "OVERWRITE ERROR ON UPDATE IN PLACE"},
+    { 0x062E00, 0xFFFFFF, "INSUFFICIENT TIME FOR OPERATION"},
+    { 0x062F00, 0xFFFFFF, "COMMANDS CLEARED BY ANOTHER INITIATOR"},
+    { 0x023000, 0xFFFFFF, "INCOMPATIBLE MEDIUM INSTALLED"},
+    { 0x023001, 0xFFFFFF, "CANNOT READ MEDIUM - UNKNOWN FORMAT"},
+    { 0x023002, 0xFFFFFF, "CANNOT READ MEDIUM - INCOMPATIBLE FORMAT"},
+    { 0x053002, 0xFFFFFF, "CANNOT READ MEDIUM - INCOMPATIBLE FORMAT"},
+    { 0x023003, 0xFFFFFF, "CLEANING CARTRIDGE INSTALLED"},
+    { 0x053004, 0xFFFFFF, "CANNOT WRITE MEDIUM - UNKNOWN FORMAT"},
+    { 0x053005, 0xFFFFFF, "CANNOT WRITE MEDIUM - INCOMPATIBLE FORMAT"},
+    { 0x053006, 0xFFFFFF, "CANNOT FORMAT MEDIUM - INCOMPATIBLE MEDIUM"},
+    { 0x023007, 0xFFFFFF, "CLEANING FAILURE"},
+    { 0x053008, 0xFFFFFF, "CANNOT WRITE - APPLICATION CODE MISMATCH"},
+    { 0x053009, 0xFFFFFF, "CURRENT SESSION NOT FIXATED FOR APPEND"},
+    { 0x033100, 0xFFFFFF, "MEDIUM FORMAT CORRUPTED"},
+    { 0x033101, 0xFFFFFF, "FORMAT COMMAND FAILED"},
+    { 0x033102, 0xFFFFFF, "ZONED FORMATTING FAILED DUE TO SPARE LINKING"},
+    { 0x033200, 0xFFFFFF, "NO DEFECT SPARE LOCATION AVAILABLE"},
+    { 0x033201, 0xFFFFFF, "DEFECT LIST UPDATE FAILURE"},
+    { 0x033300, 0xFFFFFF, "TAPE LENGTH ERROR"},
+    { 0x043400, 0xFFFFFF, "ENCLOSURE FAILURE"},
+    { 0x043500, 0xFFFFFF, "ENCLOSURE SERVICES FAILURE"},
+    { 0x053501, 0xFFFFFF, "UNSUPPORTED ENCLOSURE FUNCTION"},
+    { 0x023502, 0xFFFFFF, "ENCLOSURE SERVICES UNAVAILABLE"},
+    { 0x043503, 0xFFFFFF, "ENCLOSURE SERVICES TRANSFER FAILURE"},
+    { 0x053504, 0xFFFFFF, "ENCLOSURE SERVICES TRANSFER REFUSED"},
+    { 0x033600, 0xFFFFFF, "RIBBON, INK, OR TONER FAILURE"},
+    { 0x013700, 0xFFFFFF, "ROUNDED PARAMETER"},
+    { 0x053800, 0xFFFFFF, "Reserved"},
+    { 0x053900, 0xFFFFFF, "SAVING PARAMETERS NOT SUPPORTED"},
+    { 0x023A00, 0xFFFFFF, "MEDIUM NOT PRESENT"},
+    { 0x023A01, 0xFFFFFF, "MEDIUM NOT PRESENT - TRAY CLOSED"},
+    { 0x023A02, 0xFFFFFF, "MEDIUM NOT PRESENT - TRAY OPEN"},
+    { 0x033B00, 0xFFFFFF, "SEQUENTIAL POSITIONING ERROR"},
+    { 0x033B01, 0xFFFFFF, "TAPE POSITION ERROR AT BEGINNING-OF-MEDIUM"},
+    { 0x033B02, 0xFFFFFF, "TAPE POSITION ERROR AT END-OF-MEDIUM"},
+    { 0x033B03, 0xFFFFFF, "TAPE OR ELECTRONIC VERTICAL FORMS UNIT NOT READY"},
+    { 0x043B04, 0xFFFFFF, "SLEW FAILURE"},
+    { 0x043B05, 0xFFFFFF, "PAPER JAM"},
+    { 0x033B06, 0xFFFFFF, "FAILED TO SENSE TOP-OF-FORM"},
+    { 0x033B07, 0xFFFFFF, "FAILED TO SENSE BOTTOM-OF-FORM"},
+    { 0x033B08, 0xFFFFFF, "REPOSITION ERROR"},
+    { 0x033B09, 0xFFFFFF, "READ PAST END OF MEDIUM"},
+    { 0x033B0A, 0xFFFFFF, "READ PAST BEGINNING OF MEDIUM"},
+    { 0x033B0B, 0xFFFFFF, "POSITION PAST END OF MEDIUM"},
+    { 0x033B0C, 0xFFFFFF, "POSITION PAST BEGINNING OF MEDIUM"},
+    { 0x053B0D, 0xFFFFFF, "MEDIUM DESTINATION ELEMENT FULL"},
+    { 0x053B0E, 0xFFFFFF, "MEDIUM SOURCE ELEMENT EMPTY"},
+    { 0x063B0F, 0xFFFFFF, "END OF MEDIUM REACHED"},
+    { 0x023B11, 0xFFFFFF, "MEDIUM MAGAZINE NOT ACCESSIBLE"},
+    { 0x063B12, 0xFFFFFF, "MEDIUM MAGAZINE REMOVED"},
+    { 0x063B13, 0xFFFFFF, "MEDIUM MAGAZINE INSERTED"},
+    { 0x063B14, 0xFFFFFF, "MEDIUM MAGAZINE LOCKED"},
+    { 0x063B15, 0xFFFFFF, "MEDIUM MAGAZINE UNLOCKED"},
+    { 0x043B16, 0xFFFFFF, "MECHANICAL POSITIONING OR CHANGER ERROR"},
+    { 0x003C00, 0x00FFFF, "Reserved"},
+    { 0x053D00, 0xFFFFFF, "INVALID BITS IN IDENTIFY MESSAGE"},
+    { 0x023E00, 0xFFFFFF, "LOGICAL UNIT HAS NOT SELF-CONFIGURED YET"},
+    { 0x043E01, 0xFFFFFF, "LOGICAL UNIT FAILURE"},
+    { 0x043E02, 0xFFFFFF, "TIMEOUT ON LOGICAL UNIT"},
+    { 0x063F00, 0xFFFFFF, "TARGET OPERATING CONDITIONS HAVE CHANGED"},
+    { 0x063F01, 0xFFFFFF, "MICROCODE HAS BEEN CHANGED"},
+    { 0x063F02, 0xFFFFFF, "CHANGED OPERATING DEFINITION"},
+    { 0x063F03, 0xFFFFFF, "INQUIRY DATA HAS CHANGED"},
+    { 0x044000, 0xFFFFFF, "RAM FAILURE (SHOULD USE 40 NN)"},
+    { 0x044000, 0xFFFF80, "DIAGNOSTIC FAILURE ON COMPONENT NN (80H-FFH)"},
+    { 0x044100, 0xFFFFFF, "DATA PATH FAILURE (SHOULD USE 40 NN)"},
+    { 0x044200, 0xFFFFFF, "POWER-ON OR SELF-TEST FAILURE (SHOULD USE 40 NN)"},
+    { 0x054300, 0xFFFFFF, "MESSAGE ERROR"},
+    { 0x044400, 0xFFFFFF, "INTERNAL TARGET FAILURE"},
+    { 0x0b4500, 0xFFFFFF, "SELECT OR RESELECT FAILURE"},
+    { 0x044600, 0xFFFFFF, "UNSUCCESSFUL SOFT RESET"},
+    { 0x044700, 0xFFFFFF, "SCSI PARITY ERROR"},
+    { 0x0b4800, 0xFFFFFF, "INITIATOR DETECTED ERROR MESSAGE RECEIVED"},
+    { 0x0b4900, 0xFFFFFF, "INVALID MESSAGE ERROR"},
+    { 0x044A00, 0xFFFFFF, "COMMAND PHASE ERROR"},
+    { 0x044B00, 0xFFFFFF, "DATA PHASE ERROR"},
+    { 0x044C00, 0xFFFFFF, "LOGICAL UNIT FAILED SELF-CONFIGURATION"},
+    { 0x0b4D00, 0xFFFF00, "TAGGED OVERLAPPED COMMANDS (NN = QUEUE TAG)"},
+    { 0x0B4E00, 0xFFFFFF, "OVERLAPPED COMMANDS ATTEMPTED"},
+    { 0x004F00, 0x00FFFF, "Reserved"},
+    { 0x005000, 0x00FFFF, "WRITE APPEND ERROR"},
+    { 0x005001, 0x00FFFF, "WRITE APPEND POSITION ERROR"},
+    { 0x005002, 0x00FFFF, "POSITION ERROR RELATED TO TIMING"},
+    { 0x035100, 0xFFFFFF, "ERASE FAILURE"},
+    { 0x035101, 0xFFFFFF, "ERASE FAILURE - Incomplete erase operation detected"},
+    { 0x035200, 0xFFFFFF, "CARTRIDGE FAULT"},
+    { 0x045300, 0xFFFFFF, "MEDIA LOAD OR EJECT FAILED"},
+    { 0x005301, 0x00FFFF, "UNLOAD TAPE FAILURE"},
+    { 0x025302, 0xFFFFFF, "MEDIUM REMOVAL PREVENTED"},
+    { 0x055302, 0xFFFFFF, "MEDIUM REMOVAL PREVENTED"},
+    { 0x005400, 0x00FFFF, "SCSI TO HOST SYSTEM INTERFACE FAILURE"},
+    { 0x055500, 0xFFFFFF, "SYSTEM RESOURCE FAILURE"},
+    { 0x005501, 0x00FFFF, "SYSTEM BUFFER FULL"},
+    { 0x005600, 0x00FFFF, "Reserved"},
+    { 0x035700, 0xFFFFFF, "UNABLE TO RECOVER TABLE-OF-CONTENTS"},
+    { 0x005800, 0x00FFFF, "GENERATION DOES NOT EXIST"},
+    { 0x005900, 0x00FFFF, "UPDATED BLOCK READ"},
+    { 0x065A00, 0xFFFFFF, "OPERATOR REQUEST OR STATE CHANGE INPUT"},
+    { 0x065A01, 0xFFFFFF, "OPERATOR MEDIUM REMOVAL REQUEST"},
+    { 0x065A02, 0xFFFFFF, "OPERATOR SELECTED WRITE PROTECT"},
+    { 0x065A03, 0xFFFFFF, "OPERATOR SELECTED WRITE PERMIT"},
+    { 0x065B00, 0xFFFFFF, "LOG EXCEPTION"},
+    { 0x065B01, 0xFFFFFF, "THRESHOLD CONDITION MET"},
+    { 0x065B02, 0xFFFFFF, "LOG COUNTER AT MAXIMUM"},
+    { 0x065B03, 0xFFFFFF, "LOG LIST CODES EXHAUSTED"},
+    { 0x065C00, 0xFFFFFF, "RPL STATUS CHANGE"},
+    { 0x065C01, 0xFFFFFF, "SPINDLES SYNCHRONIZED"},
+    { 0x035C02, 0xFFFFFF, "SPINDLES NOT SYNCHRONIZED"},
+    { 0x015D00, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED - Predicted Logical Unit Failure"},
+    { 0x015D01, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED - Predicted Media Failure"},
+    { 0x015D03, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED - Predicted Spare Area Exhaustion"},
+    { 0x015DFF, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED (FALSE)"},
+    { 0x065E00, 0xFFFFFF, "LOW POWER CONDITION ON"},
+    { 0x065E01, 0xFFFFFF, "IDLE CONDITION ACTIVATED BY TIMER"},
+    { 0x065E02, 0xFFFFFF, "STANDBY CONDITION ACTIVATED BY TIMER"},
+    { 0x065E03, 0xFFFFFF, "IDLE CONDITION ACTIVATED BY COMMAND"},
+    { 0x065E04, 0xFFFFFF, "STANDBY CONDITION ACTIVATED BY COMMAND"},
+    { 0x005F00, 0x00FFFF, "Reserved"},
+    { 0x046000, 0xFFFFFF, "LAMP FAILURE"},
+    { 0x036100, 0xFFFFFF, "VIDEO ACQUISITION ERROR"},
+    { 0x036101, 0xFFFFFF, "UNABLE TO ACQUIRE VIDEO"},
+    { 0x036102, 0xFFFFFF, "OUT OF FOCUS"},
+    { 0x046200, 0xFFFFFF, "SCAN HEAD POSITIONING ERROR"},
+    { 0x056300, 0xFFFFFF, "END OF USER AREA ENCOUNTERED ON THIS TRACK"},
+    { 0x056301, 0xFFFFFF, "PACKET DOES NOT FIT IN AVAILABLE SPACE"},
+    { 0x056400, 0xFFFFFF, "ILLEGAL MODE FOR THIS TRACK"},
+    { 0x056401, 0xFFFFFF, "INVALID PACKET SIZE"},
+    { 0x046500, 0xFFFFFF, "VOLTAGE FAULT"},
+    { 0x046600, 0xFFFFFF, "AUTOMATIC DOCUMENT FEEDER COVER UP"},
+    { 0x046601, 0xFFFFFF, "AUTOMATIC DOCUMENT FEEDER LIFT UP"},
+    { 0x046602, 0xFFFFFF, "DOCUMENT JAM IN AUTOMATIC DOCUMENT FEEDER"},
+    { 0x046603, 0xFFFFFF, "DOCUMENT MISS FEED AUTOMATIC IN DOCUMENT FEEDER"},
+    { 0x046700, 0xFFFFFF, "CONFIGURATION FAILURE"},
+    { 0x046701, 0xFFFFFF, "CONFIGURATION OF INCAPABLE LOGICAL UNITS FAILED"},
+    { 0x046702, 0xFFFFFF, "ADD LOGICAL UNIT FAILED"},
+    { 0x046703, 0xFFFFFF, "MODIFICATION OF LOGICAL UNIT FAILED"},
+    { 0x046704, 0xFFFFFF, "EXCHANGE OF LOGICAL UNIT FAILED"},
+    { 0x046705, 0xFFFFFF, "REMOVE OF LOGICAL UNIT FAILED"},
+    { 0x046706, 0xFFFFFF, "ATTACHMENT OF LOGICAL UNIT FAILED"},
+    { 0x046707, 0xFFFFFF, "CREATION OF LOGICAL UNIT FAILED"},
+    { 0x026800, 0xFFFFFF, "LOGICAL UNIT NOT CONFIGURED"},
+    { 0x046900, 0xFFFFFF, "DATA LOSS ON LOGICAL UNIT"},
+    { 0x046901, 0xFFFFFF, "MULTIPLE LOGICAL UNIT FAILURES"},
+    { 0x046902, 0xFFFFFF, "A PARITY/DATA MISMATCH"},
+    { 0x016A00, 0xFFFFFF, "INFORMATIONAL, REFER TO LOG"},
+    { 0x066B00, 0xFFFFFF, "STATE CHANGE HAS OCCURRED"},
+    { 0x066B01, 0xFFFFFF, "REDUNDANCY LEVEL GOT BETTER"},
+    { 0x066B02, 0xFFFFFF, "REDUNDANCY LEVEL GOT WORSE"},
+    { 0x036C00, 0xFFFFFF, "REBUILD FAILURE OCCURRED"},
+    { 0x036D00, 0xFFFFFF, "RECALCULATE FAILURE OCCURRED"},
+    { 0x046E00, 0xFFFFFF, "COMMAND TO LOGICAL UNIT FAILED"},
+    { 0x056F00, 0xFFFFFF, "COPY PROTECTION KEY EXCHANGE FAILURE - AUTHENTICATION FAILURE"},
+    { 0x056F01, 0xFFFFFF, "COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT PRESENT"},
+    { 0x056F02, 0xFFFFFF, "COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT ESTABLISHED"},
+    { 0x056F03, 0xFFFFFF, "READ OF SCRAMBLED SECTOR WITHOUT AUTHENTICATION"},
+    { 0x056F04, 0xFFFFFF, "MEDIA REGION CODE IS MISMATCHED TO LOGICAL UNIT REGION"},
+    { 0x056F05, 0xFFFFFF, "DRIVE REGION MUST BE PERMANENT/REGION RESET COUNT ERROR"},
+    { 0x037000, 0xFFFF00, "DECOMPRESSION EXCEPTION SHORT ALGORITHM ID OF NN"},
+    { 0x037100, 0xFFFFFF, "DECOMPRESSION EXCEPTION LONG ALGORITHM ID"},
+    { 0x037200, 0xFFFFFF, "SESSION FIXATION ERROR"},
+    { 0x037201, 0xFFFFFF, "SESSION FIXATION ERROR WRITING LEAD-IN"},
+    { 0x037202, 0xFFFFFF, "SESSION FIXATION ERROR WRITING LEAD-OUT"},
+    { 0x057203, 0xFFFFFF, "SESSION FIXATION ERROR - INCOMPLETE TRACK IN SESSION"},
+    { 0x057204, 0xFFFFFF, "EMPTY OR PARTIALLY WRITTEN RESERVED TRACK"},
+    { 0x057205, 0xFFFFFF, "NO MORE RZONE RESERVATIONS ARE ALLOWED"},
+    { 0x037300, 0xFFFFFF, "CD CONTROL ERROR"},
+    { 0x017301, 0xFFFFFF, "POWER CALIBRATION AREA ALMOST FULL"},
+    { 0x037302, 0xFFFFFF, "POWER CALIBRATION AREA IS FULL"},
+    { 0x037303, 0xFFFFFF, "POWER CALIBRATION AREA ERROR"},
+    { 0x037304, 0xFFFFFF, "PROGRAM MEMORY AREA/RMA UPDATE FAILURE"},
+    { 0x037305, 0xFFFFFF, "PROGRAM MEMORY AREA/RMA IS FULL"},
+    { 0x017306, 0xFFFFFF, "PROGRAM MEMORY AREA/RMA IS (almost) FULL"},
+    { 0x008000, 0x008000, "VENDOR SPECIFIC"},
+    { 0x000000, 0x000000, "Unrecognised sense data"}
+};
+
+static char const *atapi_sense_to_str(uint8_t const key,
+                      uint8_t const asc, uint8_t const ascq)
+{
+    uint32_t i;
+    uint32_t code;
+
+    code = ((key & 0xFF) << 16) | ((asc & 0xFF) << 8) | (ascq & 0xFF);
+
+    for (i = 0; 1; ++i) {
+        if ((code & sense_data_texts[i].mask) == sense_data_texts[i].code) {
+            break;
+        }
+    }
+
+    return sense_data_texts[i].text;
+}
+
+static void atapi_pt_dump_hexa(void *message, unsigned int len)
+{
+    char *p = (char *)message;
+    int i;
+
+    if (!p) {
+        return;
+    }
+
+    PT_LOG("dumping %u bytes [", len);
+    for (i = 0; i < len;) {
+        /* print up to 8 at a time to reduce syslog line spamming */
+        int rem = len - i;
+        switch (rem)
+        {
+            case 1:
+                PT_LOG("pos=%d: 0x%02x ]\n", i, p[i]);
+                i += 1;
+                break;
+            case 2:
+                PT_LOG("pos=%d: 0x%02x 0x%02x ]\n",
+                       i, p[i], p[i+1]);
+                i += 2;
+                break;
+            case 3:
+                PT_LOG("pos=%d: 0x%02x 0x%02x 0x%02x ]\n",
+                       i, p[i], p[i+1], p[i+2]);
+                i += 3;
+                break;
+            case 4:
+                PT_LOG("pos=%d: 0x%02x 0x%02x 0x%02x 0x%02x ]\n",
+                       i, p[i], p[i+1], p[i+2], p[i+3]);
+                i += 4;
+                break;
+            case 5:
+                PT_LOG("pos=%d: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x ]\n",
+                       i, p[i], p[i+1], p[i+2], p[i+3], p[i+4]);
+                i += 5;
+                break;
+            case 6:
+                PT_LOG("pos=%d: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x ]\n",
+                       i, p[i], p[i+1], p[i+2], p[i+3], p[i+4], p[i+5]);
+                i += 6;
+                break;
+            case 7:
+                PT_LOG("pos=%d: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x "
+                       "0x%02x ]\n", i, p[i], p[i+1], p[i+2], p[i+3], p[i+4],
+                       p[i+5], p[i+6]);
+                i += 7;
+                break;
+            default:
+                /* >= 8 */
+                PT_LOG("pos=%d: 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x "
+                       "0x%02x 0x%02x ]\n", i, p[i], p[i+1], p[i+2], p[i+3],
+                       p[i+4], p[i+5], p[i+6], p[i+7]);
+                i += 8;
+                break;
+        }
+    }
+}
+
+/* For each SCSI command we need to know up to 3 data sizes. These are:
+ * 1. The amount of data to send to the LU.
+ * 2. The size of the buffer provided for data sent back from the LU.
+ * 3. The amount of data the LU wanted to send.
+ *
+ * These are all measured in bytes.
+ *
+ * The table ide_atapi_cmd_data_sizes specifies how to determine these sizes
+ * for each SCSI command. Each size is given by:
+ *
+ *   constant + (base * block_size)
+ *
+ * where base is a value specified within the command data. This is specified
+ * in our table as an offset into the data at which the value starts and the
+ * size of the value, in bytes. All base value are assumed to be MSB first
+ * (lowest offset).
+ *
+ * The number of bytes forming the base value can only take values between 0
+ * and 4 inclusive, with 0 indicating that there is no base value.
+ *
+ * The amount of data to send to the LU and the size of the receiving buffer
+ * are both determined from the CDB. A value of 0 means that no data is
+ * transfered and a value of -1 indicates that the table entry is invalid (eg
+ * undefined command).
+ *
+ * The amount of data the LU wanted to return is determined from the returned
+ * data. A value of 0 is invalid and a value of -1 indicates that this size is
+ * the same as the receiving buffer size.
+ *
+ * A few commands are too complex for this scheme and so are handled by code in
+ * ide_atapi_pt_cmd() and ide_atapi_pt_do_sg_io().
+ */
+
+#define SET_ATAPI_CMD(cmd, o1, o2, o3, o4, b1, b2, b3, b4, i1, i2, i3, i4) \
+    [ cmd ] = { \
+      .dout_recipe = {.len_const = o1, .len_offset = o2, .len_size =  o3, .block_size = o4}, \
+      .buffer_recipe = {.len_const = b1, .len_offset = b2, .len_size =  b3, .block_size = b4}, \
+      .din_recipe = {.len_const = i1, .len_offset = i2, .len_size = i3, .block_size = i4}, \
+      .name = #cmd \
+    }
+struct atapi_pt_size_recipes {
+    uint32_t len_const;
+    uint32_t len_offset;
+    uint32_t len_size;
+    uint32_t block_size;
+};
+
+// define a shorter name to make the following table easier to read
+#define CDFSZ          CD_FRAMESIZE
+
+static const struct {
+    struct atapi_pt_size_recipes dout_recipe;
+    struct atapi_pt_size_recipes buffer_recipe;
+    struct atapi_pt_size_recipes din_recipe;
+    char const *name;
+} atapi_cmd_table[0x100] = {
+    /* SET_ATAPI_CMD(CMD,
+                     OUT[4],
+                     BUFFER[4],
+                     IN[4]) */
+    SET_ATAPI_CMD(GPCMD_TEST_UNIT_READY,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_REQUEST_SENSE,
+                  0, 0, 0, 0,
+                  0, 4, 1, 1,
+                  8, 7, 1, 1),
+    SET_ATAPI_CMD(GPCMD_FORMAT_UNIT,
+                  12, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_INQUIRY,
+                  0, 0, 0, 0,
+                  0, 4, 1, 1,
+                  5, 4, 1, 1),
+    SET_ATAPI_CMD(GPCMD_START_STOP_UNIT,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_READ_FORMAT_CAPACITIES,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  4, 3, 1, 1),
+    SET_ATAPI_CMD(GPCMD_READ_CDVD_CAPACITY,
+                  0, 0, 0, 0,
+                  8, 0, 0, 0,
+                  8, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_READ_10,
+                  0, 0, 0, 0,
+                  0, 7, 2, CDFSZ,
+                  -1,0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_WRITE_10,
+                  0, 7, 2, CDFSZ,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SEEK,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_WRITE_AND_VERIFY_10,
+                  0, 7, 2, CDFSZ,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_VERIFY_10,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_FLUSH_CACHE,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_WRITE_BUFFER,
+                  0, 6, 3, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_READ_BUFFER,
+                  0, 0, 0, 0,
+                  0, 6, 3, 1,
+                  4, 1, 3, 1),
+    SET_ATAPI_CMD(GPCMD_READ_SUBCHANNEL,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  4, 2, 2, 1),
+    SET_ATAPI_CMD(GPCMD_READ_TOC_PMA_ATIP,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_READ_HEADER,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  8, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_PLAY_AUDIO_10,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_GET_CONFIGURATION,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  4, 0, 4, 1),
+    SET_ATAPI_CMD(GPCMD_PLAY_AUDIO_MSF,
+                  0, 0, 0, 0,
+                  -1,0, 0, 0,
+                  -1,0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_GET_EVENT_STATUS_NOTIFICATION,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_PAUSE_RESUME,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_STOP_PLAY_SCAN,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_READ_DISC_INFO,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_READ_TRACK_RZONE_INFO,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_RESERVE_RZONE_TRACK,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SEND_OPC,
+                  0, 7, 2, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_MODE_SELECT_10,
+                  0, 7, 2, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_REPAIR_RZONE_TRACK,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_MODE_SENSE_10,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_CLOSE_TRACK,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_READ_BUFFER_CAPACITY,
+                  0, 0, 0, 0,
+                  0, 7, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_SEND_CUE_SHEET,
+                  0, 6, 3, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_BLANK,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SEND_EVENT,
+                  0, 8, 2, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SEND_KEY,
+                  0, 8, 2, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_REPORT_KEY,
+                  0, 0, 0, 0,
+                  0, 8, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_LOAD_UNLOAD,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SET_READ_AHEAD,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_READ_12,
+                  0, 0, 0, 0,
+                  0, 6, 4, CDFSZ,
+                  -1,0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_WRITE_12,
+                  0, 6, 4, CDFSZ,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_GET_PERFORMANCE,
+                  0, 0, 0, 0,
+                  0, 8, 2, 1,
+                  4, 0, 4, 1),
+    SET_ATAPI_CMD(GPCMD_READ_DVD_STRUCTURE,
+                  0, 0, 0, 0,
+                  0, 8, 2, 1,
+                  2, 0, 2, 1),
+    SET_ATAPI_CMD(GPCMD_SET_STREAMING,
+                  0, 9, 2, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_READ_CD_MSF,
+                  0, 0, 0, 0,
+                  -1,0, 0, 0,
+                  -1,0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SCAN,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SET_SPEED,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_PLAY_CD,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_MECHANISM_STATUS,
+                  0, 0, 0, 0,
+                  0, 8, 2, 1,
+                  8, 6, 2, 1),
+    SET_ATAPI_CMD(GPCMD_READ_CD,
+                  0, 0, 0, 0,
+                  0, 6, 3, 1,
+                  -1,0, 0, 0),
+    SET_ATAPI_CMD(GPCMD_SEND_DVD_STRUCTURE,
+                  0, 8, 2, 1,
+                  0, 0, 0, 0,
+                  0, 0, 0, 0),
+    /* 0xC0 - 0xFF: intentionaly left blank */
+};
+
+enum atapi_pt_recipe_select {
+    ide_atapi_pt_size_dout,    // size of dout
+    ide_atapi_pt_size_buffer,    // size of din buffer
+    ide_atapi_pt_size_din    // size of din data
+};
+
+static int ptcmd_open(BlockDriverState *bs, IDEState *s)
+{
+    return bdrv_direct_ioctl(bs, ATAPI_PT_OPEN, s);
+}
+
+static bool ptcmd_get_global_media_lock(BlockDriverState *bs)
+{
+    uint32_t lock_state = 0;
+
+    bdrv_direct_ioctl(bs, ATAPI_PT_ACQUIRE_LOCK, &lock_state);
+
+    if (lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+        return true;
+    }
+
+    return false;
+}
+
+static void ptcmd_set_global_media_state(BlockDriverState *bs, bool present)
+{
+    uint32_t media_present = present ? 1 : 0;
+    bdrv_direct_ioctl(bs, ATAPI_PT_SET_GLOB_MEDIA_STATE, &media_present);
+}
+
+static bool ptcmd_get_global_media_state(BlockDriverState *bs)
+{
+    uint32_t media_present = 0;
+
+    bdrv_direct_ioctl(bs, ATAPI_PT_GET_GLOB_MEDIA_STATE, &media_present);
+
+    return media_present ? true : false;
+}
+
+static int ptcmd_do_sg_io(BlockDriverState *bs, void *buf)
+{
+    return bdrv_direct_ioctl(bs, ATAPI_PT_SG_IO, buf);
+}
+
+static int ptcmd_do_sg_get_reserved_size(BlockDriverState *bs, void *buf)
+{
+    return bdrv_direct_ioctl(bs, ATAPI_PT_SG_GET_RESERVED_SIZE, buf);
+}
+
+static inline char const *atapi_cmd_to_str(uint8_t const cmd)
+{
+    if (atapi_cmd_table[cmd].name == NULL) {
+        return "Unsupported command";
+    }
+
+    return atapi_cmd_table[cmd].name;
+}
+
+#define MSF_TO_FRAMES(M, S, F) (((M) * CD_SECS + (S)) * CD_FRAMES + (F))
+
+static inline void cpu_to_ube16(uint8_t * buf, int val)
+{
+    buf[0] = val >> 8;
+    buf[1] = val & 0xff;
+}
+
+static inline void cpu_to_ube32(uint8_t * buf, unsigned int val)
+{
+    buf[0] = val >> 24;
+    buf[1] = val >> 16;
+    buf[2] = val >> 8;
+    buf[3] = val & 0xff;
+}
+
+static inline int ube16_to_cpu(const uint8_t * buf)
+{
+    return (buf[0] << 8) | buf[1];
+}
+
+static inline int ube24_to_cpu(const uint8_t * buf)
+{
+    return (buf[0] << 16) | (buf[1] << 8) | buf[2];
+}
+
+static inline int ube32_to_cpu(const uint8_t * buf)
+{
+    return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
+}
+
+/* The table ide_atapi_cmd_data_sizes specifies how to determine these sizes
+ * for each SCSI command. Each size is given by:
+ *
+ * constant + (base * block_size)
+ *
+ * This function help us to compute the size */
+static uint32_t atapi_pt_get_data_size(enum atapi_pt_recipe_select size_select,
+                                       uint8_t command, uint8_t * data)
+{
+    struct atapi_pt_size_recipes const *size_devfn = NULL;
+    uint32_t size = 0;
+
+    if (atapi_cmd_table[command].name == 0) {
+        PT_LOG("invalid command=0x%02x\n", command);
+        return -1;
+    }
+
+    /* Get the size recipe */
+    switch (size_select) {
+        case ide_atapi_pt_size_dout:
+            size_devfn = &atapi_cmd_table[command].dout_recipe;
+            break;
+        case ide_atapi_pt_size_buffer:
+            size_devfn = &atapi_cmd_table[command].buffer_recipe;
+            break;
+        case ide_atapi_pt_size_din:
+            size_devfn = &atapi_cmd_table[command].din_recipe;
+            break;
+        default:
+            PT_LOG("invalid data size selection=%d\n", size_select);
+            return -1;
+    }
+
+    /* Determine the base size. */
+    switch (size_devfn->len_size) {
+        case 0:
+            /* If no specified len size, keep 0 */
+            size = 0;
+            break;
+        case 1:
+            /* Get a size on 8 bits from the command buffer */
+            size = data[size_devfn->len_offset];
+            break;
+        case 2:
+            /* Get a size on 16bits from the command buffer */
+            size = ube16_to_cpu(data + size_devfn->len_offset);
+            break;
+        case 3:
+            /* Get a size on 24bits from the command buffer */
+            size = ube24_to_cpu(data + size_devfn->len_offset);
+            break;
+        case 4:
+            /* Get a size on 32bits from the command buffer */
+            size = ube32_to_cpu(data + size_devfn->len_offset);
+            break;
+        default:
+            PT_LOG("invalid data size len - cmd=0x%02x select=%d size=%d\n",
+                   command, size_select, size_devfn->len_size);
+            return -1;
+    }
+
+    /* Compute the size of data: (base * block_size) + len_const */
+    size *= size_devfn->block_size;
+    size += size_devfn->len_const;
+    return size;
+}
+
+/* This function set an error on the IDE Bus, the guest will be notified */
+static void atapi_pt_set_error(IDEState *s,
+                               int sense_key, int asc, int ascq, int error)
+{
+    ATAPIPassThroughState *as = s->atapipts;
+    memset(&as->sense, 0, sizeof(as->sense));
+    as->sense.error_code = 0x70;
+    as->sense.sense_key = sense_key;
+    as->sense.asc = asc;
+    as->sense.ascq = ascq;
+    as->sense.error_code = error;
+    as->sense.add_sense_len = 10;
+
+    PT_DEBUG_SENSE(as->sense.sense_key, as->sense.asc, as->sense.ascq);
+
+    s->status = READY_STAT | ERR_STAT;
+    s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;
+    ide_set_irq(s->bus);
+}
+
+static void atapi_pt_error(IDEState *s)
+{
+    s->status = READY_STAT | ERR_STAT;
+    s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;
+    ide_set_irq(s->bus);
+}
+
+void atapi_pt_notify_medium_maybe_changed(void *opaque)
+{
+    IDEState *s = (IDEState *)opaque;
+    ATAPIPassThroughState *as = s->atapipts;
+
+    if (!as->allow_notifications) {
+        /* nothing to do if guest has not yet communicated to drive */
+        PT_LOG("ignoring request to notify guest that medium has changed\n");
+        return;
+    }
+
+    /* if the global state suggests media is in the drive, setup notify */
+    if (ptcmd_get_global_media_state(blk_bs(s->blk))) {
+        as->notify_new_media = true;
+    }
+
+    PT_LOG("notifying guest that medium has (possibly) changed\n");
+    atapi_pt_set_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED, 0, 0x70);
+}
+
+void atapi_pt_notify_medium_ejected(void *opaque)
+{
+    IDEState *s = (IDEState *)opaque;
+    ATAPIPassThroughState *as = s->atapipts;
+
+    if (!as->allow_notifications) {
+        /* nothing to do if guest has not yet communicated to drive */
+        PT_LOG("ignoring request to notify guest that medium has ejected\n");
+        return;
+    }
+
+    as->notify_eject_requested = true;
+
+    PT_LOG("notifying guest that medium has ejected\n");
+    atapi_pt_set_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT, 0, 0x70);
+}
+
+static int atapi_pt_do_dispatch(volatile IDEState *s)
+{
+    int r = 0;
+    struct sg_io_v4 cmd;
+    int is_dout = 0;
+    uint32_t seg_offset = 0;
+    uint32_t lba;
+    uint16_t len;
+    uint32_t segment = 0;
+    __u32 *cmd_len_p;
+    uint32_t *req_len_p;
+    uint8_t request[ATAPI_PACKET_SIZE];
+    ATAPIPassThroughState *as = s->atapipts;
+
+    PT_DEBUG("dispatch for %s\n", atapi_cmd_to_str(as->request[0]));
+
+    memcpy(request, (void *)as->request, sizeof(request));
+
+    is_dout = (as->dout_xfer_len > 0) ? 1 : 0;
+    cmd_len_p = is_dout ? &(cmd.dout_xfer_len) : &(cmd.din_xfer_len);
+    req_len_p = is_dout ? &(as->dout_xfer_len) : &(as->din_xfer_len);
+
+    memset(&cmd, 0, sizeof(cmd));
+    cmd.guard = 'Q';    /* To differentiate from v3 */
+    cmd.protocol = BSG_PROTOCOL_SCSI;
+    cmd.subprotocol = BSG_SUB_PROTOCOL_SCSI_CMD;
+    cmd.request_len = ATAPI_PACKET_SIZE;
+    cmd.request = (uintptr_t) request;
+    cmd.response = (uintptr_t) & (as->sense);
+    cmd.max_response_len = sizeof(as->sense);
+    cmd.timeout = as->timeout;
+
+    /* -- SEGMENT ---------------------------------------------------------- */
+    do {
+        cmd.din_xferp = (uintptr_t) (s->io_buffer + seg_offset);
+        cmd.dout_xferp = (uintptr_t) (s->io_buffer + seg_offset);
+        *cmd_len_p = (as->max_xfer_len > (*req_len_p - seg_offset)) ?
+                     (*req_len_p - seg_offset) : as->max_xfer_len;
+
+        if (*req_len_p > as->max_xfer_len) {
+            if ((as->request[0] == GPCMD_WRITE_10) ||
+                (as->request[0] == GPCMD_WRITE_AND_VERIFY_10) ||
+                (as->request[0] == GPCMD_READ_10)) {
+                PT_DEBUG("'%s' total(%d) seg(%d:%d), remaining: %d\n",
+                       atapi_cmd_to_str(as->request[0]),
+                       *req_len_p, segment, *cmd_len_p,
+                       *req_len_p - seg_offset - *cmd_len_p);
+
+                segment++;
+
+                /* Adjust LBA offset and length */
+                lba = ube32_to_cpu((uint8_t *) as->request + 2);
+                lba += seg_offset / CD_FRAMESIZE;
+                cpu_to_ube32(request + 2, lba);
+                len = *cmd_len_p / CD_FRAMESIZE;
+                cpu_to_ube16(request + 7, len);
+
+                PT_DEBUG("adjust lba from %d to %d, length from %d to %d\n",
+                       ube32_to_cpu((uint8_t *) as->request + 2), lba,
+                       ube16_to_cpu((uint8_t *) as->request + 7), len);
+            } else {
+                PT_LOG("failing overlong cmd=%s (%d, max: %d)\n",
+                       atapi_cmd_to_str(as->request[0]),
+                       *req_len_p, as->max_xfer_len);
+                atapi_pt_set_error((IDEState *) s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+                r = -1;
+            }
+        }
+        seg_offset += *cmd_len_p;
+
+        if (cmd.timeout != 15000) {
+            PT_DEBUG("timeout=%d msec\n", cmd.timeout);
+        }
+
+        if (!r) {
+            r = ptcmd_do_sg_io(blk_bs(s->blk), &cmd);
+        }
+        if (r) {
+            as->result = r;
+        } else if (cmd.driver_status) {
+            as->result = cmd.driver_status;
+        } else if (cmd.transport_status) {
+            as->result = cmd.transport_status;
+        } else if (cmd.device_status) {
+            as->result = cmd.device_status;
+        } else {
+            as->result = 0;
+        }
+        PT_DEBUG("ioctl=%d driver=%d transport=%d device=%d=\n",
+               r, cmd.driver_status, cmd.transport_status, cmd.device_status);
+        PT_DEBUG("result=%d req_len=%d seg_offset=%d last_segment=%s\n",
+               as->result, *req_len_p, seg_offset,
+               (*req_len_p > seg_offset) ? "no" : "yes");
+    } while ((!as->result) && (*req_len_p > seg_offset));
+
+    if (as->result) {
+        char *p = (char *)&as->sense;
+        switch (as->sense.error_code) {
+            case 0x70 ... 0x71:
+                PT_DEBUG("command error:\n");
+                PT_DEBUG_SENSE(as->sense.sense_key, as->sense.asc, as->sense.ascq);
+                break;
+            case 0x72 ... 0x73:
+                PT_DEBUG("command spc-3 error:\n");
+                PT_DEBUG_SENSE(p[1] & 0xF, p[2], p[3]);
+                PT_LOG("suppressing error\n");
+                as->result = 0;
+                break;
+            default:
+                PT_LOG("error: unrecognised sense format str=%s\n",
+                       atapi_cmd_to_str(as->request[0]));
+                break;
+            }
+    }
+
+    return r;
+}
+
+/* Worker thread... This thread is waiting for a signal from the main processus
+ * and perform the command via the atapi_pt_do_dispatch function. */
+static void *atapi_pt_worker_thread(void *arg)
+{
+    volatile IDEState *s = (volatile IDEState *)arg;
+    ATAPIPassThroughState *as = s->atapipts;
+
+    PT_LOG("atapi pt thread worker started!\n");
+
+    while (as->thread_continue) {
+        if (event_notifier_wait_and_clear(&as->e_cmd, 0) == 1) {
+            atapi_pt_do_dispatch(s);
+            event_notifier_set(&as->e_ret);
+        }
+    }
+
+    PT_LOG("atapi pt thread worker bailed!\n");
+
+    qemu_thread_exit(NULL);
+    return NULL;
+}
+
+static void event_status_notification_complete(IDEState *s)
+{
+    ATAPIPassThroughState *as = s->atapipts;
+    uint8_t *b = s->io_buffer;
+    int ev_class = b[2];
+    int ev_code = b[4];
+
+    if (ev_class == 4 && ev_code == MEC_NEW_MEDIA) {
+        /* This is a "new media" message coming from actual drive */
+        PT_LOG("new media detected\n");
+        ptcmd_set_global_media_state(blk_bs(s->blk), true);
+    }
+
+    if (ev_class == 4 && ev_code == MEC_MEDIA_REMOVAL) {
+        /* This is a "media removed" message coming from actual drive */
+        PT_LOG("media removed\n");
+        ptcmd_set_global_media_state(blk_bs(s->blk), false);
+    }
+
+    if (ev_class == 4) {
+        PT_VERBOSE("media class event\n");
+    } else if (b[4] == 0 && b[5] == 0 && b[6] == 0 && b[7] == 0) {
+        PT_VERBOSE("no requested classes available event\n");
+    } else {
+        /* no spoofing other event types, just allow it through */
+        PT_VERBOSE("passthrough event status notification\n");
+        return;
+    }
+
+    if (as->notify_eject_requested) {
+        PT_VERBOSE("spoofing MEC_EJECT_REQUESTED\n");
+        b[2] = 4;
+        b[4] = MEC_EJECT_REQUESTED;
+        b[5] = MS_TRAY_OPEN;
+        b[6] = 0;
+        b[7] = 0;
+        as->notify_eject_requested = false;
+        as->notify_media_removed = true;
+        return;
+    }
+
+    if (as->notify_media_removed) {
+        PT_VERBOSE("spoofing MEC_MEDIA_REMOVAL\n");
+        b[2] = 4;
+        b[4] = MEC_MEDIA_REMOVAL;
+        b[5] = MS_TRAY_OPEN;
+        b[6] = 0;
+        b[7] = 0;
+        as->notify_media_removed = false;
+        return;
+    }
+
+    if (as->notify_new_media) {
+        PT_VERBOSE("spoofing MEC_NEW_MEDIA\n");
+        b[2] = 4;
+        b[4] = MEC_NEW_MEDIA;
+        b[5] = MS_MEDIA_PRESENT;
+        b[6] = 0;
+        b[7] = 0;
+        as->notify_new_media = false;
+        return;
+    }
+
+    /* if we don't have the lock, we need to hijack this message */
+    if (!ptcmd_get_global_media_lock(blk_bs(s->blk))) {
+        PT_VERBOSE("spoofing MEC_NO_CHANGE\n");
+        b[2] = 4;
+        b[4] = MEC_NO_CHANGE;
+        b[5] = MS_TRAY_OPEN;
+        b[6] = 0;
+        b[7] = 0;
+        return;
+    }
+
+    PT_VERBOSE("passthrough media class event status notification\n");
+}
+
+/* AIO Read handler:
+ * This function is call to receive message from the sgio_dispatch_fd.
+ * It help us to get the return code of IOCTL from the worker thread
+ * 'atapi_pt_worker_thread', notify the guest of the return status of the SG_IO
+ * and handle error */
+static void atapi_pt_event_read(struct EventNotifier *e)
+{
+    IDEState *s = (IDEState *) e->opaque;
+    ATAPIPassThroughState *as = s->atapipts;
+    uint32_t din_actual;
+    bool glob_media_present;
+
+    PT_DEBUG("event read!\n");
+
+    event_notifier_test_and_clear(&as->e_ret);
+
+    glob_media_present = ptcmd_get_global_media_state(blk_bs(s->blk));
+
+    if (as->result) {
+        if ((as->sense.sense_key == SENSE_NOT_READY) &&
+            (as->sense.asc == ASC_MEDIUM_NOT_PRESENT)) {
+            if (glob_media_present) {
+                PT_DEBUG("sense no medium - media must be absent?\n");
+                ptcmd_set_global_media_state(blk_bs(s->blk), false);
+            }
+        }
+        atapi_pt_error(s);
+        return;
+    }
+
+    if ((as->request[0] == GPCMD_TEST_UNIT_READY) ||
+        (as->request[0] == GPCMD_REQUEST_SENSE) ||
+        (as->request[0] == GPCMD_READ_CDVD_CAPACITY) ||
+        (as->request[0] == GPCMD_READ_10) ||
+        (as->request[0] == GPCMD_READ_12) ||
+        (as->request[0] == GPCMD_READ_DISC_INFO)) {
+        if (!glob_media_present) {
+            PT_DEBUG("read command detected - media must be present?\n");
+            ptcmd_set_global_media_state(blk_bs(s->blk), true);
+        }
+    }
+
+    if (as->request[0] == GPCMD_GET_EVENT_STATUS_NOTIFICATION) {
+        PT_DEBUG("event status notification command\n");
+        event_status_notification_complete(s);
+    }
+
+    if (!ptcmd_get_global_media_lock(blk_bs(s->blk))) {
+        if (as->request[0] == GPCMD_GET_CONFIGURATION) {
+            PT_VERBOSE("spoofing GPCMD_GET_CONFIGURATION\n");
+            /*
+             * report no current profile if media should be not present in guest.
+             * udev uses the current profile to detect media presence.
+             * Bytes 6,7 hold current profile.
+             */
+            s->io_buffer[6] = 0;
+            s->io_buffer[7] = 0;
+        }
+    }
+
+    if (as->din_xfer_len == 0) {
+        /* Nothing else to do */
+        ide_atapi_cmd_ok(s);
+
+        /* commands have gone through - make sure to allow notifications */
+        as->allow_notifications = true;
+        return;
+    }
+
+    din_actual = atapi_pt_get_data_size(ide_atapi_pt_size_din,
+                                        as->request[0], s->io_buffer);
+
+    /* din_xfer_len is the size of the buffer provided for the din data,
+     * din_actual in the size of the data the LU tried to send to us. Either one
+     * may be bigger. */
+    if (as->request[0] == GPCMD_READ_BUFFER) {
+        switch (as->request[1] & 7) {
+        case 0:    // data with header, as specified in atapi_data_sizes table
+            break;
+        case 2:    // data only
+            din_actual = as->din_xfer_len;
+            break;
+        case 3:    // header only
+            din_actual = 4;
+            break;
+        case 1:    // vendor specific
+        default:
+            PT_LOG("illegal read buffer mode %d\n", s->io_buffer[1] & 7);
+            atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                               ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+            return;
+        }
+    }
+
+    if (din_actual == (__u32) - 1) {
+        din_actual = as->din_xfer_len;
+    }
+
+    PT_DEBUG("read %d bytes of data (buffer size %d)\n", din_actual,
+                                                         as->din_xfer_len);
+
+    ide_atapi_cmd_reply(s, din_actual, as->din_xfer_len);
+
+    /* commands have gone through - make sure to allow notifications */
+    as->allow_notifications = true;
+}
+
+int atapi_pt_init(IDEState * s)
+{
+    ATAPIPassThroughState *as = NULL;
+    int error = 0;
+
+    as = g_malloc(sizeof(ATAPIPassThroughState));
+    if (as == NULL) {
+        PT_LOG("malloc failed!\n");
+        return -1;
+    }
+
+    memset(as, 0, sizeof(ATAPIPassThroughState));
+    s->atapipts = as;
+
+    /* disable notifications until guest is ready */
+    as->allow_notifications = false;
+
+    /* register with backend */
+    if (ptcmd_open(blk_bs(s->blk), s) != 0) {
+        PT_LOG("ptcmd_open failed: %s\n", strerror(errno));
+        g_free(as);
+        return -1;
+    }
+
+    /* create event notifier */
+    error = event_notifier_init(&as->e_cmd, 0 /* Do not activate it now */ );
+    if (error != 0) {
+        PT_LOG("[%s] unable to create EventNotifier", strerror(error));
+        g_free(as);
+        return -1;
+    }
+
+    error = event_notifier_init(&as->e_ret, 0 /* Do not activate it now */ );
+    if (error != 0) {
+        PT_LOG("[%s] unable to create EventNotifier", strerror(error));
+        g_free(as);
+        return -1;
+    }
+
+    /* setup worker thread */
+    as->thread_continue = true;
+    qemu_thread_create(&(as->thread), "atapi_pt_th", atapi_pt_worker_thread,
+                       s, QEMU_THREAD_JOINABLE);
+
+    /*
+     * Get the reserved size:
+     * Find out the maximum block size the hardware supports. This is needed
+     * for USB drives where it is 120kb (less than the normal 128kb for some
+     * reason)
+     */
+    if (ptcmd_do_sg_get_reserved_size(blk_bs(s->blk), &(as->max_xfer_len)) != 0) {
+        PT_LOG("SG_GET_RESERVED_SIZE failed: %s\n", strerror(errno));
+        as->thread_continue = false;
+        event_notifier_cleanup(&as->e_cmd);
+        event_notifier_cleanup(&as->e_ret);
+        g_free(as);
+        return -1;
+    }
+    as->max_xfer_len = (as->max_xfer_len + CD_FRAMESIZE - 1) &
+                        ~(CD_FRAMESIZE - 1);
+
+    as->e_ret.opaque = s;
+    /*
+     * The two ends of the event handling are all internal to this module
+     * so passing false for is_external.
+     */
+    event_notifier_set_handler(&as->e_ret, atapi_pt_event_read);
+
+    PT_LOG("initialization complete\n");
+    return 0;
+}
+
+static void atapi_pt_do_sg_io(IDEState * s)
+{
+    /* poke worker thread */
+    event_notifier_set(&s->atapipts->e_cmd);
+}
+
+void atapi_pt_dout_fetch_pio_done(IDEState * s)
+{
+    ide_transfer_stop(s);
+    atapi_pt_do_sg_io(s);
+}
+
+static void atapi_pt_dout_fetch_dma_done(void *opaque, int ret)
+{
+    IDEState *s = opaque;
+
+    if (ret < 0) {
+        ide_atapi_io_error(s, ret);
+        return;
+    }
+
+    s->bus->dma->ops->rw_buf(s->bus->dma, 0);
+
+    atapi_pt_do_sg_io(s);
+}
+
+static void atapi_pt_wcmd(IDEState * s)
+{
+    s->io_buffer_index = 0;
+    if (s->atapi_dma) {
+        s->io_buffer_index = 0;
+        s->io_buffer_size = s->atapipts->dout_xfer_len;
+        ide_start_dma(s, atapi_pt_dout_fetch_dma_done);
+    } else {        /* PIO */
+        s->packet_transfer_size = s->atapipts->dout_xfer_len;
+        s->io_buffer_size = 0;
+        s->elementary_transfer_size = 0;
+        s->status |= DRQ_STAT;
+        s->status &= ~BUSY_STAT;
+        s->nsector = (s->nsector & ~7) &
+                     ~ATAPI_INT_REASON_IO & ~ATAPI_INT_REASON_CD;
+        ide_transfer_start(s, s->io_buffer, s->atapipts->dout_xfer_len,
+                           atapi_pt_dout_fetch_pio_done);
+        ide_set_irq(s->bus);
+    }
+}
+
+static int atapi_pt_read_cd_block_size(uint8_t const *io_buffer)
+{
+    int sector_type = (io_buffer[1] >> 2) & 7;
+    int error_flags = (io_buffer[9] >> 1) & 3;
+    int flags_bits = io_buffer[9] & ~7;
+    int block_size = 0;
+
+    // expected sector type
+    switch (sector_type) {
+    case 0:        // Any type
+        switch (flags_bits) {
+        case 0x0:
+            block_size = 0;
+            break;
+        case 0x10:
+            block_size = 2048;
+            break;
+        case 0xf8:
+            block_size = 2352;
+            break;
+        default:
+            return -1;    // illegal
+        }
+        break;
+
+    case 1:        // CD-DA
+        block_size = (flags_bits) ? 2352 : 0;
+        break;
+
+    case 2:        // Mode 1
+        switch (flags_bits) {
+        case 0x0:
+            block_size = 0;
+            break;
+        case 0x10:
+        case 0x50:
+            block_size = 2048;
+            break;
+        case 0x18:
+        case 0x58:
+            block_size = 2336;
+            break;
+        case 0x20:
+        case 0x60:
+            block_size = 4;
+            break;
+        case 0x30:
+        case 0x70:
+        case 0x78:
+            block_size = 2052;
+            break;
+        case 0x38:
+            block_size = 2340;
+            break;
+        case 0x40:
+            block_size = 0;
+            break;
+        case 0xa0:
+            block_size = 16;
+            break;
+        case 0xb0:
+            block_size = 2064;
+            break;
+        case 0xb8:
+            block_size = 2352;
+            break;
+        case 0xe0:
+            block_size = 16;
+            break;
+        case 0xf0:
+            block_size = 2064;
+            break;
+        case 0xf8:
+            block_size = 2352;
+            break;
+        default:
+            return -1;    // illegal
+        }
+        break;
+
+    case 3:        // Mode 2
+        switch (flags_bits) {
+        case 0x0:
+            block_size = 0;
+            break;
+        case 0x10:
+        case 0x50:
+        case 0x18:
+        case 0x58:
+            block_size = 2336;
+            break;
+        case 0x20:
+        case 0x60:
+            block_size = 4;
+            break;
+        case 0x30:
+        case 0x70:
+        case 0x78:
+        case 0x38:
+            block_size = 2340;
+            break;
+        case 0x40:
+            block_size = 0;
+            break;
+        case 0xa0:
+            block_size = 16;
+            break;
+        case 0xb0:
+        case 0xb8:
+            block_size = 2352;
+            break;
+        case 0xe0:
+            block_size = 16;
+            break;
+        case 0xf0:
+        case 0xf8:
+            block_size = 2352;
+            break;
+        default:
+            return -1;    // illegal
+        }
+        break;
+
+    case 4:        // Mode 2 Form 1
+        switch (flags_bits) {
+        case 0x0:
+            block_size = 0;
+            break;
+        case 0x10:
+            block_size = 2048;
+            break;
+        case 0x18:
+            block_size = 2328;
+            break;
+        case 0x20:
+            block_size = 4;
+            break;
+        case 0x40:
+            block_size = 8;
+            break;
+        case 0x50:
+            block_size = 2056;
+            break;
+        case 0x58:
+            block_size = 2336;
+            break;
+        case 0x60:
+            block_size = 12;
+            break;
+        case 0x70:
+            block_size = 2060;
+            break;
+        case 0x78:
+            block_size = 2340;
+            break;
+        case 0xa0:
+            block_size = 16;
+            break;
+        case 0xe0:
+            block_size = 24;
+            break;
+        case 0xf0:
+            block_size = 2072;
+            break;
+        case 0xf8:
+            block_size = 2352;
+            break;
+        default:
+            return -1;    // illegal
+        }
+        break;
+
+    case 5:        // Mode 2 Form 2
+        switch (flags_bits) {
+        case 0x0:
+            block_size = 0;
+            break;
+        case 0x10:
+        case 0x18:
+            block_size = 2328;
+            break;
+        case 0x20:
+            block_size = 4;
+            break;
+        case 0x40:
+            block_size = 8;
+            break;
+        case 0x50:
+        case 0x58:
+            block_size = 2336;
+            break;
+        case 0x60:
+            block_size = 12;
+            break;
+        case 0x70:
+        case 0x78:
+            block_size = 2340;
+            break;
+        case 0xa0:
+            block_size = 16;
+            break;
+        case 0xe0:
+            block_size = 24;
+            break;
+        case 0xf0:
+        case 0xf8:
+            block_size = 2352;
+            break;
+        default:
+            return -1;    // illegal
+        }
+        break;
+
+    default:
+        return -1;
+    }
+
+    switch (error_flags) {
+        case 1:
+            block_size += 294;
+            break;
+        case 2:
+            block_size += 296;
+            break;
+        default:
+            break;
+    }
+
+    return block_size;
+}
+
+static bool atapi_pt_cmd_requires_write(uint8_t cmd)
+{
+    switch (cmd)
+    {
+        case GPCMD_BLANK:
+        case GPCMD_CLOSE_TRACK:
+        case GPCMD_FLUSH_CACHE:
+        case GPCMD_FORMAT_UNIT:
+        case GPCMD_SEND_DVD_STRUCTURE:
+        case GPCMD_SEND_OPC:
+        case GPCMD_WRITE_10:
+        case GPCMD_WRITE_12:
+        case GPCMD_WRITE_AND_VERIFY_10:
+        case GPCMD_WRITE_BUFFER:
+            return true;
+    }
+
+    return false;
+}
+
+static void atapi_pt_fake_sense(IDEState *s)
+{
+    ATAPIPassThroughState *as = s->atapipts;
+    int max_len = atapi_pt_get_data_size(ide_atapi_pt_size_buffer,
+                                         GPCMD_REQUEST_SENSE, as->request);
+
+    memset(&as->sense, 0, sizeof(as->sense));
+    //as->sense.valid = 1;
+    as->sense.error_code = 0x70;
+    as->sense.sense_key = NOT_READY;
+    as->sense.add_sense_len = 10;
+    as->sense.asc = ASC_MEDIUM_NOT_PRESENT;
+    as->sense.ascq = 0;
+
+    PT_LOG("sending fake request sense\n");
+    PT_DEBUG_SENSE(as->sense.sense_key, as->sense.asc, as->sense.ascq);
+
+    memcpy(s->io_buffer, &as->sense, sizeof(as->sense));
+    ide_atapi_cmd_reply(s, 18, max_len);
+}
+
+static void atapi_pt_fake_inquiry(IDEState * s)
+{
+    ATAPIPassThroughState *as = s->atapipts;
+
+    /* TODO: explain me */
+    uint8_t inquiry_data[96] = {0x05, 0x80, 0x05, 0x32,
+                                0x5b, 0x00, 0x00, 0x00,
+                                0x48, 0x4c, 0x2d, 0x44,
+                                0x54, 0x2d, 0x53, 0x54,
+                                0x43, 0x44, 0x52, 0x57,
+                                0x44, 0x56, 0x44, 0x20,
+                                0x4d, 0x55, 0x31, 0x30,
+                                0x4e, 0x20, 0x20, 0x20,
+                                0x41, 0x31, 0x30, 0x36,
+                                0x41, 0x42, 0x4c, 0x44,
+                                0x41, 0x20, 0x20, 0x20,
+                                0x30, 0x38, 0x2f, 0x31,
+                                0x31, 0x2f, 0x31, 0x38,
+                                0x20, 0x20, 0x20, 0x00,
+                                0x01, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00,
+                                0x00, 0x00, 0x00, 0x00};
+
+    PT_VERBOSE("sending fake inquiry reply\n");
+
+    memcpy(s->io_buffer, inquiry_data, sizeof(inquiry_data));
+
+    ide_atapi_cmd_reply(s, sizeof(inquiry_data), as->din_xfer_len);
+
+    /* clear sense data */
+    memset(&as->sense, 0, sizeof(as->sense));
+
+    /* faked commands to drive - allow notifications */
+    as->allow_notifications = true;
+}
+
+static bool atapi_pt_cmd_requires_ready(uint8_t cmd)
+{
+    switch (cmd)
+    {
+        case GPCMD_TEST_UNIT_READY:
+        case GPCMD_READ_CDVD_CAPACITY:
+        case GPCMD_READ_10:
+        case GPCMD_SEEK:
+        case GPCMD_READ_TOC_PMA_ATIP:
+        case GPCMD_READ_DISC_INFO:
+        case GPCMD_READ_12:
+        case GPCMD_READ_DVD_STRUCTURE:
+        case GPCMD_READ_CD:
+            return true;
+    }
+
+    return false;
+}
+
+void atapi_pt_cmd(IDEState * s)
+{
+    ATAPIPassThroughState *as = s->atapipts;
+    uint8_t cmd_code;
+    int block_size;
+
+    memcpy(as->request, s->io_buffer, ATAPI_PACKET_SIZE);
+    cmd_code = as->request[0];
+    as->timeout = 15000;
+    s->status |= BUSY_STAT;
+
+    as->dout_xfer_len = atapi_pt_get_data_size(ide_atapi_pt_size_dout,
+                                               cmd_code, as->request);
+
+    as->din_xfer_len = atapi_pt_get_data_size(ide_atapi_pt_size_buffer,
+                                              cmd_code, as->request);
+
+    PT_VERBOSE("sending command: 0x%02x (%s) dma=%d timeout=%u din=%d dout=%d\n",
+           cmd_code, atapi_cmd_to_str(cmd_code), s->atapi_dma, as->timeout,
+           as->din_xfer_len, as->dout_xfer_len);
+
+    if (pt_log_level > 1) {
+        atapi_pt_dump_hexa(as->request, ATAPI_PACKET_SIZE);
+    }
+
+    /* emulate commands when we don't have exclusive media lock */
+    if (!ptcmd_get_global_media_lock(blk_bs(s->blk))) {
+        if (atapi_pt_cmd_requires_ready(cmd_code)) {
+            /* error with medium not present for commands requiring lock */
+            PT_VERBOSE("refusing command early: 0x%02x (%s) dma=%d timeout=%u\n",
+                   cmd_code, atapi_cmd_to_str(cmd_code), s->atapi_dma,
+                   s->atapipts->timeout);
+
+            atapi_pt_set_error(s, SENSE_NOT_READY,
+                               ASC_MEDIUM_NOT_PRESENT, 0, 0x70);
+            return;
+        }
+
+        switch (cmd_code)
+        {
+            case GPCMD_INQUIRY:
+                atapi_pt_fake_inquiry(s);
+                return;
+            case GPCMD_REQUEST_SENSE:
+                atapi_pt_fake_sense(s);
+                return;
+            /* XXX: the below were allowed through in ioemu patch :( */
+            case GPCMD_GET_CONFIGURATION:
+            case GPCMD_GET_EVENT_STATUS_NOTIFICATION:
+            //case GPCMD_TEST_UNIT_READY: /* requires ready */
+            case GPCMD_GET_PERFORMANCE:
+            case GPCMD_MECHANISM_STATUS:
+            case GPCMD_MODE_SENSE_10:
+            case GPCMD_REPORT_KEY:
+            case GPCMD_READ_CDVD_CAPACITY:
+            case GPCMD_READ_FORMAT_CAPACITIES:
+                break;
+            default:
+                /* error with medium not present for commands requiring lock */
+                PT_VERBOSE("refusing command: 0x%02x (%s) dma=%d timeout=%u\n",
+                       cmd_code, atapi_cmd_to_str(cmd_code), s->atapi_dma,
+                       s->atapipts->timeout);
+
+                atapi_pt_set_error(s, SENSE_NOT_READY,
+                                   ASC_MEDIUM_NOT_PRESENT, 0, 0x70);
+                return;
+        }
+    }
+
+    /* check that we have write permissions before continuing write cmds */
+    if (bdrv_is_read_only(blk_bs(s->blk)) && atapi_pt_cmd_requires_write(cmd_code)) {
+        atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                           ASC_ILLEGAL_OPCODE, 0, 0x70);
+        PT_LOG("error: unable to perform cmd=%s: readonly device=%d\n",
+               atapi_cmd_to_str(cmd_code), bdrv_is_read_only(blk_bs(s->blk)));
+        return;
+    }
+
+    /* commands need special attention */
+    switch (cmd_code) {
+    case GPCMD_START_STOP_UNIT:
+        /* ignore stop motor command that windows issues on shutdown */
+        if ((as->request[4] & 0x3) == 0x0) {
+            PT_LOG("stop motor command ignored\n");
+            ide_atapi_cmd_ok(s);
+            return;
+        }
+        break;
+    case GPCMD_REQUEST_SENSE:
+        /* if we previously caught an error, report it */
+        if (*(char *)(&as->sense) != 0) {
+            int max_size = atapi_pt_get_data_size(ide_atapi_pt_size_buffer,
+                                                  GPCMD_REQUEST_SENSE, as->request);
+            int size = atapi_pt_get_data_size(ide_atapi_pt_size_din,
+                                              GPCMD_REQUEST_SENSE,
+                                              (uint8_t *) &as->sense);
+
+            memcpy(s->io_buffer, &as->sense, sizeof(as->sense));
+
+            PT_LOG("GPCMD_REQUEST_SENSE - reporting previous error\n");
+            PT_DEBUG_SENSE(as->sense.sense_key, as->sense.asc, as->sense.ascq);
+            ide_atapi_cmd_reply(s, size, max_size);
+
+            /* reported the error, now clear it */
+            *(char *)(&as->sense) = 0;
+            return;
+        }
+    //case GPCMD_SET_STREAMING:
+    case GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
+        /* we don't allow locking, to prevent a VM from hogging the drive */
+        PT_LOG("ignoring (%s)", atapi_cmd_to_str(cmd_code));
+        ide_atapi_cmd_ok(s);
+        return;
+    case GPCMD_FLUSH_CACHE:
+        /* bigger timeout while flushing write cache */
+        as->timeout = 1000 * 60;
+        break;
+    case GPCMD_SEND_OPC:
+        /* bigger timeout while sending OPC */
+        as->timeout = 1000 * 60;
+        break;
+    case GPCMD_FORMAT_UNIT:
+        /* bigger timeout while formatting if Immed bit not set */
+        if ((s->io_buffer[1] & 2) == 0) {
+            as->timeout = 1000 * 60 * 20;
+        }
+        /* If Format Code == 7 the drive expects 4 more bytes.
+         * Not sure which spec that's defined in, the ATAPI spec
+         * requires it to be 1. */
+        if ((as->request[1] & 7) != 1) {
+            as->dout_xfer_len += 4;
+        }
+        break;
+    case GPCMD_BLANK:
+        /* 80 mins timeout while blanking */
+        as->timeout = 1000 * 60 * 80;
+        break;
+    case GPCMD_CLOSE_TRACK:
+        /* 5 mins timeout */
+        as->timeout = 1000 * 60 * 5;
+        break;
+    case GPCMD_WRITE_BUFFER:
+        if ((s->io_buffer[1] & 7) != 0 &&    /* Combined header and data mode */
+            (s->io_buffer[1] & 7) != 2) {    /* Data mode */
+            atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                               ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+            PT_LOG("illegal request (%s): invalid field in command packet\n",
+                   atapi_cmd_to_str(cmd_code));
+            return;
+        }
+        break;
+    case GPCMD_WRITE_10:
+        /* bigger timout while writing */
+        as->timeout = 1000 * 60;
+        break;
+    case GPCMD_READ_CD:
+        /* We read blocks, not bytes */
+        block_size = atapi_pt_read_cd_block_size(s->io_buffer);
+        if (block_size < 0) {
+            atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                               ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+            PT_LOG("illegal request (%s): read a not handled field\n",
+                   atapi_cmd_to_str(cmd_code));
+            return;
+        }
+        as->din_xfer_len *= block_size;
+        break;
+    case GPCMD_READ_CD_MSF:
+        {
+            /* command fields */
+            int starting_frame =
+                MSF_TO_FRAMES(s->io_buffer[3], s->io_buffer[4],
+                      s->io_buffer[5]);
+            int ending_frame =
+                MSF_TO_FRAMES(s->io_buffer[6], s->io_buffer[7],
+                      s->io_buffer[8]);
+            int block_count = ending_frame - starting_frame;
+
+            block_size = atapi_pt_read_cd_block_size(s->io_buffer);
+            if (block_size < 0) {
+                atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+                PT_LOG("illegal request (%s): read a not handled frame field\n",
+                       atapi_cmd_to_str(cmd_code));
+                return;
+            }
+            as->din_xfer_len = block_count * block_size;
+            break;
+        }
+
+    case GPCMD_PLAY_AUDIO_MSF:
+        {
+            int starting_frame = MSF_TO_FRAMES(s->io_buffer[3], s->io_buffer[4],
+                                               s->io_buffer[5]);
+            int ending_frame = MSF_TO_FRAMES(s->io_buffer[6], s->io_buffer[7],
+                                             s->io_buffer[8]);
+            int block_count = ending_frame - starting_frame;
+            as->din_xfer_len = block_count * CD_FRAMESIZE;
+            break;
+        }
+
+    case GPCMD_GET_PERFORMANCE:
+        /* din_xfer_len is currently the max number of descriptors */
+        switch (s->io_buffer[10])
+        {
+            case 0:    // performance
+                if ((s->io_buffer[1] & 3) == 0) {
+                    /* nominal performance, 16 byte descriptors */
+                    as->din_xfer_len *= 16;
+                } else {
+                    /* exceptions, 6 byte descriptors */
+                    as->din_xfer_len *= 6;
+                }
+                break;
+            case 1:                          // unusable area
+                /* 8 byte descriptors */
+                as->din_xfer_len *= 8;
+                break;
+            case 2:                          // defect status
+                /* 2048 byte descriptors */
+                as->din_xfer_len *= 2048;
+                break;
+            case 3:                          // write speed
+                /* 16 byte descriptors */
+                as->din_xfer_len *= 16;
+                break;
+            case 4:                          // DBI data
+                /* 8 byte descriptors */
+                as->din_xfer_len *= 8;
+                break;
+            default:
+                atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+                PT_LOG("illegal request (%s): bad field in command packet",
+                       atapi_cmd_to_str(cmd_code));
+                return;
+        }
+        /* 8 bytes of header */
+        as->din_xfer_len += 8;
+        break;
+    case GPCMD_LOAD_UNLOAD:
+        break;
+    default:
+        break;
+    }
+
+    /* clear sense data */
+    memset(&as->sense, 0, sizeof(as->sense));
+
+    if (as->dout_xfer_len == (__u32) -1) {
+        atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                           ASC_ILLEGAL_OPCODE, 0, 0x70);
+        PT_LOG("illegal request (%s): illegal opcode (dout_xfer_len == -1)\n",
+               atapi_cmd_to_str(cmd_code));
+        return;
+    }
+
+    if (as->dout_xfer_len > 0) {
+        /* dout data is required, get it from somewhere */
+        atapi_pt_wcmd(s);
+        return;
+    }
+
+    atapi_pt_do_sg_io(s);
+}
--- a/hw/ide/core.c
+++ b/hw/ide/core.c
@@ -1730,7 +1730,11 @@ static bool cmd_packet(IDEState *s, uint
     }
     s->nsector = 1;
     ide_transfer_start(s, s->io_buffer, ATAPI_PACKET_SIZE,
+#ifdef CONFIG_ATAPI_PT
+                       s->atapi_pt ? atapi_pt_cmd : ide_atapi_cmd);
+#else
                        ide_atapi_cmd);
+#endif
     return false;
 }
 
@@ -2286,7 +2290,12 @@ void ide_cmd_write(void *opaque, uint32_
 static bool ide_is_pio_out(IDEState *s)
 {
     if (s->end_transfer_func == ide_sector_write ||
-        s->end_transfer_func == ide_atapi_cmd) {
+        s->end_transfer_func == ide_atapi_cmd
+#ifdef CONFIG_ATAPI_PT
+        || s->end_transfer_func == atapi_pt_cmd ||
+           s->end_transfer_func == atapi_pt_dout_fetch_pio_done
+#endif
+        ) {
         return false;
     } else if (s->end_transfer_func == ide_sector_read ||
                s->end_transfer_func == ide_transfer_stop ||
@@ -2499,6 +2508,12 @@ int ide_init_drive(IDEState *s, BlockBac
     uint64_t nb_sectors;
 
     s->blk = blk;
+#ifdef CONFIG_ATAPI_PT
+    if (kind == IDE_CD_PT) {
+        kind = IDE_CD;
+        s->atapi_pt = true;
+    }
+#endif
     s->drive_kind = kind;
 
     blk_get_geometry(blk, &nb_sectors);
@@ -2541,7 +2556,19 @@ int ide_init_drive(IDEState *s, BlockBac
     } else {
         switch (kind) {
         case IDE_CD:
-            strcpy(s->drive_model_str, "QEMU DVD-ROM");
+#ifdef CONFIG_ATAPI_PT
+            if (s->atapi_pt) {
+                strcpy(s->drive_model_str, "QEMU DVD PT");
+                if (0 != atapi_pt_init(s)) {
+                    error_report("Can't use a direst Pass Through drive");
+                    return -1;
+                }
+            } else {
+#endif
+                strcpy(s->drive_model_str, "QEMU DVD-ROM");
+#ifdef CONFIG_ATAPI_PT
+            }
+#endif
             break;
         case IDE_CFATA:
             strcpy(s->drive_model_str, "QEMU MICRODRIVE");
@@ -2573,8 +2600,15 @@ static void ide_init1(IDEBus *bus, int u
     s->drive_serial = drive_serial++;
     /* we need at least 2k alignment for accessing CDROMs using O_DIRECT */
     s->io_buffer_total_len = IDE_DMA_BUF_SECTORS*512 + 4;
+
+#ifdef CONFIG_ATAPI_PT
+    /* TODO: why double the buffer size?? */
+    s->io_buffer = qemu_memalign(2048, s->io_buffer_total_len * 2);
+    memset(s->io_buffer, 0, s->io_buffer_total_len * 2);
+#else
     s->io_buffer = qemu_memalign(2048, s->io_buffer_total_len);
     memset(s->io_buffer, 0, s->io_buffer_total_len);
+#endif
 
     s->smart_selftest_data = blk_blockalign(s->blk, 512);
     memset(s->smart_selftest_data, 0, 512);
@@ -2748,6 +2782,10 @@ static EndTransferFunc* transfer_end_tab
         ide_atapi_cmd_reply_end,
         ide_atapi_cmd,
         ide_dummy_transfer_stop,
+#ifdef CONFIG_ATAPI_PT
+        atapi_pt_cmd,
+        atapi_pt_dout_fetch_pio_done,
+#endif
 };
 
 static int transfer_end_table_idx(EndTransferFunc *fn)
--- a/hw/ide/pci.c
+++ b/hw/ide/pci.c
@@ -229,6 +229,16 @@ void bmdma_cmd_writeb(BMDMAState *bm, ui
     /* Ignore writes to SSBM if it keeps the old value */
     if ((val & BM_CMD_START) != (bm->cmd & BM_CMD_START)) {
         if (!(val & BM_CMD_START)) {
+
+            /*
+             * ATAPI PT: This whole function changed quite a bit
+             * and the original patch here seemed unsure of itself so
+             * leaving the patch stubbed our for now.
+             */
+#ifdef CONFIG_ATAPI_PT
+            /* TODO: Why? Are we sure this is safe? */
+            bmdma_cancel(bm);
+#endif
             ide_cancel_dma_sync(idebus_active_if(bm->bus));
             bm->status &= ~BM_STATUS_DMAING;
         } else {
--- a/hw/ide/qdev.c
+++ b/hw/ide/qdev.c
@@ -122,7 +122,19 @@ IDEDevice *ide_create_drive(IDEBus *bus,
 {
     DeviceState *dev;
 
-    dev = qdev_create(&bus->qbus, drive->media_cd ? "ide-cd" : "ide-hd");
+#ifdef CONFIG_ATAPI_PT
+    /*
+     * TODO this logic seems incorrect. It seems we should test whether it is
+     * media_cd first and only in that case create the ide-cd-pt device.
+     */
+    if (drive->atapi_pt) {
+        dev = qdev_create(&bus->qbus, "ide-cd-pt");
+    } else {
+#endif
+        dev = qdev_create(&bus->qbus, drive->media_cd ? "ide-cd" : "ide-hd");
+#ifdef CONFIG_ATAPI_PT
+    }
+#endif
     qdev_prop_set_uint32(dev, "unit", unit);
     qdev_prop_set_drive(dev, "drive", blk_by_legacy_dinfo(drive),
                         &error_fatal);
@@ -344,6 +356,35 @@ static const TypeInfo ide_cd_info = {
     .class_init    = ide_cd_class_init,
 };
 
+#ifdef CONFIG_ATAPI_PT
+static void ide_cd_pt_realize(IDEDevice *dev, Error **errp)
+{
+    ide_dev_initfn(dev, IDE_CD_PT, errp);
+}
+
+static Property ide_cd_pt_properties[] = {
+    DEFINE_IDE_DEV_PROPERTIES(),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void ide_cd_pt_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    IDEDeviceClass *k = IDE_DEVICE_CLASS(klass);
+    k->realize = ide_cd_pt_realize;
+    dc->fw_name = "drive";
+    dc->desc = "virtual IDE CD-ROM";
+    dc->props = ide_cd_pt_properties;
+}
+
+static const TypeInfo ide_cd_pt_info = {
+    .name          = "ide-cd-pt",
+    .parent        = TYPE_IDE_DEVICE,
+    .instance_size = sizeof(IDEDrive),
+    .class_init    = ide_cd_pt_class_init,
+};
+#endif /* CONFIG_ATAPI_PT */
+
 static Property ide_drive_properties[] = {
     DEFINE_IDE_DEV_PROPERTIES(),
     DEFINE_PROP_END_OF_LIST(),
@@ -393,6 +434,9 @@ static void ide_register_types(void)
     type_register_static(&ide_cd_info);
     type_register_static(&ide_drive_info);
     type_register_static(&ide_device_type_info);
+#ifdef CONFIG_ATAPI_PT
+    type_register_static(&ide_cd_pt_info);
+#endif
 }
 
 type_init(ide_register_types)
--- /dev/null
+++ b/include/block/atapi_pt_ioctl.h
@@ -0,0 +1,37 @@
+/*
+ *
+ * Copyright (C) 2015 Assured Information Security, Chris Patterson <pattersonc@ainfosec.com>
+ * Copyright (C) 2014 Citrix Systems Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _ATAPI_PT_IOCTL_H_
+#define _ATAPI_PT_IOCTL_H_
+
+typedef enum {
+    ATAPI_PT_OPEN                        = 0x00,
+    ATAPI_PT_SG_IO                       = 0x01,
+    ATAPI_PT_SG_GET_RESERVED_SIZE        = 0x02,
+    ATAPI_PT_ACQUIRE_LOCK                = 0x03,
+    ATAPI_PT_RELEASE_LOCK                = 0x04,
+    ATAPI_PT_GET_GLOB_MEDIA_STATE        = 0x05,
+    ATAPI_PT_SET_GLOB_MEDIA_STATE        = 0x06,
+} atapi_pt_ioctl_cmd_t;
+
+void atapi_pt_notify_medium_maybe_changed(void *opaque);
+void atapi_pt_notify_medium_ejected(void *opaque);
+
+#endif /* !_ATAPI_PT_IOCTL_H_ */
--- /dev/null
+++ b/include/block/atapi_pt_argo.h
@@ -0,0 +1,93 @@
+/*
+ *
+ * Copyright (C) 2015 Assured Information Security, Chris Patterson <pattersonc@ainfosec.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _ATAPI_PT_ARGO_H_
+#define _ATAPI_PT_ARGO_H_
+
+typedef enum {
+    ATAPI_PT_LOCK_STATE_UNLOCKED         = 0x00,
+    ATAPI_PT_LOCK_STATE_LOCKED_BY_ME     = 0x01,
+    ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER  = 0x02,
+} atapi_pt_lock_state_t;
+
+typedef enum {
+    ATAPI_PTARGO_OPEN                     = 0x00,
+    ATAPI_PTARGO_SG_IO                    = 0x01,
+    ATAPI_PTARGO_SG_GET_RESERVED_SIZE     = 0x02,
+    ATAPI_PTARGO_ACQUIRE_LOCK             = 0x03,
+    ATAPI_PTARGO_RELEASE_LOCK             = 0x04,
+} atapi_ptargo_cmd_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_OPEN */
+    uint8_t device_id;
+    char device_path[256];
+} __attribute__((packed)) pt_argocmd_open_request_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_OPEN */
+    uint8_t device_id;
+} __attribute__((packed)) pt_argocmd_open_response_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_ACQUIRE_LOCK */
+    uint8_t device_id;
+} __attribute__((packed)) pt_argocmd_acquire_lock_request_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_ACQUIRE_LOCK */
+    uint8_t device_id;
+    uint8_t lock_state; /* atapi_pt_lock_state_t */
+} __attribute__((packed)) pt_argocmd_acquire_lock_response_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_RELEASE_LOCK */
+    uint8_t device_id;
+} __attribute__((packed)) pt_argocmd_release_lock_request_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_SG_GET_RESERVED_SIZE */
+    uint8_t device_id;
+} __attribute__((packed)) pt_argocmd_sg_get_reserved_size_request_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_SG_GET_RESERVED_SIZE */
+    uint8_t device_id;
+    uint32_t size;
+} __attribute__((packed)) pt_argocmd_sg_get_reserved_size_response_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_SG_IO */
+    uint8_t device_id;
+    struct sg_io_v4 sgio;
+    uint8_t request_data[12]; /* ATAPI_PACKET_SIZE */
+    uint32_t dout_data_len;
+    uint8_t dout_data[];
+} __attribute__((packed)) pt_argocmd_sg_io_request_t;
+
+typedef struct {
+    uint8_t cmd; /* ATAPI_PTARGO_SG_IO */
+    uint8_t device_id;
+    struct sg_io_v4 sgio;
+    uint8_t sense_data[64]; /* struct request_sense */
+    uint32_t din_data_len;
+    uint8_t din_data[];
+} __attribute__((packed)) pt_argocmd_sg_io_response_t;
+
+#endif /* !_ATAPI_PT_ARGO_H_ */
--- a/include/block/block.h
+++ b/include/block/block.h
@@ -397,6 +397,9 @@ void bdrv_aio_cancel_async(BlockAIOCB *a
 /* sg packet commands */
 int bdrv_co_ioctl(BlockDriverState *bs, int req, void *buf);
 
+/* OpenXT: direct IOCTL delivery */
+int bdrv_direct_ioctl(BlockDriverState *bs, unsigned long int req, void *buf);
+
 /* Invalidate any cached metadata used by image formats */
 void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp);
 void bdrv_invalidate_cache_all(Error **errp);
--- a/include/block/block_int.h
+++ b/include/block/block_int.h
@@ -343,6 +343,10 @@ struct BlockDriver {
     int coroutine_fn (*bdrv_co_ioctl)(BlockDriverState *bs,
                                       unsigned long int req, void *buf);
 
+    /* OpenXT: direct IOCTL delivery */
+    int (*bdrv_direct_ioctl)(BlockDriverState *bs, unsigned long int req,
+        void *buf);
+
     /* List of options for creating images, terminated by name == NULL */
     QemuOptsList *create_opts;
 
--- /dev/null
+++ b/include/hw/atapi_pt.h
@@ -0,0 +1,153 @@
+/*
+ * ATAPI guest commands translation.
+ *
+ * Copyright (C) 2014 Citrix Systems Ltd
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef ATAPI_PT_H_
+# define ATAPI_PT_H_
+
+/* Use for sense comand and CDROM management */
+# include <linux/cdrom.h>
+# include <linux/bsg.h>
+/* useful for thread management... (TODO: push it in the Block Driver */
+# include <pthread.h>
+/* use IOCTL to send for communication between the main processus and the
+ * block driver socketpair */
+# include <linux/ioctl.h>
+/* use for socketpair */
+# include <sys/types.h>
+# include <sys/socket.h>
+/* Qemu EventNotifier
+ * TODO: Remove socketpair */
+# include "qemu/event_notifier.h"
+
+/* The generic packet command opcodes for CD/DVD Logical Units,
+ * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
+# define GPCMD_BLANK                              0xa1
+# define GPCMD_CLOSE_TRACK                        0x5b
+# define GPCMD_FLUSH_CACHE                        0x35
+# define GPCMD_FORMAT_UNIT                        0x04
+# define GPCMD_GET_CONFIGURATION                  0x46
+# define GPCMD_GET_EVENT_STATUS_NOTIFICATION      0x4a
+# define GPCMD_GET_PERFORMANCE                    0xac
+# define GPCMD_INQUIRY                            0x12
+# define GPCMD_LOAD_UNLOAD                        0xa6
+# define GPCMD_MECHANISM_STATUS                   0xbd
+# define GPCMD_MODE_SELECT_10                     0x55
+# define GPCMD_MODE_SENSE_10                      0x5a
+# define GPCMD_PAUSE_RESUME                       0x4b
+# define GPCMD_PLAY_AUDIO_10                      0x45
+# define GPCMD_PLAY_AUDIO_MSF                     0x47
+# define GPCMD_PLAY_AUDIO_TI                      0x48
+# define GPCMD_PLAY_CD                            0xbc
+# define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL       0x1e
+# define GPCMD_READ_10                            0x28
+# define GPCMD_READ_12                            0xa8
+# define GPCMD_READ_BUFFER                        0x3c
+# define GPCMD_READ_BUFFER_CAPACITY               0x5c
+# define GPCMD_READ_CDVD_CAPACITY                 0x25
+# define GPCMD_READ_CD                            0xbe
+# define GPCMD_READ_CD_MSF                        0xb9
+# define GPCMD_READ_DISC_INFO                     0x51
+# define GPCMD_READ_DVD_STRUCTURE                 0xad
+# define GPCMD_READ_FORMAT_CAPACITIES             0x23
+# define GPCMD_READ_HEADER                        0x44
+# define GPCMD_READ_TRACK_RZONE_INFO              0x52
+# define GPCMD_READ_SUBCHANNEL                    0x42
+# define GPCMD_READ_TOC_PMA_ATIP                  0x43
+# define GPCMD_REPAIR_RZONE_TRACK                 0x58
+# define GPCMD_REPORT_KEY                         0xa4
+# define GPCMD_REQUEST_SENSE                      0x03
+# define GPCMD_RESERVE_RZONE_TRACK                0x53
+# define GPCMD_SEND_CUE_SHEET                     0x5d
+# define GPCMD_SCAN                               0xba
+# define GPCMD_SEEK                               0x2b
+# define GPCMD_SEND_DVD_STRUCTURE                 0xbf
+# define GPCMD_SEND_EVENT                         0xa2
+# define GPCMD_SEND_KEY                           0xa3
+# define GPCMD_SEND_OPC                           0x54
+# define GPCMD_SET_READ_AHEAD                     0xa7
+# define GPCMD_SET_SPEED                          0xbb
+# define GPCMD_SET_STREAMING                      0xb6
+# define GPCMD_START_STOP_UNIT                    0x1b
+# define GPCMD_STOP_PLAY_SCAN                     0x4e
+# define GPCMD_TEST_UNIT_READY                    0x00
+# define GPCMD_VERIFY_10                          0x2f
+# define GPCMD_WRITE_10                           0x2a
+# define GPCMD_WRITE_12                           0xaa
+# define GPCMD_WRITE_AND_VERIFY_10                0x2e
+# define GPCMD_WRITE_BUFFER                       0x3b
+
+/* Sense keys */
+#define SENSE_NONE              0
+#define SENSE_RECOVERED_ERROR   1
+#define SENSE_NOT_READY         2
+#define SENSE_MEDIUM_ERROR      3
+#define SENSE_HARDWARE_ERROR    4
+#define SENSE_ILLEGAL_REQUEST   5
+#define SENSE_UNIT_ATTENTION    6
+#define SENSE_DATA_PROTECT      7
+#define SENSE_BLANK_CHECK       8
+#define SENSE_VENDOR_SPECIFIC   9
+#define SENSE_COPY_ABORTED     10
+#define SENSE_ABORTED_COMMAND  11
+#define SENSE_VOLUME_OVERFLOW  13
+#define SENSE_MISCOMPARE       14
+
+/* same constants as bochs */
+#define ASC_NONE                             0x00
+#define ASC_READ_ERROR                       0x11
+#define ASC_ILLEGAL_OPCODE                   0x20
+#define ASC_LOGICAL_BLOCK_OOR                0x21
+#define ASC_INV_FIELD_IN_CMD_PACKET          0x24
+#define ASC_MEDIUM_MAY_HAVE_CHANGED          0x28
+#define ASC_INCOMPATIBLE_FORMAT              0x30
+#define ASC_MEDIUM_NOT_PRESENT               0x3a
+#define ASC_SAVING_PARAMETERS_NOT_SUPPORTED  0x39
+
+typedef struct ATAPIPassThroughState {
+    /* The ATAPI packet request */
+    struct request_sense sense;
+    /* Maximum transfert length */
+    uint32_t             max_xfer_len;
+
+    uint8_t              request[ATAPI_PACKET_SIZE];
+    uint32_t             dout_xfer_len;
+    uint32_t             din_xfer_len;
+    uint32_t             timeout;
+    uint32_t             result;
+    /* Thread communication */
+    QemuThread           thread;
+    bool                 thread_continue;
+    /* Use sgio_worker_fd ou sgio_dispatch_fd to get the needed file
+     * descriptor */
+    EventNotifier        e_cmd;
+    EventNotifier        e_ret;
+
+    /* flag to enable/disable disc notifications (guest is ready) */
+    bool allow_notifications;
+    bool notify_eject_requested;
+    bool notify_media_removed;
+    bool notify_new_media;
+} ATAPIPassThroughState;
+
+int32_t atapi_pt_init(IDEState *s);
+void atapi_pt_cmd(IDEState *s);
+void atapi_pt_dout_fetch_pio_done(IDEState *s);
+
+#endif /* !ATAPI_PT_H_ */
--- a/include/hw/ide/internal.h
+++ b/include/hw/ide/internal.h
@@ -314,7 +314,14 @@ typedef struct IDEDMAOps IDEDMAOps;
 #define SMART_DISABLE         0xd9
 #define SMART_STATUS          0xda
 
-typedef enum { IDE_HD, IDE_CD, IDE_CFATA } IDEDriveKind;
+typedef enum {
+    IDE_HD,
+    IDE_CD,
+    IDE_CFATA,
+#ifdef CONFIG_ATAPI_PT
+    IDE_CD_PT,
+#endif
+} IDEDriveKind;
 
 typedef void EndTransferFunc(IDEState *);
 
@@ -344,6 +351,10 @@ extern const char *IDE_DMA_CMD_lookup[ID
 #define ide_cmd_is_read(s) \
 	((s)->dma_cmd == IDE_DMA_READ)
 
+#ifdef CONFIG_ATAPI_PT
+#include "hw/atapi_pt.h"
+#endif
+
 typedef struct IDEBufferedRequest {
     QLIST_ENTRY(IDEBufferedRequest) list;
     struct iovec iov;
@@ -397,6 +408,10 @@ struct IDEState {
     bool tray_open;
     bool tray_locked;
     uint8_t cdrom_changed;
+#ifdef CONFIG_ATAPI_PT
+    bool atapi_pt;
+    ATAPIPassThroughState *atapipts;
+#endif
     int packet_transfer_size;
     int elementary_transfer_size;
     int32_t io_buffer_index;
@@ -599,6 +614,9 @@ void ide_atapi_cmd_ok(IDEState *s);
 void ide_atapi_cmd_error(IDEState *s, int sense_key, int asc);
 void ide_atapi_dma_restart(IDEState *s);
 void ide_atapi_io_error(IDEState *s, int ret);
+#ifdef CONFIG_ATAPI_PT
+void ide_atapi_cmd_reply(IDEState *s, int size, int max_size);
+#endif
 
 void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val);
 uint32_t ide_ioport_read(void *opaque, uint32_t addr1);
--- a/include/qemu/event_notifier.h
+++ b/include/qemu/event_notifier.h
@@ -26,6 +26,10 @@ struct EventNotifier {
     int rfd;
     int wfd;
 #endif
+
+#ifdef CONFIG_ATAPI_PT
+    void *opaque;
+#endif
 };
 
 typedef void EventNotifierHandler(EventNotifier *);
@@ -38,6 +42,9 @@ int event_notifier_test_and_clear(EventN
 #ifdef CONFIG_POSIX
 void event_notifier_init_fd(EventNotifier *, int fd);
 int event_notifier_get_fd(const EventNotifier *);
+#ifdef CONFIG_ATAPI_PT
+int event_notifier_wait_and_clear(EventNotifier *e, long second);
+#endif
 #else
 HANDLE event_notifier_get_handle(EventNotifier *);
 #endif
--- a/include/sysemu/blockdev.h
+++ b/include/sysemu/blockdev.h
@@ -24,6 +24,9 @@ typedef enum {
      */
     IF_NONE = 0,
     IF_IDE, IF_SCSI, IF_FLOPPY, IF_PFLASH, IF_MTD, IF_SD, IF_VIRTIO, IF_XEN,
+#ifdef CONFIG_ATAPI_PT
+    IF_ATAPI_PT,
+#endif
     IF_COUNT
 } BlockInterfaceType;
 
@@ -36,6 +39,9 @@ struct DriveInfo {
     int media_cd;
     QemuOpts *opts;
     QTAILQ_ENTRY(DriveInfo) next;
+#ifdef CONFIG_ATAPI_PT
+    bool atapi_pt;
+#endif
 };
 
 DriveInfo *blk_legacy_dinfo(BlockBackend *blk);
--- a/util/event_notifier-posix.c
+++ b/util/event_notifier-posix.c
@@ -122,3 +122,41 @@ int event_notifier_test_and_clear(EventN
 
     return value;
 }
+
+#ifdef CONFIG_ATAPI_PT
+int event_notifier_wait_and_clear(EventNotifier *e, long second)
+{
+    fd_set rfds;
+    int value;
+    struct timeval tv;
+    struct timeval *tvp;
+
+    if (second != 0) {
+        tv.tv_sec = second;
+        tv.tv_usec = 0;
+        tvp = &tv;
+    } else {
+        tvp = NULL;
+    }
+
+    FD_ZERO(&rfds);
+    FD_SET(e->rfd, &rfds);
+
+    value = select(e->rfd + 1, &rfds, NULL, NULL, tvp);
+
+    switch (value) {
+    case -1:
+        value = -errno;
+        break;
+    case 1:
+        event_notifier_test_and_clear(e);
+        break;
+    case 0:
+    default:
+        value = 0;
+        break;
+    }
+
+    return value;
+}
+#endif
