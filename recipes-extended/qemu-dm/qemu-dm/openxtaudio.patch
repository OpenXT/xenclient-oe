================================================================================
SHORT DESCRIPTION:
================================================================================
Enables QEMU Emulated Audio Stubdomain Support

================================================================================
LONG DESCRIPTION:
================================================================================
The ALSA code the QEMU provides has no way of communicating the audio
information from one VM to another. To provide emulated audio support in
a stubdomain, this patch forwards all of the QEMU information to an audio
helper.

Previous versions of this patch implemented the ALSA API in QEMU, and then
forwarded the ALSA APIs over v4v. The problems with this approach is there
are a lot of ALSA APIs that must be called, resulting in unneeded context
switching when collecting / delivering samples. This patch instead forwards
the QEMU API to the audio helper, simplifiying the overall approach, and
improving performance.

In the future, this patch should be removed in favor of true PV Audio
support. Until then, this patch will need to be ported as we uprev
QEMU.

================================================================================
CHANGELOG
================================================================================
Intial Commit: Rian Quinn, quinnr@ainfosec.com, 4/8/2015
Ported to QEMU 2.6.2: Ross Philipson, philipsonr@ainfosec.com, 10/13/2016
Port to QEMU 2.12: Jason Andryuk, jandryuk@gmail.com, 6/19/2018
  CONFIG option must be prefixed CONFIG_AUDIO_
  name must be openxt to be found in driver search

================================================================================
REMOVAL
================================================================================
This patch can be removed from QEMU once full PV audio support is provided
in openxt.

================================================================================
UPSTREAM PLAN
================================================================================
There is no plan to upstream this code. It is openxt specific

================================================================================
INTERNAL DEPENDENCIES
================================================================================
None

================================================================================
PATCHES
================================================================================
=======
--- a/audio/Makefile.objs
+++ b/audio/Makefile.objs
@@ -4,6 +4,8 @@ common-obj-$(CONFIG_AUDIO_COREAUDIO) +=
 common-obj-$(CONFIG_AUDIO_DSOUND) += dsoundaudio.o
 common-obj-$(CONFIG_AUDIO_PT_INT) += audio_pt_int.o
 common-obj-$(CONFIG_AUDIO_WIN_INT) += audio_win_int.o
+common-obj-$(CONFIG_AUDIO_OPENXT) += alsadef.o openxtv4v.o
+common-obj-$(CONFIG_AUDIO_OPENXT) += openxtdebug.o openxtaudio.o
 common-obj-y += wavcapture.o
 
 coreaudio.o-libs := $(COREAUDIO_LIBS)
--- /dev/null
+++ b/audio/alsadef.c
@@ -0,0 +1,151 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "audio.h"
+#include "qemu/timer.h"
+#include "alsadef.h"
+
+///
+/// Convert QEMU audio settings to ALSA audio settings
+///
+/// @param fmt the QEMU audio format
+/// @param endianness the QEMU audio endianness
+///
+/// @return the ALSA equivalent audio format
+///
+snd_pcm_format_t aud_to_alsafmt(audfmt_e fmt, int endianness)
+{
+    switch (fmt) {
+        case AUD_FMT_S8:
+            return SND_PCM_FORMAT_S8;
+
+        case AUD_FMT_U8:
+            return SND_PCM_FORMAT_U8;
+
+        case AUD_FMT_S16:
+            if (endianness) {
+                return SND_PCM_FORMAT_S16_BE;
+            }
+            else {
+                return SND_PCM_FORMAT_S16_LE;
+            }
+
+        case AUD_FMT_U16:
+            if (endianness) {
+                return SND_PCM_FORMAT_U16_BE;
+            }
+            else {
+                return SND_PCM_FORMAT_U16_LE;
+            }
+
+        case AUD_FMT_S32:
+            if (endianness) {
+                return SND_PCM_FORMAT_S32_BE;
+            }
+            else {
+                return SND_PCM_FORMAT_S32_LE;
+            }
+
+        case AUD_FMT_U32:
+            if (endianness) {
+                return SND_PCM_FORMAT_U32_BE;
+            }
+            else {
+                return SND_PCM_FORMAT_U32_LE;
+            }
+
+        default:
+            return SND_PCM_FORMAT_U8;
+    }
+}
+
+///
+/// Convert ALSA audio format to QEMU audio format
+///
+/// @param alsafmt the ALSA audio format
+/// @param fmt place to store the QEMU audio format equivalent
+/// @param endianness place to store the QEMU audio endianness equivalent
+///
+/// @return -1 on error
+///         0 on success
+///
+int alsa_to_audfmt(snd_pcm_format_t alsafmt, audfmt_e *fmt, int *endianness)
+{
+    switch (alsafmt) {
+        case SND_PCM_FORMAT_S8:
+            *endianness = 0;
+            *fmt = AUD_FMT_S8;
+            break;
+
+        case SND_PCM_FORMAT_U8:
+            *endianness = 0;
+            *fmt = AUD_FMT_U8;
+            break;
+
+        case SND_PCM_FORMAT_S16_LE:
+            *endianness = 0;
+            *fmt = AUD_FMT_S16;
+            break;
+
+        case SND_PCM_FORMAT_U16_LE:
+            *endianness = 0;
+            *fmt = AUD_FMT_U16;
+            break;
+
+        case SND_PCM_FORMAT_S16_BE:
+            *endianness = 1;
+            *fmt = AUD_FMT_S16;
+            break;
+
+        case SND_PCM_FORMAT_U16_BE:
+            *endianness = 1;
+            *fmt = AUD_FMT_U16;
+            break;
+
+        case SND_PCM_FORMAT_S32_LE:
+            *endianness = 0;
+            *fmt = AUD_FMT_S32;
+            break;
+
+        case SND_PCM_FORMAT_U32_LE:
+            *endianness = 0;
+            *fmt = AUD_FMT_U32;
+            break;
+
+        case SND_PCM_FORMAT_S32_BE:
+            *endianness = 1;
+            *fmt = AUD_FMT_S32;
+            break;
+
+        case SND_PCM_FORMAT_U32_BE:
+            *endianness = 1;
+            *fmt = AUD_FMT_U32;
+            break;
+
+        default:
+            return -1;
+    }
+
+    return 0;
+}
--- /dev/null
+++ b/audio/alsadef.h
@@ -0,0 +1,35 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#ifndef ALSADEF_H
+#define ALSADEF_H
+
+// QEMU Libraries
+
+// ALSA Libraries
+#include <alsa/asoundlib.h>
+
+// Conversion Functions
+snd_pcm_format_t aud_to_alsafmt(audfmt_e fmt, int endianness);
+int alsa_to_audfmt(snd_pcm_format_t alsafmt, audfmt_e *fmt, int *endianness);
+
+#endif // ALSADEF_H
--- /dev/null
+++ b/audio/openxtaudio.c
@@ -0,0 +1,743 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "audio.h"
+#include "qemu/timer.h"
+
+#define AUDIO_CAP "openxtaudio"
+#include "audio_int.h"
+
+#include "alsadef.h"
+#include "openxtv4v.h"
+#include "openxtdebug.h"
+#include "openxtpackets.h"
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Macros                                                                                              //
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// The following defines the sample buffer that QEMU will use. If there is
+// problems with buffering, increasing this value might help, but it might
+// also increase latency.
+#define MAX_SAMPLES 1024
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Opaque Structures                                                                                   //
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// Opaque out pointer
+typedef struct OpenXTOut {
+    HWVoiceOut hw;
+
+} OpenXTOut;
+
+// Opaque in pointer
+typedef struct OpenXTIn {
+    HWVoiceIn hw;
+
+} OpenXTIn;
+
+bool playback_initialized = false;
+bool capture_initialized = false;
+
+// Global V4V Packets
+V4VPacket snd_packet;
+V4VPacket rcv_packet;
+
+// GLobal V4V Connection
+V4VConnection *conn = NULL;
+
+// Global V4V Packet Playback Bodies
+OpenXTPlaybackPacket *playback_packet = NULL;
+OpenXTPlaybackInitAckPacket *playback_init_ack_packet = NULL;
+OpenXTPlaybackSetVolumePacket *playback_set_volume_packet = NULL;
+OpenXTPlaybackGetAvailableAckPacket *playback_get_available_ack_packet = NULL;
+
+// Global V4V Packet Capture Bodies
+OpenXTCapturePacket *capture_packet = NULL;
+OpenXTCaptureAckPacket *capture_ack_packet = NULL;
+OpenXTCaptureInitAckPacket *capture_init_ack_packet = NULL;
+OpenXTCaptureGetAvailableAckPacket *capture_get_available_ack_packet = NULL;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Helpers                                                                                             //
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+///
+/// Send a blank packet with a specific opcode.
+///
+/// @desc This function should be used anytime you need to signal to the audio helper,
+/// but you don't actually have to send any information minus the opcode itself.
+///
+/// @param opcode the opcode that you wish to send. This can be any integer, but it should
+/// match what you have in the audio helper.
+///
+/// @return -ENODEV if V4V is not connected
+///         negative error code on error
+///         0 on success
+///
+static int openxt_send_blank_packet(int32_t opcode)
+{
+    int ret;
+
+    // Sanity checks
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, -ENODEV);
+
+    // Send the blank packet
+    ret = openxt_v4v_set_opcode(&snd_packet, opcode);
+    openxt_assert(ret == 0, ret);
+    ret = openxt_v4v_set_length(&snd_packet, sizeof(OpenBlankPacket));
+    openxt_assert(ret == 0, ret);
+    ret = openxt_v4v_send(conn, &snd_packet);
+    openxt_assert(ret == sizeof(OpenBlankPacket), ret);
+
+    // Success
+    return 0;
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Playback                                                                                            //
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+///
+/// Initializes the playback device. This is one of QEMU's required functions.
+///
+/// @param hw points to a structure that QEMU provides. You need to initialize
+/// this structure by running audio_pcm_init_info, and then setting the # of
+/// samples after words.
+/// @param as settings structure. Provide information about the audio device
+/// as QEMU would like it. When you initialize hw, you can change these settings
+/// to whatever you want.
+///
+/// @return -EINVAL if NULL is passed to the parameters
+///         -ENODEV if V4V is not connected or the audio helper fails
+///         negative error code on error
+///         0 on success
+///
+static int openxt_playback_init(HWVoiceOut *hw, struct audsettings *as,
+                                void *drv_opaque)
+{
+    int ret;
+    struct audsettings settings;
+
+    // Sanity checks
+    openxt_checkp(hw, -EINVAL);
+    openxt_checkp(as, -EINVAL);
+    openxt_assert_quiet(playback_initialized == false, -ENODEV);
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, -ENODEV);
+
+    // For whatever reason, QEMU will run this function once, or it can run it
+    // 1000 times if an error occurs. The result if the VM gets bogged down
+    // like mad. This code with the assert above just makes sure that this code
+    // can only execute once.... like it should be in the first place.
+    playback_initialized = true;
+
+    // Ask the audio helper for the settings that we should be using. Note that
+    // we do not get these from QEMU, but instead let the audio helper tell us
+    // what it wants to do, and then tell QEMU what that is, which is a little
+    // different then what you will see in the alsaaudio driver.
+    ret = openxt_send_blank_packet(OPENXT_PLAYBACK_INIT);
+    openxt_assert(ret == 0, ret);
+    ret = openxt_v4v_recv(conn, &rcv_packet);
+    openxt_assert(ret == sizeof(OpenXTPlaybackInitAckPacket), ret);
+
+    // Make sure that ALSA configured correctly
+    openxt_assert(playback_init_ack_packet->valid != 0, -ENODEV);
+
+    // Set the settings structure that QEMU is expecting with the results
+    // from the audio helper. Note that this requires some conversions as
+    // ALSA stores the endianness and format together, while QEMU keeps
+    // these apart.
+    settings.freq = playback_init_ack_packet->freq;
+    settings.nchannels = playback_init_ack_packet->nchannels;
+    alsa_to_audfmt(playback_init_ack_packet->fmt, &settings.fmt, &settings.endianness);
+
+    // Setup QEMU
+    audio_pcm_init_info(&hw->info, &settings);
+    hw->samples = 1024;
+
+    // Success
+    return 0;
+}
+
+///
+/// Finalizes the playback device. This is one of QEMU's required functions.
+///
+/// @param hw points to a structure that QEMU provides.
+///
+static void openxt_playback_fini(HWVoiceOut *hw)
+{
+    openxt_send_blank_packet(OPENXT_PLAYBACK_FINI);
+}
+
+///
+/// Processes the playback device. This is one of QEMU's required functions.
+///
+/// @param hw points to a structure that QEMU provides.
+/// @param live the total number of samples that are available. Attempts to
+/// read all of theses samples at once will fail with some strange issues.
+/// In general, you need a way to "rate" how many samples you decide to process
+/// (i.e. you simply cannot process all of the samples that "live" would suggest
+/// can be processed). Spice and the noaudio code do this by using a clock.
+/// The ALSA code does this by requesting how many samples the physical hardware
+/// can actually process, which seems to work a lot better.
+///
+/// @return the total number of samples that were processed.
+///
+static int openxt_playback(HWVoiceOut *hw, int live)
+{
+    int ret;
+    int decr;
+    int samples;
+
+    // Sanity checks
+    openxt_checkp(hw, 0);
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, 0);
+
+    // We need to find out how much space is available in ALSA so that we
+    // know how many samples to read.
+    ret = openxt_send_blank_packet(OPENXT_PLAYBACK_GET_AVAILABLE);
+    openxt_assert(ret == 0, 0);
+    ret = openxt_v4v_recv(conn, &rcv_packet);
+    openxt_assert(ret == sizeof(OpenXTPlaybackGetAvailableAckPacket), 0);
+
+    // The following figures out how many samples we "can" process in this
+    // iteration (as this function is called by a timer in QEMU). Basically,
+    // that total number of samples we can process is the lower value of either
+    // the total number of samples provided to the hardware (live), and the
+    // total number of samples that ALSA can currently take.
+    decr = audio_MIN(live, playback_get_available_ack_packet->available);
+
+    // Now that we know how many samples we can send to ALSA to process, we
+    // need to package these samples up into packets and send them to the
+    // helper. This loop has to do a couple of things, including making sure
+    // that we do not overrun the circular buffer that QEMU maintains, as well
+    // as the making sure that we do not overrun the packet itself, as it
+    // can only hold a limited number of samples.
+    for (samples = decr; samples > 0; )
+    {
+        int len = samples;
+
+        // Make sure that we are not overrunning the circular buffer that QEMU
+        // has, as well as make sure that we are not overrunning the packet
+        // buffer.
+        len = audio_MIN(len, hw->samples - hw->rpos);
+        len = audio_MIN(len, MAX_PCM_BUFFER_SIZE / sizeof(uint32_t));
+
+        // Setup the packet.
+        ret = openxt_v4v_set_opcode(&snd_packet, OPENXT_PLAYBACK);
+        openxt_assert(ret == 0, 0);
+        ret = openxt_v4v_set_length(&snd_packet, PLAYBACK_PACKET_LENGTH(len));
+        openxt_assert(ret == 0, 0);
+
+        // Fill in the packet's body. Note that the hw->clip function is
+        // basically a memcpy, the only difference is that len is in samples
+        // instead of bytes. The source is our packet, and it's unit is expected
+        // to be in 16 bit little endian with 2 channels, which means that
+        // each sample is 32 bits (size of a unit32_t). The destination is
+        // an array of st_samples which is 64 bits per channel, for a total
+        // of 16 bytes per samples. This function does the copy, and conversion
+        // for us.
+        playback_packet->num_samples = len;
+        hw->clip(playback_packet->samples, hw->mix_buf + hw->rpos, len);
+
+        // Send the packet to the helper.
+        ret = openxt_v4v_send(conn, &snd_packet);
+        openxt_assert(ret == PLAYBACK_PACKET_LENGTH(len), 0);
+
+        // We need to advance the internal pointers.
+        samples -= len;
+        hw->rpos = (hw->rpos + len) % hw->samples;
+    }
+
+    // Success
+    return decr;
+}
+
+///
+/// This is one of QEMU's required functions. All of the other drivers
+/// just pass this to QEMU's built in function. No idea what it actually
+/// does.
+///
+/// @param sw N/A
+/// @param buf N/A
+/// @param len N/A
+///
+/// @return N/A
+///
+static int openxt_write(SWVoiceOut *sw, void *buf, int len)
+{
+    return audio_pcm_sw_write(sw, buf, len);
+}
+
+///
+/// This function returns control information from QEMU.
+///
+/// @desc This is actually a really important function. Whenever the guest is
+/// about to start playing sound, it will first start the audio device, and
+/// once it is done, it will "close" the audio device. An easy way to
+/// see this is open Windows Media player, and play a song. Once you hit play
+/// you will see VOICE_ENABLE come through, and then when the song is done
+/// you will see VOICE_DISABLE. ALSA does this with "prepare" and "drop".
+/// The other thing that this does is volume control. The value that you get
+/// needs to be converted. Basically, QEMU will report a number between
+/// 0 and UINT_MAX. That allows you to calculate a linear percentage of what
+/// the volume should be. There are some quirks that took a while to work
+/// though:
+/// - Windows (AC97) never sets the volume to 100% within QEMU. It will
+///   always stop at 75%. The running theory is that Windows will not set
+///   the gain beyond the hardware's ability to raise the volume without
+///   distortion.
+/// - Linux alsamixer will not match this percentage. It appears that
+///   alsamixer uses the hardware's gain to create a fake logarithmic scale
+///   that doesn't match what you see in the hardware itself. Since the gain
+///   on the physical hardware will never match what the guest is reporting,
+///   alsamixer within the guest and dom0 will not match
+/// - Linux amixer will match between the guest and dom0, as well as the
+///   percentage that you see QEMU reporting. Amixer doesn't seem to be
+///   doing anything strange with the percentage, so everything matches up
+///   fine.
+/// - Windows (hda) never calls VOICE_VOLUME. It appears to be doing some
+///   sort of software volume mixing, which might explain why it doesn't work
+///   well, as that operation is pretty slow.
+///
+/// @param hw points to a structure that QEMU provides.
+/// @param cmd that command that QEMU is sending
+/// @param ... needs to be parsed based on the command. Look at the other
+/// drivers for examples.
+///
+/// @return -1 on not supported or error
+///         0 success / supported
+///
+static int openxt_playback_ctl(HWVoiceOut *hw, int cmd, ...)
+{
+    int ret;
+
+    // Sanity checks
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, -ENODEV);
+
+    // Process the command
+    switch(cmd) {
+
+        case VOICE_ENABLE:
+            ret = openxt_send_blank_packet(OPENXT_PLAYBACK_ENABLE_VOICE);
+            openxt_assert(ret == 0, -1);
+
+            // Success
+            return 0;
+
+        case VOICE_DISABLE:
+            ret = openxt_send_blank_packet(OPENXT_PLAYBACK_DISABLE_VOICE);
+            openxt_assert(ret == 0, -1);
+
+            // Success
+            return 0;
+
+        case VOICE_VOLUME:
+        {
+            va_list va;
+            SWVoiceOut *sw = NULL;
+
+            // Get the SWVoiceOut from the args
+            va_start(va, cmd);
+            sw = va_arg(va, SWVoiceOut*);
+            va_end(va);
+
+            // Make sure that we actually got an argument back.
+            if (sw != NULL) {
+
+                // Setup the packet
+                ret = openxt_v4v_set_opcode(&snd_packet, OPENXT_PLAYBACK_SET_VOLUME);
+                openxt_assert(ret == 0, -1);
+                ret = openxt_v4v_set_length(&snd_packet, sizeof(OpenXTPlaybackSetVolumePacket));
+                openxt_assert(ret == 0, -1);
+
+                // Setup the packet.
+                if (sw->vol.mute) {
+
+                    playback_set_volume_packet->vol = 0;
+                    playback_set_volume_packet->enabled = 0;
+
+                } else {
+
+                    playback_set_volume_packet->vol = (sw->vol.l * 100) / UINT_MAX;
+                    playback_set_volume_packet->enabled = 1;
+                }
+
+                // Send the packet
+                ret = openxt_v4v_send(conn, &snd_packet);
+                openxt_assert(ret == sizeof(OpenXTPlaybackSetVolumePacket), -1);
+
+                // Done
+                return 0;
+            }
+
+            // Failure
+            return -1;
+        }
+
+        default:
+            return -1;
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Capture                                                                                             //
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+///
+/// Initializes the capture device. This is one of QEMU's required functions.
+///
+/// @param hw points to a structure that QEMU provides. You need to initialize
+/// this structure by running audio_pcm_init_info, and then setting the # of
+/// samples after words.
+/// @param as settings structure. Provide information about the audio device
+/// as QEMU would like it. When you initialize hw, you can change these settings
+/// to whatever you want.
+///
+/// @return -EINVAL if NULL is passed to the parameters
+///         -ENODEV if V4V is not connected or the audio helper fails
+///         negative error code on error
+///         0 on success
+///
+static int openxt_capture_init(HWVoiceIn *hw, struct audsettings *as,
+                               void *drv_opaque)
+{
+    int ret;
+    struct audsettings settings;
+
+    // Sanity checks
+    openxt_checkp(hw, -EINVAL);
+    openxt_checkp(as, -EINVAL);
+    openxt_assert_quiet(capture_initialized == false, -ENODEV);
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, -ENODEV);
+
+    // For whatever reason, QEMU will run this function once, or it can run it
+    // 1000 times if an error occurs. The result if the VM gets bogged down
+    // like mad. This code with the assert above just makes sure that this code
+    // can only execute once.... like it should be in the first place.
+    capture_initialized = true;
+
+    // Ask the audio helper for the settings that we should be using. Note that
+    // we do not get these from QEMU, but instead let the audio helper tell us
+    // what it wants to do, and then tell QEMU what that is, which is a little
+    // different then what you will see in the alsaaudio driver.
+    ret = openxt_send_blank_packet(OPENXT_CAPTURE_INIT);
+    openxt_assert(ret == 0, ret);
+    ret = openxt_v4v_recv(conn, &rcv_packet);
+    openxt_assert(ret == sizeof(OpenXTCaptureInitAckPacket), ret);
+
+    // Make sure that ALSA configured correctly
+    openxt_assert(capture_init_ack_packet->valid != 0, -ENODEV);
+
+    // Set the settings structure that QEMU is expecting with the results
+    // from the audio helper. Note that this requires some conversions as
+    // ALSA stores the endianness and format together, while QEMU keeps
+    // these apart.
+    settings.freq = capture_init_ack_packet->freq;
+    settings.nchannels = capture_init_ack_packet->nchannels;
+    alsa_to_audfmt(capture_init_ack_packet->fmt, &settings.fmt, &settings.endianness);
+
+    // Setup QEMU
+    audio_pcm_init_info(&hw->info, &settings);
+    hw->samples = 1024;
+
+    // Success
+    return 0;
+}
+
+///
+/// Finalizes the capture device. This is one of QEMU's required functions.
+///
+/// @param hw points to a structure that QEMU provides.
+///
+static void openxt_capture_fini(HWVoiceIn *hw)
+{
+    openxt_send_blank_packet(OPENXT_CAPTURE_FINI);
+}
+
+///
+/// Processes the capture device. This is one of QEMU's required functions.
+///
+/// @param hw points to a structure that QEMU provides.
+/// @return the total number of samples that were processed.
+///
+static int openxt_capture(HWVoiceIn *hw)
+{
+    int ret;
+    int decr;
+    int samples;
+    int written = 0;
+
+    // Sanity checks
+    openxt_checkp(hw, 0);
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, 0);
+
+    // Calculate the total amount of space that is available in the emulated
+    // hardware. This is basically the total size of the buffer, minus the
+    // number of samples that are "live" in the buffer. Note that we use the
+    // max function as it is possible to get a negative here, so we check for
+    // that.
+    decr = audio_MAX(hw->samples - audio_pcm_hw_get_live_in(hw), 0);
+
+    // Loop through all of the samples that need to be processed, get them
+    // from don0, and provide them to the emulated hardware.
+    for (samples = decr; samples > 0; )
+    {
+        int len = samples;
+
+        // Make sure that we are not overrunning the circular buffer that QEMU
+        // has, as well as make sure that we are not overrunning the packet
+        // buffer.
+        len = audio_MIN(len, hw->samples - hw->wpos);
+        len = audio_MIN(len, MAX_PCM_BUFFER_SIZE / sizeof(uint32_t));
+
+        // Setup the packet so that we can ask for a set of samples from dom0
+        ret = openxt_v4v_set_opcode(&snd_packet, OPENXT_CAPTURE);
+        openxt_assert(ret == 0, 0);
+        ret = openxt_v4v_set_length(&snd_packet, sizeof(OpenXTCapturePacket));
+        openxt_assert(ret == 0, 0);
+
+        // Tell dom0 how many samples need to be collected.
+        capture_packet->num_samples = len;
+
+        // Send the request to dom0, and then wait for the samples to come back.
+        // Note that in this case, we don't really have a way to validate the
+        // packet size here for the result. The V4V logic will at least verify
+        // that the packet's len is what it reports, but it's possible for a
+        // messed up audio helper to give use a num_samples that doesn't correlate
+        // with the actually number of samples. This will not result in an overflow
+        // but it would result in garbage being sent to QEMU (not a big deal).
+        ret = openxt_v4v_send(conn, &snd_packet);
+        openxt_assert(ret == sizeof(OpenXTCapturePacket), 0);
+        ret = openxt_v4v_recv(conn, &rcv_packet);
+        openxt_assert(ret >= 0, 0);
+
+        // Check to see if we got any samples back. If we didn't there is nothing
+        // to do, and we can stop
+        if (capture_ack_packet->num_samples == 0)
+            break;
+
+        // Fill in the packet's body. Note that the hw->conv function is
+        // basically a memcpy, the only difference is that len is in samples
+        // instead of bytes. The destination is the current position in the circular
+        // buffer that QEMU provides, and the source is our packet.
+        hw->conv(hw->conv_buf + hw->wpos, capture_ack_packet->samples, capture_ack_packet->num_samples);
+
+        // We need to advance the internal pointers.
+        samples -= capture_ack_packet->num_samples;
+        written += capture_ack_packet->num_samples;
+        hw->wpos = (hw->wpos + capture_ack_packet->num_samples) % hw->samples;
+
+        // If the number of samples that we got back does not match the number
+        // of samples that we asked for, it means that the source is out of
+        // samples, in which case we can stop processing in this iteration.
+        if (capture_ack_packet->num_samples != len)
+            break;
+    }
+
+    // Success
+    return written;
+}
+
+///
+/// This is one of QEMU's required functions. All of the other drivers
+/// just pass this to QEMU's built in function. No idea what it actually
+/// does.
+///
+/// @param sw N/A
+/// @param buf N/A
+/// @param len N/A
+///
+/// @return N/A
+///
+static int openxt_read(SWVoiceIn *sw, void *buf, int size)
+{
+    return audio_pcm_sw_read(sw, buf, size);
+}
+
+///
+/// This function returns control information from QEMU.
+///
+/// @desc This is actually a really important function. Whenever the guest is
+/// about to start recording sound, it will first start the audio device, and
+/// once it is done, it will "close" the audio device. An easy way to
+/// see this is open Windows Recorder. As soon as you see recorder start,
+/// you will get an VOICE_ENABLE and you will get a VOICE_DISABLE when
+/// you close the app. This is important because these controls will prevent
+/// the hardware and software from processing when it doesn't need to be.
+/// One issue you might notice is ALSA by default in Linux seems to enable
+/// the device on bootup, so basically, in Linux, the capture device is
+/// firing constantly, even if your not using it. Either disable capture
+/// support in the VM's settings, or turn off the capture device in ALSA
+/// mixer once you start up the guest.
+///
+/// @param hw points to a structure that QEMU provides.
+/// @param cmd that command that QEMU is sending
+/// @param ... needs to be parsed based on the command. Look at the other
+/// drivers for examples.
+///
+/// @return -1 on not supported or error
+///         0 success / supported
+static int openxt_capture_ctl(HWVoiceIn *hw, int cmd, ...)
+{
+    int ret;
+
+    // Sanity checks
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, -ENODEV);
+
+    // Process the command
+    switch(cmd) {
+
+        case VOICE_ENABLE:
+            ret = openxt_send_blank_packet(OPENXT_CAPTURE_ENABLE_VOICE);
+            openxt_assert(ret == 0, -1);
+
+            // Success
+            return 0;
+
+        case VOICE_DISABLE:
+            ret = openxt_send_blank_packet(OPENXT_CAPTURE_DISABLE_VOICE);
+            openxt_assert(ret == 0, -1);
+
+            // Success
+            return 0;
+
+        case VOICE_VOLUME:
+
+            // TODO: We need to implement capture audio volume support. To support this
+            // a lot of work needs to be done to the audio helper side, as only one VM
+            // should have access to the capture device at a time, which it doesn't do
+            // now.
+            return -1;
+
+        default:
+            return -1;
+    }
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+// Init / Fini                                                                                         //
+/////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+///
+/// Initializes the audio front driver
+///
+/// @return an opaque pointer. We don't use this.
+///
+static void *openxt_audio_init(void)
+{
+    // Setup
+    openxt_debug_init();
+    conn = openxt_v4v_open(V4V_PORT_NONE, V4V_DOMID_ANY, OPENXT_AUDIO_PORT, 0);
+    openxt_assert(conn != NULL, NULL);
+
+    // Cleanup memory(safety)
+    memset(&snd_packet, 0, sizeof(V4VPacket));
+    memset(&rcv_packet, 0, sizeof(V4VPacket));
+
+    // Pointer checks
+    openxt_checkp(playback_packet = openxt_v4v_get_body(&snd_packet), NULL);
+    openxt_checkp(playback_init_ack_packet = openxt_v4v_get_body(&rcv_packet), NULL);
+    openxt_checkp(playback_set_volume_packet = openxt_v4v_get_body(&snd_packet), NULL);
+    openxt_checkp(playback_get_available_ack_packet = openxt_v4v_get_body(&rcv_packet), NULL);
+
+    // Pointer checks
+    openxt_checkp(capture_packet = openxt_v4v_get_body(&snd_packet), NULL);
+    openxt_checkp(capture_ack_packet = openxt_v4v_get_body(&rcv_packet), NULL);
+    openxt_checkp(capture_init_ack_packet = openxt_v4v_get_body(&rcv_packet), NULL);
+    openxt_checkp(capture_get_available_ack_packet = openxt_v4v_get_body(&rcv_packet), NULL);
+
+    // Size checks
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTPlaybackPacket)) == true, NULL);
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTPlaybackInitAckPacket)) == true, NULL);
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTPlaybackSetVolumePacket)) == true, NULL);
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTPlaybackGetAvailableAckPacket)) == true, NULL);
+
+    // Size checks
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTCapturePacket)) == true, NULL);
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTCaptureAckPacket)) == true, NULL);
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTCaptureInitAckPacket)) == true, NULL);
+    openxt_assert(openxt_v4v_validate(sizeof(OpenXTCaptureGetAvailableAckPacket)) == true, NULL);
+
+    // Success. We don't have an init/fini pointer to return as we use
+    // global memory like the other drivers, so like the other drivers we
+    // just pass the address of this function, as returning NULL indicates
+    // and error to QEMU.
+    return &openxt_audio_init;
+}
+
+///
+/// Finalize the audio front driver
+///
+static void openxt_audio_fini(void *opaque)
+{
+    int ret;
+
+    // Unused / Sanity checks
+    openxt_unused(opaque);
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true);
+
+    // Setup the packet
+    ret = openxt_send_blank_packet(OPENXT_FINI);
+    openxt_assert(ret == 0);
+
+    // Cleanup
+    openxt_v4v_close(conn);
+    openxt_debug_fini();
+}
+
+static struct audio_pcm_ops openxt_pcm_ops = {
+    .init_out = openxt_playback_init,
+    .fini_out = openxt_playback_fini,
+    .run_out  = openxt_playback,
+    .write    = openxt_write,
+    .ctl_out  = openxt_playback_ctl,
+
+    .init_in  = openxt_capture_init,
+    .fini_in  = openxt_capture_fini,
+    .run_in   = openxt_capture,
+    .read     = openxt_read,
+    .ctl_in   = openxt_capture_ctl
+};
+
+static struct audio_driver openxt_audio_driver = {
+    .name           = "openxt",
+    .descr          = "OpenXT Audio Driver",
+    .options        = NULL,
+    .init           = openxt_audio_init,
+    .fini           = openxt_audio_fini,
+    .pcm_ops        = &openxt_pcm_ops,
+    .can_be_default = 1,
+    .max_voices_out = INT_MAX,
+    .max_voices_in  = INT_MAX,
+    .voice_size_out = sizeof(OpenXTOut),
+    .voice_size_in  = sizeof(OpenXTIn)
+};
+
+static void register_audio_openxt(void)
+{
+    audio_driver_register(&openxt_audio_driver);
+}
+type_init(register_audio_openxt);
--- /dev/null
+++ b/audio/openxtdebug.c
@@ -0,0 +1,61 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#include "openxtdebug.h"
+
+////////////////////////////////////////////////////////////////////////////////
+// Global Variables                                                           //
+////////////////////////////////////////////////////////////////////////////////
+
+bool debugging_enabled = false;
+
+////////////////////////////////////////////////////////////////////////////////
+// Functions                                                                  //
+////////////////////////////////////////////////////////////////////////////////
+
+inline void openxt_debug_init(void)
+{
+#ifdef SYSLOG
+    openlog ("", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
+#endif
+
+    openxt_debug_set_enabled(true);
+}
+
+inline void openxt_debug_fini(void)
+{
+#ifdef SYSLOG
+    closelog ();
+#endif
+
+    openxt_debug_set_enabled(false);
+}
+
+bool openxt_debug_is_enabled(void)
+{
+    return debugging_enabled;
+}
+
+void openxt_debug_set_enabled(bool enabled)
+{
+    debugging_enabled = enabled;
+}
--- /dev/null
+++ b/audio/openxtdebug.h
@@ -0,0 +1,288 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#ifndef OPENXT_DEBUG_H
+#define OPENXT_DEBUG_H
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <sys/types.h>
+
+#include "openxtsettings.h"
+
+#ifdef SYSLOG
+#include <syslog.h>
+#include <stdlib.h>
+#else
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
+///
+/// Define TAG in your settings if you want a custom TAG provided in the debug
+/// statements
+///
+#ifndef TAG
+#define TAG ""
+#endif
+
+///
+/// This function can be used to tell the compiler that a variable is not used.
+///
+/// @param a unused variable
+///
+#define openxt_unused(a) (void)a
+
+///
+/// The goal of this macro to provide a a simple debug statement that also
+/// encapsulates syslog, so that things are reported to syslog if desired.
+/// You should not use this directly, but instead use one of the openxt_
+/// macros.
+///
+#ifdef SYSLOG
+    #define OPENXT_ERROR(...) \
+        fprintf(stderr, __VA_ARGS__); \
+        syslog(LOG_ERR, __VA_ARGS__)
+    #define OPENXT_DEBUG(...) \
+        fprintf(stdout, __VA_ARGS__); \
+        syslog(LOG_DEBUG, __VA_ARGS__)
+#else
+    #define OPENXT_ERROR(...) \
+        fprintf(stderr, __VA_ARGS__)
+    #define OPENXT_DEBUG(...) \
+        fprintf(stdout, __VA_ARGS__)
+#endif
+
+///
+/// This function can be used to validate that a pointer is not equal to NULL.
+/// It takes a second, variable set of arguments that allows you to provide a
+/// return value when the error occurs. If the function is a void, you can
+/// remove the second argument, and the compiler will equate that to "return;"
+///
+/// @param a pointer to validate
+/// @param ... return value (for none void functions)
+///
+#define openxt_checkp(a,...) \
+    if ((a) == 0) { \
+        if (openxt_debug_is_enabled() == true) { \
+            OPENXT_ERROR("%s: ERROR: {%s} == NULL, line: %d, func: %s\n", \
+                         TAG, \
+                         #a, \
+                         __LINE__, \
+                         __PRETTY_FUNCTION__); \
+        } \
+        return __VA_ARGS__; \
+    }
+
+///
+/// This function can be used to validate that a pointer is not equal to NULL.
+/// It takes a second, variable set of arguments that allows you to provide a
+/// return value when the error occurs. If the function is a void, you can
+/// remove the second argument, and the compiler will equate that to "return;"
+///
+/// @param a pointer to validate
+/// @param b goto label
+///
+#define openxt_checkp_goto(a,b) \
+    if ((a) == 0) { \
+        if (openxt_debug_is_enabled() == true) { \
+            OPENXT_ERROR("%s: ERROR: {%s} == NULL, line: %d, func: %s\n", \
+                        TAG, \
+                        #a, \
+                        __LINE__, \
+                        __PRETTY_FUNCTION__); \
+        } \
+        goto b; \
+    }
+
+///
+/// This is an assert, with a return. Most asserts are removed in "production"
+/// but this version is not. This macro (or it's alternatives) will likely be
+/// used a lot as it makes sure that what you are calling executed correctly.
+/// Use this to validate that a function executed correctly, or use it to
+/// validate that a variable has an expected value. The goal is to use this
+/// macro enough such that, if an error occurs, the function gracefully exits
+/// before something really bad happens.
+///
+/// @param a the expression to validate
+/// @param ... return value (for none void functions)
+///
+#define openxt_assert(a,...) \
+    if (!(a)) { \
+        if (openxt_debug_is_enabled() == true) { \
+            OPENXT_ERROR("%s: ERROR: {%s} == false, line: %d, func: %s\n", \
+                         TAG, \
+                         #a, \
+                         __LINE__, \
+                         __PRETTY_FUNCTION__); \
+        } \
+        return __VA_ARGS__; \
+    }
+
+///
+/// This is an assert, with a goto. Most asserts are removed in "production"
+/// but this version is not. This macro (or it's alternatives) will likely be
+/// used a lot as it makes sure that what you are calling executed correctly.
+/// Use this to validate that a function executed correctly, or use it to
+/// validate that a variable has an expected value. The goal is to use this
+/// macro enough such that, if an error occurs, the function gracefully exits
+/// before something really bad happens.
+///
+/// @param a the expression to validate
+/// @param b goto label
+///
+#define openxt_assert_goto(a,b) \
+    if (!(a)) { \
+        if (openxt_debug_is_enabled() == true) { \
+            OPENXT_ERROR("%s: ERROR: {%s} == false, line: %d, func: %s\n", \
+                         TAG, \
+                         #a, \
+                         __LINE__, \
+                         __PRETTY_FUNCTION__); \
+        } \
+        goto b; \
+    }
+
+///
+/// This is an assert, with a return. Most asserts are removed in "production"
+/// but this version is not. This macro (or it's alternatives) will likely be
+/// used a lot as it makes sure that what you are calling executed correctly.
+/// Use this to validate that a function executed correctly, or use it to
+/// validate that a variable has an expected value. The goal is to use this
+/// macro enough such that, if an error occurs, the function gracefully exits
+/// before something really bad happens.
+///
+/// @param a the expression to validate
+/// @param b linux error code (can either be ret, or errno)
+/// @param ... return value (for none void functions)
+///
+#define openxt_assert_ret(a,b,...) \
+    if (!(a)) { \
+        if (openxt_debug_is_enabled() == true) { \
+            OPENXT_ERROR("%s: ERROR: {%s} == false, error: %d, line: %d, func: %s\n", \
+                TAG, \
+                #a, \
+                b, \
+                __LINE__, \
+                __PRETTY_FUNCTION__); \
+        } \
+        return __VA_ARGS__; \
+    }
+
+///
+/// This is an assert, with a return. Most asserts are removed in "production"
+/// but this version is not. This macro (or it's alternatives) will likely be
+/// used a lot as it makes sure that what you are calling executed correctly.
+/// Use this to validate that a function executed correctly, or use it to
+/// validate that a variable has an expected value. The goal is to use this
+/// macro enough such that, if an error occurs, the function gracefully exits
+/// before something really bad happens.
+///
+/// @param a the expression to validate
+/// @param ... return value (for none void functions)
+///
+#define openxt_assert_quiet(a,...) \
+    if (!(a)) { \
+        return __VA_ARGS__; \
+    }
+
+///
+/// This function provide a wrapped printf (info). You can also define SYSLOG
+/// in your settings file, and the functionality will convert to using
+/// syslog instead of using printf. Use these functions just like
+/// printf.
+///
+#ifdef DEBUGGING_ENABLED
+#define openxt_info(...) \
+    if (openxt_debug_is_enabled() == true) { \
+        OPENXT_DEBUG(__VA_ARGS__); \
+    }
+#else
+#define openxt_info(...)
+#endif
+
+///
+/// This function provide a wrapped printf (warn). You can also define SYSLOG
+/// in your settings file, and the functionality will convert to using
+/// syslog instead of using printf. Use these functions just like
+/// printf.
+///
+#define openxt_warn(...) \
+    if (openxt_debug_is_enabled() == true) { \
+        OPENXT_ERROR(TAG ": WARNING: " __VA_ARGS__); \
+    }
+
+///
+/// This function provide a wrapped printf (error). You can also define SYSLOG
+/// in your settings file, and the functionality will convert to using
+/// syslog instead of using printf. Use these functions just like
+/// printf.
+///
+#define openxt_error(...) \
+    if (openxt_debug_is_enabled() == true) { \
+        OPENXT_ERROR(TAG ": ERROR: " __VA_ARGS__); \
+    }
+
+///
+/// This function provide a wrapped printf (error). You can also define SYSLOG
+/// in your settings file, and the functionality will convert to using
+/// syslog instead of using printf. Use these functions just like
+/// printf.
+///
+#define openxt_debug(...) \
+        OPENXT_ERROR(TAG ": DEBUG: " __VA_ARGS__); \
+
+///
+/// Helpful for debugging issues
+///
+#define openxt_line openxt_info("file: %s, line: %d\n", __FILE__, __LINE__);
+
+///
+/// This should be the first thing your run in your program. This initializes
+/// debugging
+///
+void openxt_debug_init(void);
+
+///
+/// This should be the last thing your program does. This cleans up debugging.
+///
+void openxt_debug_fini(void);
+
+///
+/// The following tells the debug statements where or not debugging is
+/// turned on
+///
+/// @return true = debugging is enabled
+///
+bool openxt_debug_is_enabled(void);
+
+///
+/// The following enables / disables debugging
+///
+/// @param enabled true = turn on debug messages
+///
+void openxt_debug_set_enabled(bool enabled);
+
+#endif // OPENXT_DEBUG_H
--- /dev/null
+++ b/audio/openxtpackets.h
@@ -0,0 +1,127 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#ifndef OPENXT_PACKETS_H
+#define OPENXT_PACKETS_H
+
+#include "openxtsettings.h"
+
+typedef enum PacketOpCode {
+
+    // Global
+    OPENXT_FINI                         = 01,
+
+    // Init Commands
+    OPENXT_PLAYBACK_INIT                = 10,
+    OPENXT_PLAYBACK_INIT_ACK            = 11,
+    OPENXT_CAPTURE_INIT                 = 12,
+    OPENXT_CAPTURE_INIT_ACK             = 13,
+
+    // Fini Commands
+    OPENXT_PLAYBACK_FINI                = 20,
+    OPENXT_CAPTURE_FINI                 = 21,
+
+    // Available
+    OPENXT_PLAYBACK_GET_AVAILABLE       = 30,
+    OPENXT_PLAYBACK_GET_AVAILABLE_ACK   = 31,
+    OPENXT_CAPTURE_GET_AVAILABLE        = 32,
+    OPENXT_CAPTURE_GET_AVAILABLE_ACK    = 33,
+
+    // Control
+    OPENXT_PLAYBACK_ENABLE_VOICE        = 40,
+    OPENXT_PLAYBACK_DISABLE_VOICE       = 41,
+    OPENXT_PLAYBACK_SET_VOLUME          = 43,
+    OPENXT_CAPTURE_ENABLE_VOICE         = 44,
+    OPENXT_CAPTURE_DISABLE_VOICE        = 45,
+
+    // Process
+    OPENXT_PLAYBACK                     = 50,
+    OPENXT_CAPTURE                      = 51,
+    OPENXT_CAPTURE_ACK                  = 53,
+
+} PacketOpCode;
+
+typedef struct  __attribute__((packed)) {
+
+} OpenBlankPacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t fmt;
+    int32_t freq;
+    int32_t valid;
+    int32_t nchannels;
+
+} OpenXTPlaybackInitAckPacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t available;
+
+} OpenXTPlaybackGetAvailableAckPacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t num_samples;
+    char samples[MAX_PCM_BUFFER_SIZE];
+
+} OpenXTPlaybackPacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t vol;
+    int32_t enabled;
+
+} OpenXTPlaybackSetVolumePacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t fmt;
+    int32_t freq;
+    int32_t valid;
+    int32_t nchannels;
+
+} OpenXTCaptureInitAckPacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t available;
+
+} OpenXTCaptureGetAvailableAckPacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t num_samples;
+
+} OpenXTCapturePacket;
+
+typedef struct  __attribute__((packed)) {
+
+    int32_t num_samples;
+    char samples[MAX_PCM_BUFFER_SIZE];
+
+} OpenXTCaptureAckPacket;
+
+#define PLAYBACK_PACKET_LENGTH(a) (sizeof(int32_t) + (sizeof(uint32_t) * a))
+#define CAPTURE_ACK_PACKET_LENGTH(a) (sizeof(int32_t) + (sizeof(uint32_t) * a))
+
+#endif // OPENXT_PACKETS_H
--- /dev/null
+++ b/audio/openxtsettings.h
@@ -0,0 +1,38 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#ifndef OPENXT_SETTINGS
+#define OPENXT_SETTINGS
+
+#define DEBUGGING_ENABLED
+#define TAG "openxt_audio_front"
+
+// The following means that we should have room for roughly 1280 samples
+#define MAX_PCM_BUFFER_SIZE (4096)
+
+// Define the maximum size of a V4V packet
+#define V4V_MAX_PACKET_BODY_SIZE (4096 * 2)
+
+// The following is the V4V port that we will use for communications.
+#define OPENXT_AUDIO_PORT 5001
+
+#endif // OPENXT_SETTINGS
\ No newline at end of file
--- /dev/null
+++ b/audio/openxtv4v.c
@@ -0,0 +1,378 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#include "openxtv4v.h"
+#include "openxtdebug.h"
+
+///
+/// This is the main function to setup your V4V connection to another domain.
+/// The following provides suggested arguments for this function:
+///
+/// Clients
+/// - local port = V4V_PORT_NONE
+/// - local domid = V4V_DOMID_ANY
+/// - remote port = <port #>
+/// - remote domid = <server domid, likely == 0>
+///
+/// Servers
+/// - local port = <port #>
+/// - local domid = V4V_DOMID_ANY
+/// - remote port = V4V_PORT_NONE
+/// - remote domid = <client domid>
+///
+/// @param lport local port
+/// @param ldomid local domid
+/// @param rport remote port
+/// @param rdomid remote domid
+///
+/// @return NULL on failure, valid pointer on success
+///
+V4VConnection *openxt_v4v_open(int32_t lport, int32_t ldomid, int32_t rport, int32_t rdomid)
+{
+    // Create a new connection structure
+    V4VConnection *conn = calloc(1, sizeof(V4VConnection));
+    openxt_checkp(conn, NULL);
+
+    // Initialize the connection for safety.
+    conn->fd = -1;
+    conn->connected = false;
+    conn->local_addr.port = lport;
+    conn->local_addr.domain = ldomid;
+    conn->remote_addr.port = rport;
+    conn->remote_addr.domain = rdomid;
+
+    // Attempt to open a V4V socket
+    if((conn->fd = v4v_socket(SOCK_DGRAM)) <= 0)
+        goto failure;
+
+    // Bind to V4V
+    if(v4v_bind(conn->fd, &conn->local_addr, conn->remote_addr.domain) != 0)
+        goto failure;
+
+    // We are now connected
+    conn->connected = true;
+
+    // Success
+    return conn;
+
+failure:
+
+    // Cleanup memory
+    free(conn);
+
+    // Failure
+    return NULL;
+}
+
+///
+/// The following is for internal use only.
+///
+int openxt_v4v_close_internal(V4VConnection *conn)
+{
+    int ret = 0;
+
+    // Sanity checks
+    openxt_checkp(conn, -EINVAL);
+
+    // Close V4V
+    if (conn->fd >= 0)
+        ret = v4v_close(conn->fd);
+
+    // We are no longer connected
+    conn->fd = -1;
+    conn->connected = false;
+
+    // Success
+    return ret;
+}
+
+///
+/// Once you are done with V4V, run this function. Note that this function
+/// could be called by this API if something bad happens.
+///
+/// Note that this free's conn, so don't call it twice :)
+///
+/// @return -EINVAL if conn == NULL,
+///          negative error code on failure of v4v_close,
+///          0 on success
+///
+int openxt_v4v_close(V4VConnection *conn)
+{
+    int ret = openxt_v4v_close_internal(conn);
+
+    // Sanity checks
+    openxt_checkp(conn, -EINVAL);
+
+    // Cleanup
+    free(conn);
+
+    // Success
+    return ret;
+}
+
+///
+/// The following function will tell you if the V4V socket is open and
+/// connected
+///
+/// @return true = connected, false = disconnected or conn == NULL
+///
+bool openxt_v4v_isconnected(V4VConnection *conn)
+{
+    // Sanity checks
+    openxt_checkp(conn, false);
+
+    // Return connection status
+    return conn->connected;
+}
+
+///
+/// The following can be used as a safety to make sure that your packets are
+/// not bigger than a V4V packet. This way you can use the packet structures
+/// all you want later without fear of buffer overflows.
+///
+/// @param size the size of your packet
+/// @return true = safe, false = unsafe (likely will overflow)
+///
+bool openxt_v4v_validate(int32_t size)
+{
+    return size <= V4V_MAX_PACKET_BODY_SIZE;
+}
+
+///
+/// The following will set the opcode of a packet.
+///
+/// @param packet the packet that you want to set the opcode for
+/// @param opcode the opcode that you want to set
+///
+/// @return -EINVAL if packet == NULL, 0 on success
+///
+int openxt_v4v_set_opcode(V4VPacket *packet, int32_t opcode)
+{
+    // Sanity checks
+    openxt_checkp(packet, -EINVAL);
+
+    // Set the opcode of the packet
+    packet->header.opcode = opcode;
+
+    // Success
+    return 0;
+}
+
+///
+/// The following will set the length of a packet.
+///
+/// @param packet the packet that you want to set the length for
+/// @param length the length that you want to set
+///
+/// @return -EINVAL if packet == NULL, -EOVERFLOW if the length is too large, 0 on success
+///
+int openxt_v4v_set_length(V4VPacket *packet, int32_t length)
+{
+    // Sanity checks
+    openxt_checkp(packet, -EINVAL);
+    openxt_assert(length <= V4V_MAX_PACKET_BODY_SIZE, -EOVERFLOW);
+
+    // Set the opcode of the packet
+    packet->header.length = length + sizeof(V4VPacketHeader);
+
+    // Success
+    return 0;
+}
+
+///
+/// The following will get the opcode of a packet.
+///
+/// @param packet the packet that you want to get the opcode for
+///
+/// @return -EINVAL if packet == NULL, opcode on success
+///
+int openxt_v4v_get_opcode(V4VPacket *packet)
+{
+    // Sanity checks
+    openxt_checkp(packet, -EINVAL);
+
+    // Success
+    return packet->header.opcode;
+}
+
+///
+/// The following will get the length of a packet.
+///
+/// @param packet the packet that you want to get the length for
+///
+/// @return -EINVAL if packet == NULL, length on success
+///
+int openxt_v4v_get_length(V4VPacket *packet)
+{
+    // Sanity checks
+    openxt_checkp(packet, -EINVAL);
+
+    // Success
+    return packet->header.length - sizeof(V4VPacketHeader);
+}
+
+///
+/// The following gets the body of a packet. This is basically where you would
+/// put the contents of your packet.
+///
+/// @code
+///
+/// V4VPacket snd_packet;
+/// MyPacket *packet = openxt_v4v_get_body(&snd_packet);
+///
+/// packet->data1 = data1;
+/// packet->data2 = data2;
+///
+/// openxt_v4v_set_opcode(&snd_packet, opcode);
+/// openxt_v4v_set_length(&snd_packet, sizeof(MyPacket));
+///
+/// openxt_v4v_send(conn, &snd_packet);
+///
+/// @endcode
+///
+/// @param packet the packet that you want body access to
+/// @return NULL = packet == NULL, valid pointer on success
+///
+void *openxt_v4v_get_body(V4VPacket *packet)
+{
+    // Sanity checks
+    openxt_checkp(packet, NULL);
+
+    // Success
+    return packet->body.buffer;
+}
+
+///
+/// The following function will send a V4V packet.
+///
+/// @param conn the V4V connection created using openxt_v4v_open.
+/// @param packet the packet to send
+///
+/// @return -EINVAL if conn or packet == NULL,
+///         -EOVERFLOW if the packet length is too large,
+///         -ENODEV if conn is closed,
+///          negative errno if v4v_sendto fails,
+///          ret >= 0 on success representing number of bytes sent
+///
+int openxt_v4v_send(V4VConnection *conn, V4VPacket *packet)
+{
+    // Local variables
+    int ret;
+
+    // Sanity checks
+    openxt_checkp(conn, -EINVAL);
+    openxt_checkp(packet, -EINVAL);
+    openxt_assert(openxt_v4v_get_length(packet) <= V4V_MAX_PACKET_BODY_SIZE, -EOVERFLOW);
+
+    // Make sure that we are actually connected. Note that we make this a
+    // quite failure because if a problem happens, we will close the connection
+    // and it's possible that the code might continue attempting to send, and
+    // we do not want to kill performance by logging a ton of error messages
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, -ENODEV);
+
+    // Send the packet. Note that we handle printing useful error messages
+    // here. All the user should have to do, is validate that the send was
+    // successful
+    ret = v4v_sendto(conn->fd, (char *)packet, packet->header.length, 0, &conn->remote_addr);
+    if (ret <= 0) {
+
+        switch (ret) {
+
+            // Failed to send anything
+            case 0:
+                openxt_warn("failed openxt_v4v_send, wrote 0 bytes: %d - %s\n", errno, strerror(errno));
+                openxt_v4v_close_internal(conn);
+                return -errno;
+
+            // Error
+            default:
+                openxt_warn("failed openxt_v4v_send: %d - %s\n", errno, strerror(errno));
+                openxt_v4v_close_internal(conn);
+                return -errno;
+        }
+    }
+
+    // Success
+    return ret - sizeof(V4VPacketHeader);
+}
+
+///
+/// The following function will send a V4V packet.
+///
+/// @param conn the V4V connection created using openxt_v4v_open.
+/// @param packet the packet to send
+///
+/// @return -EINVAL if conn or packet == NULL,
+///         -EIO if the received packet length != length in header,
+///         -ENODEV if conn is closed,
+///          negative errno if v4v_recvfrom fails,
+///          ret >= 0 on success representing number of bytes received
+///
+int openxt_v4v_recv(V4VConnection *conn, V4VPacket *packet)
+{
+    // Local variables
+    int ret;
+
+    // Sanity checks
+    openxt_checkp(conn, -EINVAL);
+    openxt_checkp(packet, -EINVAL);
+
+    // Make sure that we are actually connected. Note that we make this a
+    // quite failure because if a problem happens, we will close the connection
+    // and it's possible that the code might continue attempting to send, and
+    // we do not want to kill performance by logging a ton of error messages
+    openxt_assert_quiet(openxt_v4v_isconnected(conn) == true, -ENODEV);
+
+    // Send the packet. Note that we handle printing useful error messages
+    // here. All the user should have to do, is validate that the send was
+    // successful
+    ret = v4v_recvfrom(conn->fd, (char *)packet, sizeof(V4VPacket), 0, &conn->remote_addr);
+    if (ret <= 0) {
+
+        switch (ret) {
+
+            // Failed to receive anything
+            case 0:
+                openxt_warn("failed openxt_v4v_recv, read 0 bytes: %d - %s\n", errno, strerror(errno));
+                openxt_v4v_close_internal(conn);
+                return -errno;
+
+            // Error
+            default:
+                openxt_warn("failed openxt_v4v_recv: %d - %s\n", errno, strerror(errno));
+                openxt_v4v_close_internal(conn);
+                return -errno;
+        }
+    }
+
+    // Before we return the packet, we need to check to make sure that the
+    // amount of data that we read, is equal to the amount of data that the
+    // packet should have returned. If it is not, we have an error
+    if (packet->header.length != ret) {
+        openxt_warn("failed openxt_v4v_recv: length mismatch %d - %d\n", packet->header.length, ret);
+        openxt_v4v_close_internal(conn);
+        return -EIO;
+    }
+
+    // Success
+    return ret - sizeof(V4VPacketHeader);
+}
--- /dev/null
+++ b/audio/openxtv4v.h
@@ -0,0 +1,78 @@
+//
+// Copyright (c) 2015 Assured Information Security, Inc
+//
+// Dates Modified:
+//  - 4/8/2015: Initial commit
+//    Rian Quinn <quinnr@ainfosec.com>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+//
+
+#ifndef OPENXT_V4V_H
+#define OPENXT_V4V_H
+
+#include <libv4v.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+
+#include "openxtsettings.h"
+
+typedef struct V4VConnection {
+
+    int fd;
+    bool connected;
+    v4v_addr_t local_addr;
+    v4v_addr_t remote_addr;
+
+} V4VConnection;
+
+V4VConnection *openxt_v4v_open(int32_t lport, int32_t ldomid, int32_t rport, int32_t rdomid);
+int openxt_v4v_close_internal(V4VConnection *conn);
+int openxt_v4v_close(V4VConnection *conn);
+bool openxt_v4v_isconnected(V4VConnection *conn);
+
+typedef struct V4VPacketHeader {
+
+    int32_t opcode;
+    int32_t length;
+
+} V4VPacketHeader;
+
+typedef struct V4VPacketBody {
+
+    char buffer[V4V_MAX_PACKET_BODY_SIZE];
+
+} V4VPacketBody;
+
+typedef struct V4VPacket {
+
+    V4VPacketHeader header;
+    V4VPacketBody body;
+
+} V4VPacket;
+
+bool openxt_v4v_validate(int32_t size);
+
+int openxt_v4v_set_opcode(V4VPacket *packet, int32_t opcode);
+int openxt_v4v_set_length(V4VPacket *packet, int32_t length);
+int32_t openxt_v4v_get_opcode(V4VPacket *packet);
+int32_t openxt_v4v_get_length(V4VPacket *packet);
+void *openxt_v4v_get_body(V4VPacket *packet);
+
+int openxt_v4v_send(V4VConnection *conn, V4VPacket *packet);
+int openxt_v4v_recv(V4VConnection *conn, V4VPacket *packet);
+
+#endif // OPENXT_V4V_H
--- a/configure
+++ b/configure
@@ -877,7 +877,7 @@ Haiku)
 ;;
 Linux)
   audio_drv_list="oss"
-  audio_possible_drivers="oss alsa sdl pa"
+  audio_possible_drivers="oss alsa sdl pa openxt"
   linux="yes"
   linux_user="yes"
   kvm="yes"
