--- a/chardev/Makefile.objs
+++ b/chardev/Makefile.objs
@@ -23,3 +23,4 @@ baum.o-cflags := $(SDL_CFLAGS)
 baum.o-libs := $(BRLAPI_LIBS)
 
 common-obj-$(CONFIG_SPICE) += spice.o
+chardev-obj-$(CONFIG_XEN) += char-v4v.o
--- /dev/null
+++ b/chardev/char-v4v.c
@@ -0,0 +1,326 @@
+/*
+ * QEMU System Emulator
+ *
+ * Copyright (c) 2003-2008 Fabrice Bellard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#include "qemu/osdep.h"
+#include "chardev/char.h"
+#include "io/channel-file.h"
+#include "io/channel-socket.h"
+#include "qemu/option.h"
+#include "qapi/error.h"
+
+#include "chardev/char-io.h"
+#include "sys/ioctl.h"
+#include <libv4v.h>
+
+/***********************************************************/
+/* V4V console for QMP */
+
+#define V4V_TYPE 'W'
+#define V4VIOCSETRINGSIZE       _IOW (V4V_TYPE,  1, uint32_t)
+
+#define V4V_QH_PORT 5100
+#define V4V_CHARDRV_PORT 15100
+#define V4V_CHARDRV_RING_SIZE \
+  (V4V_ROUNDUP((((4096)*4) - sizeof(v4v_ring_t)-V4V_ROUNDUP(1))))
+
+#define V4V_CHARDRV_NAME  "[v4v-chardrv]"
+
+#define V4V_MAGIC_CONNECT    "live"
+#define V4V_MAGIC_DISCONNECT "dead"
+
+typedef struct {
+    Chardev parent;
+    QIOChannel *ioc;
+    v4v_addr_t remote_addr;
+    v4v_addr_t local_addr;
+    uint8_t buf[CHR_READ_BUF_LEN];
+    int fd;
+    int bufcnt;
+    int bufptr;
+    int max_size;
+    int connected;
+    bool stream;
+} V4vChardev;
+
+#define TYPE_CHARDEV_V4V "chardev-v4v"
+#define V4V_CHARDEV(obj)                                     \
+    OBJECT_CHECK(V4vChardev, (obj), TYPE_CHARDEV_V4V)
+
+
+static int v4v_chr_write(Chardev *chr, const uint8_t *buf, int len)
+{
+    V4vChardev *s = V4V_CHARDEV(chr);
+    int ret;
+
+    if (s->stream) {
+        ret = v4v_send(s->fd, buf, len, 0);
+    } else {
+        ret = v4v_sendto(s->fd, buf, len, 0, &s->remote_addr);
+    }
+    if (ret != len) {
+        fprintf(stderr, "%s error: v4v_sendto() failed (%s) - %d %d.\n",
+                V4V_CHARDRV_NAME, strerror(errno), ret, len);
+        return 0;
+    }
+
+    return ret;
+}
+
+static int v4v_chr_read_poll(void *opaque)
+{
+    Chardev *chr = CHARDEV(opaque);
+    V4vChardev *s = V4V_CHARDEV(chr);
+
+    s->max_size = qemu_chr_be_can_write(chr);
+
+    /* If there were any stray characters in the queue process them
+     * first
+     */
+    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
+        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
+        s->bufptr++;
+        s->max_size = qemu_chr_be_can_write(chr);
+    }
+    return s->max_size;
+}
+
+static gboolean v4v_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque);
+
+static void v4v_chr_update_read_handler(Chardev *chr)
+{
+    V4vChardev *s = V4V_CHARDEV(chr);
+
+    remove_fd_in_watch(chr);
+    if (s->ioc) {
+        chr->gsource = io_add_watch_poll(chr, s->ioc,
+                                         v4v_chr_read_poll,
+                                         v4v_chr_read, chr,
+                                         chr->gcontext);
+    }
+}
+
+static gboolean v4v_chr_read(QIOChannel *chan, GIOCondition cond, void *opaque)
+{
+    Chardev *chr = CHARDEV(opaque);
+    V4vChardev *s = V4V_CHARDEV(chr);
+    int ret;
+
+    if (s->max_size == 0)
+        return FALSE;
+
+    ret = v4v_recvfrom(s->fd, s->buf, sizeof(s->buf), 0, &s->remote_addr);
+    if (ret < 0) {
+        fprintf(stderr, "%s error: v4v_recvfrom() failed (%s) - %d.\n",
+                V4V_CHARDRV_NAME, strerror(errno), ret);
+        return FALSE;
+    }
+
+    if (!s->stream) {
+        if (s->connected == 0 && !strncmp((char*)(s->buf), V4V_MAGIC_CONNECT, 4)) {
+            fprintf(stderr, "v4v_recvfrom() returned V4V_MAGIC_CONNECT, connecting.\n");
+            v4v_chr_update_read_handler(chr);
+            qemu_chr_be_event(chr, CHR_EVENT_OPENED);
+            if (!chr->gsource) {
+                chr->gsource = io_add_watch_poll(chr, s->ioc,
+                                                 v4v_chr_read_poll,
+                                                 v4v_chr_read, chr, chr->gcontext);
+            }
+            s->connected = 1;
+            return FALSE;
+        }
+        if (s->connected == 1 && !strncmp((char*)(s->buf), V4V_MAGIC_DISCONNECT, 4)) {
+            v4v_chr_update_read_handler(chr);
+            qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
+            if (!chr->gsource) {
+                chr->gsource = io_add_watch_poll(chr, s->ioc,
+                                                 v4v_chr_read_poll,
+                                                 v4v_chr_read, chr, chr->gcontext);
+            }
+            fprintf(stderr, "v4v_recvfrom() returned V4V_MAGIC_DISCONNECT, closing.\n");
+            s->connected = 0;
+            return FALSE;
+        }
+    }
+
+    s->bufcnt = ret;
+    s->bufptr = 0;
+    while (s->max_size > 0 && s->bufptr < s->bufcnt) {
+        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);
+        s->bufptr++;
+        s->max_size = qemu_chr_be_can_write(chr);
+    }
+
+    return TRUE;
+}
+
+static GSource *v4v_chr_add_watch(Chardev *chr, GIOCondition cond)
+{
+    V4vChardev *s = V4V_CHARDEV(chr);
+    return qio_channel_create_watch(s->ioc, cond);
+}
+
+static void char_v4v_finalize(Object *obj)
+{
+    Chardev *chr = CHARDEV(obj);
+    V4vChardev *s = V4V_CHARDEV(chr);
+
+    remove_fd_in_watch(chr);
+    if (s->ioc) {
+        object_unref(OBJECT(s->ioc));
+    }
+
+    s->fd = -1;
+
+    qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
+}
+
+static void qemu_chr_parse_v4v(QemuOpts *opts, ChardevBackend *backend,
+                               Error **errp)
+{
+    uint64_t domid = qemu_opt_get_number(opts, "domid", 0);
+    /* Sigh, port is defined as a string */
+    const char *port_str = qemu_opt_get(opts, "port");
+    const char *localport_str = qemu_opt_get(opts, "localport");
+    bool stream = qemu_opt_get_bool(opts, "stream", false);
+    uint32_t port, localport;
+    ChardevV4v *v4v;
+
+    port = port_str ? strtoul(port_str, NULL, 0) : V4V_QH_PORT;
+    localport = localport_str ? strtoul(localport_str, NULL, 0) : 0;
+
+    backend->type = CHARDEV_BACKEND_KIND_V4V;
+    if (domid > 0x7fff) {
+        error_setg(errp, "chardev: v4v: domid invalid");
+        return;
+    }
+    if (port > 0xffff) {
+        error_setg(errp, "chardev: v4v: port %u out of range", port);
+        return;
+    }
+    if (localport == 0) {
+        localport = port + 10000;
+    }
+    if (localport > 0xffff) {
+        error_setg(errp,
+                   "chardev: v4v: localport %u out of range", localport);
+        return;
+    }
+
+    v4v = backend->u.v4v.data = g_new0(ChardevV4v, 1);
+    qemu_chr_parse_common(opts, qapi_ChardevV4v_base(v4v));
+
+    v4v->domid     = domid;
+    v4v->port      = port;
+    v4v->localport = localport;
+    v4v->stream    = stream;
+}
+
+static void qmp_chr_open_v4v(Chardev *chr,
+                             ChardevBackend *backend,
+                             bool *be_opened,
+                             Error **errp)
+{
+    V4vChardev *s = V4V_CHARDEV(chr);
+    ChardevV4v *v4v = backend->u.v4v.data;
+    uint32_t v4v_ring_size = V4V_CHARDRV_RING_SIZE;
+    int fd = -1;
+
+    s->local_addr.port = v4v->localport;
+    s->local_addr.domain = V4V_DOMID_ANY;
+    s->remote_addr.port = v4v->port;
+    s->remote_addr.domain = v4v->domid;
+    s->stream = v4v->stream;
+
+    fd = v4v_socket(s->stream ? SOCK_STREAM : SOCK_DGRAM);
+    if (fd < 0) {
+        error_setg(errp, "%s cannot create v4v socket - err: %d",
+                   V4V_CHARDRV_NAME, fd);
+        return;
+    }
+
+    if (ioctl(fd, V4VIOCSETRINGSIZE, &v4v_ring_size)) {
+        error_setg(errp,
+                   "%s failed to set ring size v4v socket - err: %d",
+                   V4V_CHARDRV_NAME, errno);
+        close(fd);
+        return;
+    }
+
+    if (v4v_bind(fd, &s->local_addr, 0)) {
+        error_setg(errp,
+                   "%s failed to bind v4v socket - err: %d",
+                   V4V_CHARDRV_NAME, errno);
+        close(fd);
+        return;
+    }
+
+    if (s->stream) {
+        if (v4v_connect(fd, &s->remote_addr)) {
+            error_setg(errp,
+                       "%s failed to connect v4v socket - err: %d",
+                       V4V_CHARDRV_NAME, errno);
+            close(fd);
+            return;
+        }
+    }
+
+
+    s->fd = fd;
+    s->bufcnt = 0;
+    s->bufptr = 0;
+    /* be isn't opened until we get a connection */
+    *be_opened = false;
+
+    s->ioc = QIO_CHANNEL(qio_channel_file_new_fd(fd));
+
+    /* TODO currently starting up open */
+    s->connected = 1;
+
+    fprintf(stderr, "Opened V4V chardev\n");
+}
+
+static void char_v4v_class_init(ObjectClass *oc, void *data)
+{
+    ChardevClass *cc = CHARDEV_CLASS(oc);
+
+    cc->parse = qemu_chr_parse_v4v;
+    cc->open = qmp_chr_open_v4v;
+    cc->chr_write = v4v_chr_write;
+    cc->chr_add_watch = v4v_chr_add_watch;
+    cc->chr_update_read_handler = v4v_chr_update_read_handler;
+}
+
+static const TypeInfo char_v4v_type_info = {
+    .name = TYPE_CHARDEV_V4V,
+    .parent = TYPE_CHARDEV,
+    .instance_size = sizeof(V4vChardev),
+    .instance_finalize = char_v4v_finalize,
+    .class_init = char_v4v_class_init,
+};
+
+static void register_types(void)
+{
+    type_register_static(&char_v4v_type_info);
+}
+
+type_init(register_types);
--- a/chardev/char.c
+++ b/chardev/char.c
@@ -366,6 +366,7 @@ QemuOpts *qemu_chr_parse_compat(const ch
         strcmp(filename, "msmouse") == 0 ||
         strcmp(filename, "wctablet") == 0 ||
         strcmp(filename, "braille") == 0 ||
+        strcmp(filename, "v4v")     == 0 ||
         strcmp(filename, "testdev") == 0 ||
         strcmp(filename, "stdio")   == 0) {
         qemu_opt_set(opts, "backend", filename, &error_abort);
@@ -855,6 +856,9 @@ QemuOptsList qemu_chardev_opts = {
             .name = "reconnect",
             .type = QEMU_OPT_NUMBER,
         },{
+            .name = "stream",
+            .type = QEMU_OPT_BOOL,
+        },{
             .name = "telnet",
             .type = QEMU_OPT_BOOL,
         },{
--- a/include/chardev/char.h
+++ b/include/chardev/char.h
@@ -235,6 +235,7 @@ int qemu_chr_wait_connected(Chardev *chr
 #define TYPE_CHARDEV_SERIAL "chardev-serial"
 #define TYPE_CHARDEV_SOCKET "chardev-socket"
 #define TYPE_CHARDEV_UDP "chardev-udp"
+#define TYPE_CHARDEV_V4V "chardev-v4v"
 
 #define CHARDEV_IS_RINGBUF(chr) \
     object_dynamic_cast(OBJECT(chr), TYPE_CHARDEV_RINGBUF)
--- a/qapi/char.json
+++ b/qapi/char.json
@@ -286,6 +286,24 @@
   'base': 'ChardevCommon' }
 
 ##
+# @ChardevV4v:
+#
+# Configuration info for v4v socket chardevs.
+#
+# @domid: remote domain id (defaults to 0 dom0)
+# @port: remote port (defaults to 5100 QMP helper)
+# @localport: local port (defaults to port + 10000)
+# @stream: Use V4V SOCK_STREAM (defaults to false, SOCK_DGRAM)
+#
+# Since: Not upstream
+##
+{ 'struct': 'ChardevV4v', 'data': { '*domid'    : 'int',
+                                  '*port'       : 'int',
+                                  '*localport'  : 'int',
+                                  '*stream'     : 'bool' },
+  'base': 'ChardevCommon' }
+
+##
 # @ChardevMux:
 #
 # Configuration info for mux chardevs.
@@ -395,6 +413,7 @@
                                        'spiceport': 'ChardevSpicePort',
 # TODO: { 'type': 'ChardevSpicePort', 'if': 'defined(CONFIG_SPICE)' },
                                        'vc'     : 'ChardevVC',
+                                       'v4v'    : 'ChardevV4v',
                                        'ringbuf': 'ChardevRingbuf',
                                        # next one is just for compatibility
                                        'memory' : 'ChardevRingbuf' } }
--- a/qemu-options.hx
+++ b/qemu-options.hx
@@ -2458,6 +2458,10 @@ DEF("chardev", HAS_ARG, QEMU_OPTION_char
     "-chardev parallel,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\n"
     "-chardev parport,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\n"
 #endif
+#if defined(CONFIG_XEN)
+    "-chardev v4v,id=id[,port=5100][,domid=0][,localport=15100][,stream=on|off]\n"
+    "         [,logfile=PATH][,logappend=on|off]\n"
+#endif
 #if defined(CONFIG_SPICE)
     "-chardev spicevmc,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]\n"
     "-chardev spiceport,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]\n"
