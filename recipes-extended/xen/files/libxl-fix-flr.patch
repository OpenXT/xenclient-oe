################################################################################
SHORT DESCRIPTION:
################################################################################
Fix device reset for pci devices in libxl

################################################################################
LONG DESCRIPTION:
################################################################################
This patch fixes the logic and the control flow path for pci device reset in
libxl.  Additionally, it addresses an issue with Xenbus state synchronization
during domain teardown.  More detailed information about the patch follows:

The changes to Xenbus state are to prevent hitting a timeout when domains are 
shutdown or destroyed. Xl is waiting for "XenbusStateConnected" (state 4), while 
the state machine has already moved the device to Closing (state 5) and Closed 
(state 6) by the time we reach this point tearing down the domain.

The reset logic introduced in this patch is delayed until the domain has fully 
been destroyed. The reason for this has to do with the 
thorough-reset-interface-to-pciback-s-sysfs.patch in the linux patchqueue. 
__pcistub_raw_device_reset tries multiple approaches for resetting the device, 
flr, slot-level, and bus-level. If we encounter a device that, for example, 
doesn't support flr but does support a slot-level reset, we want to make sure 
all the functions on that device (GPUS are a good example, they often have 2 
functions, video and HDMI audio, and are the only device in the slot) are 
released from the domain before attempting the reset or it will fail. This 
approach seems to be taken in an attempt to support a wide variety of PCI 
devices.

################################################################################
CHANGELOG
################################################################################
Authors:
Chris Rogers <rogersc@ainfosec.com>

################################################################################
REMOVAL
################################################################################
N/A

################################################################################
UPSTREAM PLAN
################################################################################
Depends on the feasibility of upstreaming thorough-reset-interface-to-pciback...

################################################################################
INTERNAL DEPENDENCIES
################################################################################

################################################################################
PATCHES
################################################################################
--- a/tools/libxl/libxl_internal.h
+++ b/tools/libxl/libxl_internal.h
@@ -1722,12 +1722,20 @@ _hidden int libxl__pci_topology_init(lib
                                      int num_devs);
 
 /* from libxl_pci */
+typedef struct libxl_pci_dev_wrap {
+    libxl_device_pci *pcidevs;
+    int num_devs;
+} libxl_pci_dev_wrap;
 
 _hidden void libxl__device_pci_add(libxl__egc *egc, uint32_t domid,
                                    libxl_device_pci *pcidev, bool starting,
                                    libxl__ao_device *aodev);
 _hidden void libxl__device_pci_destroy_all(libxl__egc *egc, uint32_t domid,
-                                           libxl__multidev *);
+                                           libxl__multidev *,
+					   libxl_pci_dev_wrap **pciw);
+_hidden int libxl__device_pci_reset(libxl__gc *gc, unsigned int domain,
+                                    unsigned int bus, unsigned int dev,
+                                    unsigned int func);
 _hidden int libxl__device_pci_setdefault(libxl__gc *gc, uint32_t domid,
                                          libxl_device_pci *pci, bool hotplug);
 _hidden bool libxl__is_igd_vga_passthru(libxl__gc *gc,
@@ -4075,6 +4083,7 @@ struct libxl__destroy_domid_state {
     libxl__devices_remove_state drs;
     libxl__destroy_devicemodel_state ddms;
     libxl__ev_child destroyer;
+    libxl_pci_dev_wrap *pciw;
     bool soft_reset;
     libxl__multidev multidev;
 };
--- a/tools/libxl/libxl_pci.c
+++ b/tools/libxl/libxl_pci.c
@@ -221,7 +221,7 @@ static int libxl__device_pci_remove_xens
         return ERROR_FAIL;
 
     if (domtype == LIBXL_DOMAIN_TYPE_PV) {
-        if (libxl__wait_for_backend(gc, be_path, GCSPRINTF("%d", XenbusStateConnected)) < 0) {
+        if (libxl__wait_for_backend(gc, be_path, GCSPRINTF("%d", XenbusStateClosed)) < 0) {
             LOGD(DEBUG, domid, "pci backend at %s is not ready", be_path);
             return ERROR_FAIL;
         }
@@ -244,13 +244,12 @@ static int libxl__device_pci_remove_xens
 retry_transaction:
     t = xs_transaction_start(ctx->xsh);
     xs_write(ctx->xsh, t, GCSPRINTF("%s/state-%d", be_path, i), GCSPRINTF("%d", XenbusStateClosing), 1);
-    xs_write(ctx->xsh, t, GCSPRINTF("%s/state", be_path), GCSPRINTF("%d", XenbusStateReconfiguring), 1);
     if (!xs_transaction_end(ctx->xsh, t, 0))
         if (errno == EAGAIN)
             goto retry_transaction;
 
     if (domtype == LIBXL_DOMAIN_TYPE_PV) {
-        if (libxl__wait_for_backend(gc, be_path, GCSPRINTF("%d", XenbusStateConnected)) < 0) {
+        if (libxl__wait_for_backend(gc, be_path, GCSPRINTF("%d", XenbusStateClosed)) < 0) {
             LOGD(DEBUG, domid, "pci backend at %s is not ready", be_path);
             return ERROR_FAIL;
         }
@@ -1446,13 +1445,13 @@ out:
     pas->callback(egc, pas, rc);
 }
 
-static int libxl__device_pci_reset(libxl__gc *gc, unsigned int domain, unsigned int bus,
+int libxl__device_pci_reset(libxl__gc *gc, unsigned int domain, unsigned int bus,
                                    unsigned int dev, unsigned int func)
 {
     char *reset;
     int fd, rc;
 
-    reset = GCSPRINTF("%s/do_flr", SYSFS_PCIBACK_DRIVER);
+    reset = GCSPRINTF("%s/reset_device", SYSFS_PCIBACK_DRIVER);
     fd = open(reset, O_WRONLY);
     if (fd >= 0) {
         char *buf = GCSPRINTF(PCI_BDF, domain, bus, dev, func);
@@ -2169,11 +2168,6 @@ static void pci_remove_detatched(libxl__
 
     isstubdom = libxl_is_stubdom(CTX, domid, &domainid);
 
-    /* don't do multiple resets while some functions are still passed through */
-    if ( (pcidev->vdevfn & 0x7) == 0 ) {
-        libxl__device_pci_reset(gc, pcidev->domain, pcidev->bus, pcidev->dev, pcidev->func);
-    }
-
     if (!isstubdom) {
         rc = xc_deassign_device(CTX->xch, domid, pcidev_encode_bdf(pcidev));
         if (rc < 0 && (prs->hvm || errno != ENOSYS))
@@ -2419,7 +2413,8 @@ out:
 }
 
 void libxl__device_pci_destroy_all(libxl__egc *egc, uint32_t domid,
-                                   libxl__multidev *multidev)
+                                   libxl__multidev *multidev,
+                                   libxl_pci_dev_wrap **pciw)
 {
     STATE_AO_GC(multidev->ao);
     libxl_device_pci *pcidevs;
@@ -2439,6 +2434,12 @@ void libxl__device_pci_destroy_all(libxl
         libxl__device_pci_remove_common(egc, domid, pcidevs + i, true,
                                         aodev);
     }
+
+    *pciw = malloc(sizeof(libxl_pci_dev_wrap));
+    if (*pciw) {
+        (*pciw)->pcidevs = pcidevs;
+        (*pciw)->num_devs = num;
+    }
 }
 
 int libxl__grant_vga_iomem_permission(libxl__gc *gc, const uint32_t domid,
--- a/tools/libxl/libxl_domain.c
+++ b/tools/libxl/libxl_domain.c
@@ -1187,6 +1187,15 @@ static void domain_destroy_callback(libx
         dds->rc = rc;
     }
 
+    if(dis->pciw) {
+        for (int i = 0; i < dis->pciw->num_devs; i++) {
+            libxl_device_pci *pcidev = &dis->pciw->pcidevs[i];
+            libxl__device_pci_reset(gc, pcidev->domain, pcidev->bus, pcidev->dev, pcidev->func);
+        }
+        free(dis->pciw->pcidevs);
+        free(dis->pciw);
+    }
+
     dds->domain_finished = 1;
     destroy_finish_check(egc, dds);
 }
@@ -1269,7 +1278,7 @@ void libxl__destroy_domid(libxl__egc *eg
 
     libxl__multidev_begin(ao, &dis->multidev);
     dis->multidev.callback = destroy_domid_pci_done;
-    libxl__device_pci_destroy_all(egc, domid, &dis->multidev);
+    libxl__device_pci_destroy_all(egc, domid, &dis->multidev, &dis->pciw);
     libxl__multidev_prepared(egc, &dis->multidev, 0);
     return;
 
