################################################################################
SHORT DESCRIPTION: 
################################################################################
XSA-222 (http://xenbits.xen.org/xsa/advisory-222.html)
stale P2M mappings due to insufficient error checking.

################################################################################
LONG DESCRIPTION: 
################################################################################
Source: http://xenbits.xen.org/xsa/advisory-222.html
Patches: xsa222-2-4.5.patch (ARM changes removed)

From: Jan Beulich <jbeulich@suse.com>
Subject: guest_physmap_remove_page() needs its return value checked

Callers, namely such subsequently freeing the page, must not blindly
assume success - the function may namely fail when needing to shatter a
super page, but there not being memory available for the then needed
intermediate page table.

As it happens, guest_remove_page() callers now also all check the
return value.

Furthermore a missed put_gfn() on an error path in gnttab_transfer() is
also being taken care of.

This is part of XSA-222.

Reported-by: Julien Grall <julien.grall@arm.com>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Signed-off-by: Julien Grall <julien.grall@arm.com>
Reviewed-by: Andrew Cooper <andrew.cooper3@citrix.com>

################################################################################
PATCHES 
################################################################################
Index: xen-4.3.4/xen/arch/x86/mm.c
===================================================================
--- xen-4.3.4.orig/xen/arch/x86/mm.c
+++ xen-4.3.4/xen/arch/x86/mm.c
@@ -4112,7 +4112,11 @@ static int replace_grant_p2m_mapping(
                  type, mfn_x(old_mfn), frame);
         return GNTST_general_error;
     }
-    guest_physmap_remove_page(d, gfn, frame, PAGE_ORDER_4K);
+    if ( guest_physmap_remove_page(d, gfn, frame, PAGE_ORDER_4K) )
+    {
+        put_gfn(d, gfn);
+        return GNTST_general_error;
+    }
 
     put_gfn(d, gfn);
     return GNTST_okay;
@@ -4637,7 +4641,7 @@ static int xenmem_add_to_physmap_once(
     struct page_info *page = NULL;
     unsigned long gfn = 0; /* gcc ... */
     unsigned long prev_mfn, mfn = 0, gpfn, idx;
-    int rc = -EINVAL;
+    int rc = 0;
     p2m_type_t p2mt;
     int unmap_shinfo = 0;
     unsigned long gpfn_new = xatp->gpfn;
@@ -4734,14 +4738,17 @@ static int xenmem_add_to_physmap_once(
     {
         if ( is_xen_heap_mfn(prev_mfn) )
             /* Xen heap frames are simply unhooked from this phys slot. */
-            guest_physmap_remove_page(d, gpfn_new, prev_mfn, PAGE_ORDER_4K);
+            rc = guest_physmap_remove_page(d, gpfn_new, prev_mfn, PAGE_ORDER_4K);
         else if ( xatp->space != XENMAPSPACE_shared_info )
             /* Normal domain memory is freed, to avoid leaking memory. */
-            guest_remove_page(d, gpfn_new);
+            rc = guest_remove_page(d, gpfn_new);
     }
     /* In the XENMAPSPACE_gmfn case we still hold a ref on the old page. */
     put_gfn(d, gpfn_new);
 
+    if ( rc )
+        goto put_both;
+
     /* Unmap from old location, if any. */
     gpfn = get_gpfn_from_mfn(mfn);
     ASSERT( gpfn != SHARED_M2P_ENTRY );
@@ -4749,11 +4756,13 @@ static int xenmem_add_to_physmap_once(
          xatp->space == XENMAPSPACE_gmfn_range )
         ASSERT( gpfn == gfn );
     if ( gpfn != INVALID_M2P_ENTRY ) {
-        guest_physmap_remove_page(d, gpfn, mfn, PAGE_ORDER_4K);
+        rc = guest_physmap_remove_page(d, gpfn, mfn, PAGE_ORDER_4K);
     }
     /* Map at new location. */
-    rc = guest_physmap_add_page(d, gpfn_new, mfn, PAGE_ORDER_4K);
+    if ( !rc )
+        rc = guest_physmap_add_page(d, gpfn_new, mfn, PAGE_ORDER_4K);
 
+ put_both:
     /* In the XENMAPSPACE_gmfn, we took a ref of the gfn at the top */
     if ( xatp->space == XENMAPSPACE_gmfn ||
          xatp->space == XENMAPSPACE_gmfn_range )
Index: xen-4.3.4/xen/arch/x86/mm/p2m.c
===================================================================
--- xen-4.3.4.orig/xen/arch/x86/mm/p2m.c
+++ xen-4.3.4/xen/arch/x86/mm/p2m.c
@@ -548,14 +548,18 @@ p2m_remove_page(struct p2m_domain *p2m,
                          p2m->default_access);
 }
 
-void
+int
 guest_physmap_remove_page(struct domain *d, unsigned long gfn,
                           unsigned long mfn, unsigned int page_order)
 {
+    int rc;
+
     struct p2m_domain *p2m = p2m_get_hostp2m(d);
     gfn_lock(p2m, gfn, page_order);
-    p2m_remove_page(p2m, gfn, mfn, page_order);
+    rc = p2m_remove_page(p2m, gfn, mfn, page_order);
     gfn_unlock(p2m, gfn, page_order);
+
+    return rc;
 }
 
 int
Index: xen-4.3.4/xen/common/grant_table.c
===================================================================
--- xen-4.3.4.orig/xen/common/grant_table.c
+++ xen-4.3.4/xen/common/grant_table.c
@@ -1530,6 +1530,7 @@ gnttab_transfer(
     for ( i = 0; i < count; i++ )
     {
         bool_t okay;
+        int rc;
 
         if (i && hypercall_preempt_check())
             return i;
@@ -1580,19 +1581,24 @@ gnttab_transfer(
             goto copyback;
         }
 
-        guest_physmap_remove_page(d, gop.mfn, mfn, 0);
+        rc = guest_physmap_remove_page(d, gop.mfn, mfn, 0);
         flush_tlb_mask(d->domain_dirty_cpumask);
+        if ( rc )
+        {
+            gdprintk(XENLOG_INFO,
+                     "gnttab_transfer: can't remove GFN %"PRI_xen_pfn" (MFN %lx)\n",
+                     gop.mfn, mfn);
+            gop.status = GNTST_general_error;
+            goto put_gfn_and_copyback;
+        }
 
         /* Find the target domain. */
         if ( unlikely((e = rcu_lock_domain_by_id(gop.domid)) == NULL) )
         {
-            put_gfn(d, gop.mfn);
             gdprintk(XENLOG_INFO, "gnttab_transfer: can't find domain %d\n",
                     gop.domid);
-            page->count_info &= ~(PGC_count_mask|PGC_allocated);
-            free_domheap_page(page);
             gop.status = GNTST_bad_domain;
-            goto copyback;
+            goto put_gfn_and_copyback;
         }
 
         if ( xsm_grant_transfer(XSM_HOOK, d, e) )
@@ -1601,6 +1607,8 @@ gnttab_transfer(
             gop.status = GNTST_permission_denied;
         unlock_and_copyback:
             rcu_unlock_domain(e);
+        put_gfn_and_copyback:
+            put_gfn(d, gop.mfn);
             page->count_info &= ~(PGC_count_mask|PGC_allocated);
             free_domheap_page(page);
             goto copyback;
@@ -1651,12 +1659,8 @@ gnttab_transfer(
                          "Transferee (d%d) has no headroom (tot %u, max %u)\n",
                          e->domain_id, e->tot_pages, e->max_pages);
 
-            rcu_unlock_domain(e);
-            put_gfn(d, gop.mfn);
-            page->count_info &= ~(PGC_count_mask|PGC_allocated);
-            free_domheap_page(page);
             gop.status = GNTST_general_error;
-            goto copyback;
+            goto unlock_and_copyback;
         }
 
         /* Okay, add the page to 'e'. */
@@ -1685,13 +1689,8 @@ gnttab_transfer(
 
             if ( drop_dom_ref )
                 put_domain(e);
-            rcu_unlock_domain(e);
-
-            put_gfn(d, gop.mfn);
-            page->count_info &= ~(PGC_count_mask|PGC_allocated);
-            free_domheap_page(page);
             gop.status = GNTST_general_error;
-            goto copyback;
+            goto unlock_and_copyback;
         }
 
         page_list_add_tail(page, &e->page_list);
Index: xen-4.3.4/xen/common/memory.c
===================================================================
--- xen-4.3.4.orig/xen/common/memory.c
+++ xen-4.3.4/xen/common/memory.c
@@ -165,8 +165,12 @@ int guest_remove_page(struct domain *d,
     mfn = mfn_x(get_gfn_query(d, gmfn, &p2mt)); 
     if ( unlikely(p2m_is_paging(p2mt)) )
     {
-        guest_physmap_remove_page(d, gmfn, mfn, 0);
+        rc = guest_physmap_remove_page(d, gmfn, mfn, 0);
         put_gfn(d, gmfn);
+
+        if ( rc )
+            return rc;
+
         /* If the page hasn't yet been paged out, there is an
          * actual page that needs to be released. */
         if ( p2mt == p2m_ram_paging_out )
@@ -223,18 +227,18 @@ int guest_remove_page(struct domain *d,
         return -ENXIO;
     }
 
-    if ( test_and_clear_bit(_PGT_pinned, &page->u.inuse.type_info) )
+    rc = guest_physmap_remove_page(d, gmfn, mfn, 0);
+
+    if ( !rc && test_and_clear_bit(_PGT_pinned, &page->u.inuse.type_info) )
         put_page_and_type(page);
             
-    if ( test_and_clear_bit(_PGC_allocated, &page->count_info) )
+    if ( !rc && test_and_clear_bit(_PGC_allocated, &page->count_info) )
         put_page(page);
 
-    guest_physmap_remove_page(d, gmfn, mfn, 0);
-
     put_page(page);
     put_gfn(d, gmfn);
 
-    return 0;
+    return rc;
 }
 
 static void decrease_reservation(struct memop_args *a)
@@ -630,7 +634,8 @@ static long memory_exchange(XEN_GUEST_HA
             gfn = mfn_to_gmfn(d, mfn);
             /* Pages were unshared above */
             BUG_ON(SHARED_M2P(gfn));
-            guest_physmap_remove_page(d, gfn, mfn, 0);
+            if ( guest_physmap_remove_page(d, gfn, mfn, 0) )
+                domain_crash(d);
             put_page(page);
         }
 
@@ -878,7 +883,7 @@ long do_memory_op(unsigned long cmd, XEN
         page = get_page_from_gfn(d, xrfp.gpfn, NULL, P2M_ALLOC);
         if ( page )
         {
-            guest_physmap_remove_page(d, xrfp.gpfn, page_to_mfn(page), 0);
+            rc = guest_physmap_remove_page(d, xrfp.gpfn, page_to_mfn(page), 0);
             put_page(page);
         }
         else
Index: xen-4.3.4/xen/include/asm-x86/p2m.h
===================================================================
--- xen-4.3.4.orig/xen/include/asm-x86/p2m.h
+++ xen-4.3.4/xen/include/asm-x86/p2m.h
@@ -496,7 +496,7 @@ static inline int guest_physmap_add_page
 }
 
 /* Remove a page from a domain's p2m table */
-void guest_physmap_remove_page(struct domain *d,
+int guest_physmap_remove_page(struct domain *d,
                                unsigned long gfn,
                                unsigned long mfn, unsigned int page_order);
 
Index: xen-4.3.4/xen/include/xen/mm.h
===================================================================
--- xen-4.3.4.orig/xen/include/xen/mm.h
+++ xen-4.3.4/xen/include/xen/mm.h
@@ -357,7 +357,7 @@ static inline unsigned int get_order_fro
 void scrub_one_page(struct page_info *);
 
 /* Returns 0 on success, or negative on error. */
-int guest_remove_page(struct domain *d, unsigned long gmfn);
+int __must_check guest_remove_page(struct domain *d, unsigned long gmfn);
 
 #define RAM_TYPE_CONVENTIONAL 0x00000001
 #define RAM_TYPE_RESERVED     0x00000002
