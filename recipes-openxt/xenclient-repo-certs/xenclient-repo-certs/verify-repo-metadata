#!/bin/sh
#
# Verifies the integrity of the metadata files in a XenClient repository.

PROD_CERT_FILE="/usr/share/xenclient/repo-certs/prod/cert.pem"
DEV_CERT_FILE="/usr/share/xenclient/repo-certs/dev/cert.pem"

VERIFY_PACKAGES=0

parse_args()
{
    ALLOW_DEV_KEY=0

    while getopts "dp" opt ; do
        case "$opt" in
        d) ALLOW_DEV_KEY=1 ;;
        p) VERIFY_PACKAGES=1 ;;
        \?) die "unknown option" ;;
        *) die "getopts error" ;;
        esac
    done

    shift "$(( OPTIND - 1 ))"
    if [ $# -ne 1 ] ; then
        usage
        exit 2
    fi

    REPOSITORY_DIR="$1"

    REPOSITORY_FILE="${REPOSITORY_DIR}/XC-REPOSITORY"
    PACKAGES_FILE="${REPOSITORY_DIR}/XC-PACKAGES"
    SIGNATURE_FILE="${REPOSITORY_DIR}/XC-SIGNATURE"
}

usage()
{
    cat <<EOF
Usage: $(basename $0) [-d] [-p] REPOSITORY_DIR

Verifies the integrity of the metadata files (XC-REPOSITORY, XC-PACKAGES and
XC-SIGNATURE) in a XenClient repository:

  - Checks that XC-PACKAGES matches the checksum listed in XC-REPOSITORY.
  - Checks that XC-REPOSITORY matches the signature in XC-SIGNATURE.

Note that this only verifies the integrity of the metadata files: it does not
verify that the packages in the repository match the checksums listed in
XC-PACKAGES.  The -p option enables package checksum checking.

The -d option should only be used for testing purposes. It allows signatures
created with the XenClient development signing certificate in addition to
signatures created with the XenClient production signing certificate.

Exit status:

    0  metadata is valid
    1  invalid signature
    2  metadata is not valid or another error occurred

EOF
}

get_hasher()
{
    case "${#1}" in
    64)
        echo "sha256sum"
        ;;
    96)
        echo "sha384sum"
        ;;
    128)
        echo "sha512sum"
        ;;
    *)
        die "invalid checksum length"
        ;;
    esac
}

verify_xc_packages_contents()
{
    local hasher
    while read n sz hash _ _ file _ ; do
        hasher=$( get_hasher "$hash" )
        [ "$sz" = "$( du -b "$REPOSITORY_DIR/$file" | awk '{print $1}' )" ] ||
            die "file size mismatch $n $file"
        [ "$( "$hasher" "$REPOSITORY_DIR/$file" | awk '{print $1}' )" = "$hash" ] ||
            die "hash mismatch $n $file"
    done < "$PACKAGES_FILE"

}

verify_xc_packages()
{
    local PACKAGES_CHECKSUM=$(sed -n 's/^packages://p' "${REPOSITORY_FILE}") ||
        die "error reading '${REPOSITORY_FILE}'"

    [ -n "${PACKAGES_CHECKSUM}" ] ||
        die "XC-PACKAGES checksum MISSING"

    local hasher="$( get_hasher "${PACKAGES_CHECKSUM}" )"
    local FILE_CHECKSUM=$( "$hasher" "${PACKAGES_FILE}" | cut -f1 -d' ') ||
        die "error calculating checksum of '${PACKAGES_FILE}'"

    [ -n "${FILE_CHECKSUM}" ] ||
        die "error calculating checksum of '${PACKAGES_FILE}'"

    [ "${FILE_CHECKSUM}" = "${PACKAGES_CHECKSUM}" ] ||
        die "XC-PACKAGES checksum NOT VALID"
}

verify_xc_repository()
{
    local TEMP_FILE=$(mktemp -t) ||
        die "error creating temporary file"

    local VALID=0

    if verify_signature "${PROD_CERT_FILE}" 2> "${TEMP_FILE}" ; then
        VALID=1
    elif [ "${ALLOW_DEV_KEY}" -eq 1 ] ; then
        if verify_signature "${DEV_CERT_FILE}" 2> "${TEMP_FILE}" ; then
            VALID=1
        fi
    fi

    if [ "${VALID}" -eq 0 ] ; then
        cat "${TEMP_FILE}" >&2
        rm -f "${TEMP_FILE}"
        echo "$(basename $0): signature NOT VALID" >&2
        exit 1
    fi

    rm -f "${TEMP_FILE}"
}

verify_signature()
{
    local CERT_FILE="$1"

    openssl smime -verify \
                  -in "${SIGNATURE_FILE}" \
                  -inform PEM \
                  -content "${REPOSITORY_FILE}" \
                  -CAfile "${CERT_FILE}" > /dev/null
}

die()
{
    echo "$(basename $0): $*" >&2
    exit 2
}

parse_args "$@"

# Verify XC-REPOSITORY against signature in XC-SIGNATURE.
verify_xc_repository

# Verify XC-PACKAGES against checksum in XC-REPOSITORY.
verify_xc_packages

if [ "$VERIFY_PACKAGES" -eq 1 ] ; then
    verify_xc_packages_contents
fi

exit 0
