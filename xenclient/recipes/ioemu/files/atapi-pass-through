diff --git a/Makefile b/Makefile
index 53601ad..cf7ceb6 100644
--- a/Makefile
+++ b/Makefile
@@ -267,8 +267,9 @@ endif
 test speed: all
 	$(MAKE) -C tests $@
 
+.PHONY: TAGS
 TAGS:
-	etags *.[ch] tests/*.[ch]
+	find "$(SRC_PATH)" -name '*.[hc]' -print0 | xargs -0 etags
 
 cscope:
 	rm -f ./cscope.*
diff --git a/block-raw-posix.c b/block-raw-posix.c
index 9a02d4f..6898d6e 100644
--- a/block-raw-posix.c
+++ b/block-raw-posix.c
@@ -97,20 +97,7 @@
    reopen it to see if the disk has been changed */
 #define FD_OPEN_TIMEOUT 1000
 
-typedef struct BDRVRawState {
-    int fd;
-    int type;
-    unsigned int lseek_err_cnt;
-#if defined(__linux__)
-    /* linux floppy specific */
-    int fd_open_flags;
-    int64_t fd_open_time;
-    int64_t fd_error_time;
-    int fd_got_error;
-    int fd_media_changed;
-#endif
-    uint8_t* aligned_buf;
-} BDRVRawState;
+#include "block/raw-posix.h"
 
 static int posix_aio_init(void);
 
@@ -979,6 +966,7 @@ static int hdev_open(BlockDriverState *bs, const char *filename, int flags)
 
     s->type = FTYPE_FILE;
 #if defined(__linux__)
+    printf("**** hdev_open(%s)\n", filename);
     if (strstart(filename, "/dev/cd", NULL)) {
         /* open will not fail even if no CD is inserted */
         open_flags |= O_NONBLOCK;
diff --git a/block.c b/block.c
index 05ff8cb..d27bfe3 100644
--- a/block.c
+++ b/block.c
@@ -419,8 +419,7 @@ int bdrv_open2(BlockDriverState *bs, const char *filename, int flags,
     }
     bs->drv = drv;
     bs->opaque = qemu_mallocz(drv->instance_size);
-    /* Note: for compatibility, we open disk image files as RDWR, and
-       RDONLY as fallback */
+
     if (!(flags & BDRV_O_FILE))
         open_flags = (flags & BDRV_O_ACCESS) | (flags & BDRV_O_CACHE_MASK);
     else
@@ -430,6 +429,7 @@ int bdrv_open2(BlockDriverState *bs, const char *filename, int flags,
         ret = drv->bdrv_open(bs, filename, open_flags & ~BDRV_O_RDWR);
         bs->read_only = 1;
     }
+
     if (ret < 0) {
         qemu_free(bs->opaque);
         bs->opaque = NULL;
@@ -945,6 +945,7 @@ void bdrv_set_type_hint(BlockDriverState *bs, int type)
 {
     bs->type = type;
     bs->removable = ((type == BDRV_TYPE_CDROM ||
+                      type == BDRV_TYPE_CDROM_PT ||
                       type == BDRV_TYPE_FLOPPY));
 }
 
@@ -1139,6 +1140,9 @@ void bdrv_info(void)
         case BDRV_TYPE_CDROM:
             term_printf("cdrom");
             break;
+        case BDRV_TYPE_CDROM_PT:
+            term_printf("cdrom-pt");
+            break;
         case BDRV_TYPE_FLOPPY:
             term_printf("floppy");
             break;
diff --git a/block.h b/block.h
index fc0afbb..6b1215a 100644
--- a/block.h
+++ b/block.h
@@ -110,9 +110,11 @@ int bdrv_flush_all(void);
 int bdrv_is_allocated(BlockDriverState *bs, int64_t sector_num, int nb_sectors,
 	int *pnum);
 
-#define BDRV_TYPE_HD     0
-#define BDRV_TYPE_CDROM  1
-#define BDRV_TYPE_FLOPPY 2
+#define BDRV_TYPE_HD            0
+#define BDRV_TYPE_CDROM         1
+#define BDRV_TYPE_FLOPPY        2
+#define BDRV_TYPE_CDROM_PT      3
+
 #define BIOS_ATA_TRANSLATION_AUTO   0
 #define BIOS_ATA_TRANSLATION_NONE   1
 #define BIOS_ATA_TRANSLATION_LBA    2
diff --git a/block/raw-posix.h b/block/raw-posix.h
new file mode 100644
index 0000000..f9bdee9
--- /dev/null
+++ b/block/raw-posix.h
@@ -0,0 +1,19 @@
+#ifndef BLOCK_RAW_POSIX_H
+# define BLOCK_RAW_POSIX_H
+
+typedef struct BDRVRawState {
+    int fd;
+    int type;
+    unsigned int lseek_err_cnt;
+#if defined(__linux__)
+    /* linux floppy specific */
+    int fd_open_flags;
+    int64_t fd_open_time;
+    int64_t fd_error_time;
+    int fd_got_error;
+    int fd_media_changed;
+#endif
+    uint8_t* aligned_buf;
+} BDRVRawState;
+
+#endif /* !BLOCK_RAW_POSIX_H */
diff --git a/hw/atapi-pt.c b/hw/atapi-pt.c
new file mode 100644
index 0000000..1876b53
--- /dev/null
+++ b/hw/atapi-pt.c
@@ -0,0 +1,1745 @@
+#include <scsi/sg.h>
+#include <utime.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/mman.h>
+#include "xen.h"
+
+/* Even when defined debugging is only enabled if /etc/debugcdrom exists */
+#define DEBUG_IDE_ATAPI_PT
+
+#define MSF_TO_FRAMES(M, S, F) (((M) * CD_SECS + (S)) * CD_FRAMES + (F))
+static int log_fd=-1;
+
+static int debug_fd=-1;
+static int debug_enabled=-1;
+#ifdef DEBUG_IDE_ATAPI_PT
+# define DEBUG_PRINTF(Args...) atapi_dprintf(Args)
+# define DEBUG_HEXDUMP(addr, count) atapi_dhexdump(addr, count)
+#else
+# define DEBUG_PRINTF(Args...)
+# define DEBUG_HEXDUMP(addr, count)
+#endif /* DEBUG_IDE_ATAPI_PT */
+
+
+#define IDE_ATAPI_PT_SHM_NAME_TEMPLATE "/xen-atapi-pt-status-%04x:%04x"
+#define IDE_ATAPI_PT_DEBUG_ENABLE_FILE   "/etc/debugcdrom"
+#define IDE_ATAPI_PT_DEBUG_FILE_TEMPLATE "/var/log/cdrom-%d.log"
+
+
+/* Debug, utility and error handling functions */
+#define min(x,y) ((x) > (y) ? (y) : (x))
+
+/* From Table 459 of the SFF8090 Ver. 4 (Mt. Fuji) draft standard.
+ * Code is (key << 16) | (asc << 8) | ascq
+ * Mask is a bit mask, since some codes span ranges of values.
+ */
+static const struct {
+    unsigned long code;
+    unsigned long mask;
+    const char * const text;
+} sense_data_texts[] = {
+    { 0x080000, 0xFF0000, "BLANK CHECK"},
+    { 0x000000, 0xFFFFFF, "NO ADDITIONAL SENSE INFORMATION"},
+    { 0x000001, 0xFFFFFF, "FILEMARK DETECTED"},
+    { 0x000002, 0xFFFFFF, "END-OF-PARTITION/MEDIUM DETECTED"},
+    { 0x000003, 0xFFFFFF, "SETMARK DETECTED"},
+    { 0x000004, 0xFFFFFF, "BEGINNING-OF-PARTITION/MEDIUM DETECTED"},
+    { 0x000005, 0xFFFFFF, "END-OF-DATA DETECTED"},
+    { 0x0B0006, 0xFFFFFF, "I/O PROCESS TERMINATED, PLAY OPERATION ABORTED"},
+    { 0x000011, 0xFFFFFF, "AUDIO PLAY OPERATION IN PROGRESS"},
+    { 0x000012, 0xFFFFFF, "AUDIO PLAY OPERATION PAUSED"},
+    { 0x000013, 0xFFFFFF, "AUDIO PLAY OPERATION SUCCESSFULLY COMPLETED"},
+    { 0x000014, 0xFFFFFF, "AUDIO PLAY OPERATION STOPPED DUE TO ERROR"},
+    { 0x000015, 0xFFFFFF, "NO CURRENT AUDIO STATUS TO RETURN"},
+    { 0x000016, 0xFFFFFF, "OPERATION IN PROGRESS"},
+    { 0x040017, 0xFFFFFF, "CLEANING REQUESTED"},
+    { 0x040100, 0xFFFFFF, "NO INDEX/SECTOR SIGNAL"},
+    { 0x030200, 0xFFFFFF, "NO SEEK COMPLETE"},
+    { 0x030300, 0xFFFFFF, "PERIPHERAL DEVICE WRITE FAULT"},
+    { 0x030301, 0xFFFFFF, "NO WRITE CURRENT"},
+    { 0x030302, 0xFFFFFF, "EXCESSIVE WRITE ERRORS"},
+    { 0x020400, 0xFFFFFF, "LOGICAL UNIT NOT READY, CAUSE NOT REPORTABLE"},
+    { 0x020401, 0xFFFFFF, "LOGICAL UNIT IS IN PROCESS OF BECOMING READY"},
+    { 0x020402, 0xFFFFFF, "LOGICAL UNIT NOT READY, INITIALIZING CMD. REQUIRED"},
+    { 0x020403, 0xFFFFFF, "LOGICAL UNIT NOT READY, MANUAL INTERVENTION REQUIRED"},
+    { 0x020404, 0xFFFFFF, "LOGICAL UNIT NOT READY, FORMAT IN PROGRESS"},
+    { 0x020405, 0xFFFFFF, "LOGICAL UNIT NOT READY, REBUILD IN PROGRESS"},
+    { 0x020406, 0xFFFFFF, "LOGICAL UNIT NOT READY, RECALCULATION IN PROGRESS"},
+    { 0x020407, 0xFFFFFF, "LOGICAL UNIT NOT READY, OPERATION IN PROGRESS"},
+    { 0x020408, 0xFFFFFF, "LOGICAL UNIT NOT READY, LONG WRITE IN PROGRESS"},
+    { 0x020500, 0xFFFFFF, "LOGICAL UNIT DOES NOT RESPOND TO SELECTION"},
+    { 0x020600, 0xFFFFFF, "NO REFERENCE POSITION FOUND (medium may be upside down)"},
+    { 0x050700, 0xFFFFFF, "MULTIPLE PERIPHERAL DEVICES SELECTED"},
+    { 0x040800, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION FAILURE"},
+    { 0x040801, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION TIME-OUT"},
+    { 0x040802, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION PARITY ERROR"},
+    { 0x040803, 0xFFFFFF, "LOGICAL UNIT COMMUNICATION CRC ERROR (ULTRA-DMA/32)"},
+    { 0x040900, 0xFFFFFF, "TRACK FOLLOWING ERROR"},
+    { 0x040901, 0xFFFFFF, "TRACKING SERVO FAILURE"},
+    { 0x040902, 0xFFFFFF, "FOCUS SERVO FAILURE"},
+    { 0x040903, 0xFFFFFF, "SPINDLE SERVO FAILURE"},
+    { 0x040904, 0xFFFFFF, "HEAD SELECT FAULT"},
+    { 0x060A00, 0xFFFFFF, "ERROR LOG OVERFLOW"},
+    { 0x010B00, 0xFFFFFF, "WARNING"},
+    { 0x010B01, 0xFFFFFF, "WARNING - SPECIFIED TEMPERATURE EXCEEDED"},
+    { 0x010B02, 0xFFFFFF, "WARNING - ENCLOSURE DEGRADED"},
+    { 0x030C00, 0xFFFFFF, "WRITE ERROR"},
+    { 0x030C01, 0xFFFFFF, "WRITE ERROR - RECOVERED WITH AUTO REALLOCATION"},
+    { 0x030C02, 0xFFFFFF, "WRITE ERROR - AUTO REALLOCATION FAILED"},
+    { 0x030C03, 0xFFFFFF, "WRITE ERROR - RECOMMEND REASSIGNMENT"},
+    { 0x030C04, 0xFFFFFF, "COMPRESSION CHECK MISCOMPARE ERROR"},
+    { 0x030C05, 0xFFFFFF, "DATA EXPANSION OCCURRED DURING COMPRESSION"},
+    { 0x030C06, 0xFFFFFF, "BLOCK NOT COMPRESSIBLE"},
+    { 0x030C07, 0xFFFFFF, "WRITE ERROR - RECOVERY NEEDED"},
+    { 0x030C08, 0xFFFFFF, "WRITE ERROR - RECOVERY FAILED"},
+    { 0x030C09, 0xFFFFFF, "WRITE ERROR - LOSS OF STREAMING"},
+    { 0x010C0A, 0xFFFFFF, "WRITE ERROR - PADDING BLOCKS ADDED"},
+    { 0x000D00, 0x00FFFF, "Reserved"},
+    { 0x000E00, 0x00FFFF, "Reserved"},
+    { 0x000F00, 0x00FFFF, "Reserved"},
+    { 0x031000, 0xFFFFFF, "ID CRC OR ECC ERROR"},
+    { 0x031100, 0xFFFFFF, "UNRECOVERED READ ERROR"},
+    { 0x031101, 0xFFFFFF, "READ RETRIES EXHAUSTED"},
+    { 0x031102, 0xFFFFFF, "ERROR TOO LONG TO CORRECT"},
+    { 0x031103, 0xFFFFFF, "MULTIPLE READ ERRORS"},
+    { 0x031104, 0xFFFFFF, "UNRECOVERED READ ERROR - AUTO REALLOCATE FAILED"},
+    { 0x031105, 0xFFFFFF, "L-EC UNCORRECTABLE ERROR"},
+    { 0x031106, 0xFFFFFF, "CIRC UNRECOVERED ERROR"},
+    { 0x031107, 0xFFFFFF, "RE-SYNCHRONIZATION ERROR"},
+    { 0x031108, 0xFFFFFF, "INCOMPLETE BLOCK READ"},
+    { 0x031109, 0xFFFFFF, "NO GAP FOUND"},
+    { 0x03110A, 0xFFFFFF, "MISCORRECTED ERROR"},
+    { 0x03110B, 0xFFFFFF, "UNRECOVERED READ ERROR - RECOMMEND REASSIGNMENT"},
+    { 0x03110C, 0xFFFFFF, "UNRECOVERED READ ERROR - RECOMMEND REWRITE THE DATA"},
+    { 0x03110D, 0xFFFFFF, "DE-COMPRESSION CRC ERROR"},
+    { 0x03110E, 0xFFFFFF, "CANNOT DECOMPRESS USING DECLARED ALGORITHM"},
+    { 0x03110F, 0xFFFFFF, "ERROR READING UPC/EAN NUMBER"},
+    { 0x031110, 0xFFFFFF, "ERROR READING ISRC NUMBER"},
+    { 0x0B1111, 0xFFFFFF, "READ ERROR - LOSS OF STREAMING"},
+    { 0x031200, 0xFFFFFF, "ADDRESS MARK NOT FOUND FOR ID FIELD"},
+    { 0x031300, 0xFFFFFF, "ADDRESS MARK NOT FOUND FOR DATA FIELD"},
+    { 0x031400, 0xFFFFFF, "RECORDED ENTITY NOT FOUND"},
+    { 0x031401, 0xFFFFFF, "RECORD NOT FOUND"},
+    { 0x031402, 0xFFFFFF, "FILEMARK OR SETMARK NOT FOUND"},
+    { 0x031403, 0xFFFFFF, "END-OF-DATA NOT FOUND"},
+    { 0x031404, 0xFFFFFF, "BLOCK SEQUENCE ERROR"},
+    { 0x031405, 0xFFFFFF, "RECORD NOT FOUND - RECOMMEND REASSIGNMENT"},
+    { 0x031406, 0xFFFFFF, "RECORD NOT FOUND - DATA AUTO-REALLOCATED"},
+    { 0x041500, 0xFFFFFF, "RANDOM POSITIONING ERROR"},
+    { 0x041501, 0xFFFFFF, "MECHANICAL POSITIONING ERROR"},
+    { 0x031502, 0xFFFFFF, "POSITIONING ERROR DETECTED BY READ OF MEDIUM"},
+    { 0x031600, 0xFFFFFF, "DATA SYNCHRONIZATION MARK ERROR"},
+    { 0x031601, 0xFFFFFF, "DATA SYNC ERROR - DATA REWRITTEN"},
+    { 0x031602, 0xFFFFFF, "DATA SYNC ERROR - RECOMMEND REWRITE"},
+    { 0x031603, 0xFFFFFF, "DATA SYNC ERROR - DATA AUTO-REALLOCATED"},
+    { 0x031604, 0xFFFFFF, "DATA SYNC ERROR - RECOMMEND REASSIGNMENT"},
+    { 0x011700, 0xFFFFFF, "RECOVERED DATA WITH NO ERROR CORRECTION APPLIED"},
+    { 0x011701, 0xFFFFFF, "RECOVERED DATA WITH RETRIES"},
+    { 0x011702, 0xFFFFFF, "RECOVERED DATA WITH POSITIVE HEAD OFFSET"},
+    { 0x011703, 0xFFFFFF, "RECOVERED DATA WITH NEGATIVE HEAD OFFSET"},
+    { 0x011704, 0xFFFFFF, "RECOVERED DATA WITH RETRIES AND/OR CIRC APPLIED"},
+    { 0x011705, 0xFFFFFF, "RECOVERED DATA USING PREVIOUS SECTOR ID"},
+    { 0x011706, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - DATA AUTO-REALLOCATED"},
+    { 0x011707, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - RECOMMEND REASSIGNMENT"},
+    { 0x011708, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - RECOMMEND REWRITE"},
+    { 0x011709, 0xFFFFFF, "RECOVERED DATA WITHOUT ECC - DATA REWRITTEN"},
+    { 0x011800, 0xFFFFFF, "RECOVERED DATA WITH ERROR CORRECTION APPLIED"},
+    { 0x011801, 0xFFFFFF, "RECOVERED DATA WITH ERROR CORR. & RETRIES APPLIED"},
+    { 0x011802, 0xFFFFFF, "RECOVERED DATA - DATA AUTO-REALLOCATED"},
+    { 0x011803, 0xFFFFFF, "RECOVERED DATA WITH CIRC"},
+    { 0x011804, 0xFFFFFF, "RECOVERED DATA WITH L-EC"},
+    { 0x011805, 0xFFFFFF, "RECOVERED DATA - RECOMMEND REASSIGNMENT"},
+    { 0x011806, 0xFFFFFF, "RECOVERED DATA - RECOMMEND REWRITE"},
+    { 0x011807, 0xFFFFFF, "RECOVERED DATA WITH ECC - DATA REWRITTEN"},
+    { 0x011808, 0xFFFFFF, "RECOVERED DATA WITH LINKING"},
+    { 0x031900, 0xFFFFFF, "DEFECT LIST ERROR"},
+    { 0x031901, 0xFFFFFF, "DEFECT LIST NOT AVAILABLE"},
+    { 0x031902, 0xFFFFFF, "DEFECT LIST ERROR IN PRIMARY LIST"},
+    { 0x031903, 0xFFFFFF, "DEFECT LIST ERROR IN GROWN LIST"},
+    { 0x051A00, 0xFFFFFF, "PARAMETER LIST LENGTH ERROR"},
+    { 0x041B00, 0xFFFFFF, "SYNCHRONOUS DATA TRANSFER ERROR"},
+    { 0x041C00, 0xFFFFFF, "DEFECT LIST NOT FOUND"},
+    { 0x041C01, 0xFFFFFF, "PRIMARY DEFECT LIST NOT FOUND"},
+    { 0x041C02, 0xFFFFFF, "GROWN DEFECT LIST NOT FOUND"},
+    { 0x0E1D00, 0xFFFFFF, "MISCOMPARE DURING VERIFY OPERATION"},
+    { 0x011E00, 0xFFFFFF, "RECOVERED ID WITH ECC CORRECTION"},
+    { 0x031F00, 0xFFFFFF, "PARTIAL DEFECT LIST TRANSFER"},
+    { 0x052000, 0xFFFFFF, "INVALID COMMAND OPERATION CODE"},
+    { 0x052100, 0xFFFFFF, "LOGICAL BLOCK ADDRESS OUT OF RANGE"},
+    { 0x052101, 0xFFFFFF, "INVALID ELEMENT ADDRESS"},
+    { 0x052102, 0xFFFFFF, "INVALID ADDRESS FOR WRITE"},
+    { 0x052200, 0xFFFFFF, "ILLEGAL FUNCTION (USE 20 00, 24 00, OR 26 00)"},
+    { 0x002300, 0x00FFFF, "Reserved"},
+    { 0x052400, 0xFFFFFF, "INVALID FIELD IN CDB"},
+    { 0x052500, 0xFFFFFF, "LOGICAL UNIT NOT SUPPORTED"},
+    { 0x052600, 0xFFFFFF, "INVALID FIELD IN PARAMETER LIST"},
+    { 0x052601, 0xFFFFFF, "PARAMETER NOT SUPPORTED"},
+    { 0x052602, 0xFFFFFF, "PARAMETER VALUE INVALID"},
+    { 0x052603, 0xFFFFFF, "THRESHOLD PARAMETERS NOT SUPPORTED"},
+    { 0x052604, 0xFFFFFF, "INVALID RELEASE OF ACTIVE PERSISTENT RESERVATION"},
+    { 0x072700, 0xFFFFFF, "WRITE PROTECTED"},
+    { 0x072701, 0xFFFFFF, "HARDWARE WRITE PROTECTED"},
+    { 0x072702, 0xFFFFFF, "LOGICAL UNIT SOFTWARE WRITE PROTECTED"},
+    { 0x072703, 0xFFFFFF, "ASSOCIATED WRITE PROTECT"},
+    { 0x072704, 0xFFFFFF, "PERSISTENT WRITE PROTECT"},
+    { 0x072705, 0xFFFFFF, "PERMANENT WRITE PROTECT"},
+    { 0x072706, 0xFFFFFF, "CONDITIONAL WRITE PROTECT"},
+    { 0x062800, 0xFFFFFF, "NOT READY TO READY CHANGE, MEDIUM MAY HAVE CHANGED"},
+    { 0x062801, 0xFFFFFF, "IMPORT OR EXPORT ELEMENT ACCESSED"},
+    { 0x062900, 0xFFFFFF, "POWER ON, RESET, OR BUS DEVICE RESET OCCURRED"},
+    { 0x062901, 0xFFFFFF, "POWER ON OCCURRED"},
+    { 0x062902, 0xFFFFFF, "SCSI BUS RESET OCCURRED"},
+    { 0x062903, 0xFFFFFF, "BUS DEVICE RESET FUNCTION OCCURRED"},
+    { 0x062904, 0xFFFFFF, "DEVICE INTERNAL RESET"},
+    { 0x062A00, 0xFFFFFF, "PARAMETERS CHANGED"},
+    { 0x062A01, 0xFFFFFF, "MODE PARAMETERS CHANGED"},
+    { 0x062A02, 0xFFFFFF, "LOG PARAMETERS CHANGED"},
+    { 0x062A03, 0xFFFFFF, "RESERVATIONS PREEMPTED"},
+    { 0x052B00, 0xFFFFFF, "COPY CANNOT EXECUTE SINCE HOST CANNOT DISCONNECT"},
+    { 0x052C00, 0xFFFFFF, "COMMAND SEQUENCE ERROR"},
+    { 0x052C01, 0xFFFFFF, "TOO MANY WINDOWS SPECIFIED"},
+    { 0x052C02, 0xFFFFFF, "INVALID COMBINATION OF WINDOWS SPECIFIED"},
+    { 0x052C03, 0xFFFFFF, "CURRENT PROGRAM AREA IS NOT EMPTY"},
+    { 0x052C04, 0xFFFFFF, "CURRENT PROGRAM AREA IS EMPTY"},
+    { 0x052C05, 0xFFFFFF, "PERSISTENT PREVENT CONFLICT"},
+    { 0x032D00, 0xFFFFFF, "OVERWRITE ERROR ON UPDATE IN PLACE"},
+    { 0x062E00, 0xFFFFFF, "INSUFFICIENT TIME FOR OPERATION"},
+    { 0x062F00, 0xFFFFFF, "COMMANDS CLEARED BY ANOTHER INITIATOR"},
+    { 0x023000, 0xFFFFFF, "INCOMPATIBLE MEDIUM INSTALLED"},
+    { 0x023001, 0xFFFFFF, "CANNOT READ MEDIUM - UNKNOWN FORMAT"},
+    { 0x023002, 0xFFFFFF, "CANNOT READ MEDIUM - INCOMPATIBLE FORMAT"},
+    { 0x053002, 0xFFFFFF, "CANNOT READ MEDIUM - INCOMPATIBLE FORMAT"},
+    { 0x023003, 0xFFFFFF, "CLEANING CARTRIDGE INSTALLED"},
+    { 0x053004, 0xFFFFFF, "CANNOT WRITE MEDIUM - UNKNOWN FORMAT"},
+    { 0x053005, 0xFFFFFF, "CANNOT WRITE MEDIUM - INCOMPATIBLE FORMAT"},
+    { 0x053006, 0xFFFFFF, "CANNOT FORMAT MEDIUM - INCOMPATIBLE MEDIUM"},
+    { 0x023007, 0xFFFFFF, "CLEANING FAILURE"},
+    { 0x053008, 0xFFFFFF, "CANNOT WRITE - APPLICATION CODE MISMATCH"},
+    { 0x053009, 0xFFFFFF, "CURRENT SESSION NOT FIXATED FOR APPEND"},
+    { 0x033100, 0xFFFFFF, "MEDIUM FORMAT CORRUPTED"},
+    { 0x033101, 0xFFFFFF, "FORMAT COMMAND FAILED"},
+    { 0x033102, 0xFFFFFF, "ZONED FORMATTING FAILED DUE TO SPARE LINKING"},
+    { 0x033200, 0xFFFFFF, "NO DEFECT SPARE LOCATION AVAILABLE"},
+    { 0x033201, 0xFFFFFF, "DEFECT LIST UPDATE FAILURE"},
+    { 0x033300, 0xFFFFFF, "TAPE LENGTH ERROR"},
+    { 0x043400, 0xFFFFFF, "ENCLOSURE FAILURE"},
+    { 0x043500, 0xFFFFFF, "ENCLOSURE SERVICES FAILURE"},
+    { 0x053501, 0xFFFFFF, "UNSUPPORTED ENCLOSURE FUNCTION"},
+    { 0x023502, 0xFFFFFF, "ENCLOSURE SERVICES UNAVAILABLE"},
+    { 0x043503, 0xFFFFFF, "ENCLOSURE SERVICES TRANSFER FAILURE"},
+    { 0x053504, 0xFFFFFF, "ENCLOSURE SERVICES TRANSFER REFUSED"},
+    { 0x033600, 0xFFFFFF, "RIBBON, INK, OR TONER FAILURE"},
+    { 0x013700, 0xFFFFFF, "ROUNDED PARAMETER"},
+    { 0x053800, 0xFFFFFF, "Reserved"},
+    { 0x053900, 0xFFFFFF, "SAVING PARAMETERS NOT SUPPORTED"},
+    { 0x023A00, 0xFFFFFF, "MEDIUM NOT PRESENT"},
+    { 0x023A01, 0xFFFFFF, "MEDIUM NOT PRESENT - TRAY CLOSED"},
+    { 0x023A02, 0xFFFFFF, "MEDIUM NOT PRESENT - TRAY OPEN"},
+    { 0x033B00, 0xFFFFFF, "SEQUENTIAL POSITIONING ERROR"},
+    { 0x033B01, 0xFFFFFF, "TAPE POSITION ERROR AT BEGINNING-OF-MEDIUM"},
+    { 0x033B02, 0xFFFFFF, "TAPE POSITION ERROR AT END-OF-MEDIUM"},
+    { 0x033B03, 0xFFFFFF, "TAPE OR ELECTRONIC VERTICAL FORMS UNIT NOT READY"},
+    { 0x043B04, 0xFFFFFF, "SLEW FAILURE"},
+    { 0x043B05, 0xFFFFFF, "PAPER JAM"},
+    { 0x033B06, 0xFFFFFF, "FAILED TO SENSE TOP-OF-FORM"},
+    { 0x033B07, 0xFFFFFF, "FAILED TO SENSE BOTTOM-OF-FORM"},
+    { 0x033B08, 0xFFFFFF, "REPOSITION ERROR"},
+    { 0x033B09, 0xFFFFFF, "READ PAST END OF MEDIUM"},
+    { 0x033B0A, 0xFFFFFF, "READ PAST BEGINNING OF MEDIUM"},
+    { 0x033B0B, 0xFFFFFF, "POSITION PAST END OF MEDIUM"},
+    { 0x033B0C, 0xFFFFFF, "POSITION PAST BEGINNING OF MEDIUM"},
+    { 0x053B0D, 0xFFFFFF, "MEDIUM DESTINATION ELEMENT FULL"},
+    { 0x053B0E, 0xFFFFFF, "MEDIUM SOURCE ELEMENT EMPTY"},
+    { 0x063B0F, 0xFFFFFF, "END OF MEDIUM REACHED"},
+    { 0x023B11, 0xFFFFFF, "MEDIUM MAGAZINE NOT ACCESSIBLE"},
+    { 0x063B12, 0xFFFFFF, "MEDIUM MAGAZINE REMOVED"},
+    { 0x063B13, 0xFFFFFF, "MEDIUM MAGAZINE INSERTED"},
+    { 0x063B14, 0xFFFFFF, "MEDIUM MAGAZINE LOCKED"},
+    { 0x063B15, 0xFFFFFF, "MEDIUM MAGAZINE UNLOCKED"},
+    { 0x043B16, 0xFFFFFF, "MECHANICAL POSITIONING OR CHANGER ERROR"},
+    { 0x003C00, 0x00FFFF, "Reserved"},
+    { 0x053D00, 0xFFFFFF, "INVALID BITS IN IDENTIFY MESSAGE"},
+    { 0x023E00, 0xFFFFFF, "LOGICAL UNIT HAS NOT SELF-CONFIGURED YET"},
+    { 0x043E01, 0xFFFFFF, "LOGICAL UNIT FAILURE"},
+    { 0x043E02, 0xFFFFFF, "TIMEOUT ON LOGICAL UNIT"},
+    { 0x063F00, 0xFFFFFF, "TARGET OPERATING CONDITIONS HAVE CHANGED"},
+    { 0x063F01, 0xFFFFFF, "MICROCODE HAS BEEN CHANGED"},
+    { 0x063F02, 0xFFFFFF, "CHANGED OPERATING DEFINITION"},
+    { 0x063F03, 0xFFFFFF, "INQUIRY DATA HAS CHANGED"},
+    { 0x044000, 0xFFFFFF, "RAM FAILURE (SHOULD USE 40 NN)"},
+    { 0x044000, 0xFFFF80, "DIAGNOSTIC FAILURE ON COMPONENT NN (80H-FFH)"},
+    { 0x044100, 0xFFFFFF, "DATA PATH FAILURE (SHOULD USE 40 NN)"},
+    { 0x044200, 0xFFFFFF, "POWER-ON OR SELF-TEST FAILURE (SHOULD USE 40 NN)"},
+    { 0x054300, 0xFFFFFF, "MESSAGE ERROR"},
+    { 0x044400, 0xFFFFFF, "INTERNAL TARGET FAILURE"},
+    { 0x0b4500, 0xFFFFFF, "SELECT OR RESELECT FAILURE"},
+    { 0x044600, 0xFFFFFF, "UNSUCCESSFUL SOFT RESET"},
+    { 0x044700, 0xFFFFFF, "SCSI PARITY ERROR"},
+    { 0x0b4800, 0xFFFFFF, "INITIATOR DETECTED ERROR MESSAGE RECEIVED"},
+    { 0x0b4900, 0xFFFFFF, "INVALID MESSAGE ERROR"},
+    { 0x044A00, 0xFFFFFF, "COMMAND PHASE ERROR"},
+    { 0x044B00, 0xFFFFFF, "DATA PHASE ERROR"},
+    { 0x044C00, 0xFFFFFF, "LOGICAL UNIT FAILED SELF-CONFIGURATION"},
+    { 0x0b4D00, 0xFFFF00, "TAGGED OVERLAPPED COMMANDS (NN = QUEUE TAG)"},
+    { 0x0B4E00, 0xFFFFFF, "OVERLAPPED COMMANDS ATTEMPTED"},
+    { 0x004F00, 0x00FFFF, "Reserved"},
+    { 0x005000, 0x00FFFF, "WRITE APPEND ERROR"},
+    { 0x005001, 0x00FFFF, "WRITE APPEND POSITION ERROR"},
+    { 0x005002, 0x00FFFF, "POSITION ERROR RELATED TO TIMING"},
+    { 0x035100, 0xFFFFFF, "ERASE FAILURE"},
+    { 0x035101, 0xFFFFFF, "ERASE FAILURE - Incomplete erase operation detected"},
+    { 0x035200, 0xFFFFFF, "CARTRIDGE FAULT"},
+    { 0x045300, 0xFFFFFF, "MEDIA LOAD OR EJECT FAILED"},
+    { 0x005301, 0x00FFFF, "UNLOAD TAPE FAILURE"},
+    { 0x025302, 0xFFFFFF, "MEDIUM REMOVAL PREVENTED"},
+    { 0x055302, 0xFFFFFF, "MEDIUM REMOVAL PREVENTED"},
+    { 0x005400, 0x00FFFF, "SCSI TO HOST SYSTEM INTERFACE FAILURE"},
+    { 0x055500, 0xFFFFFF, "SYSTEM RESOURCE FAILURE"},
+    { 0x005501, 0x00FFFF, "SYSTEM BUFFER FULL"},
+    { 0x005600, 0x00FFFF, "Reserved"},
+    { 0x035700, 0xFFFFFF, "UNABLE TO RECOVER TABLE-OF-CONTENTS"},
+    { 0x005800, 0x00FFFF, "GENERATION DOES NOT EXIST"},
+    { 0x005900, 0x00FFFF, "UPDATED BLOCK READ"},
+    { 0x065A00, 0xFFFFFF, "OPERATOR REQUEST OR STATE CHANGE INPUT"},
+    { 0x065A01, 0xFFFFFF, "OPERATOR MEDIUM REMOVAL REQUEST"},
+    { 0x065A02, 0xFFFFFF, "OPERATOR SELECTED WRITE PROTECT"},
+    { 0x065A03, 0xFFFFFF, "OPERATOR SELECTED WRITE PERMIT"},
+    { 0x065B00, 0xFFFFFF, "LOG EXCEPTION"},
+    { 0x065B01, 0xFFFFFF, "THRESHOLD CONDITION MET"},
+    { 0x065B02, 0xFFFFFF, "LOG COUNTER AT MAXIMUM"},
+    { 0x065B03, 0xFFFFFF, "LOG LIST CODES EXHAUSTED"},
+    { 0x065C00, 0xFFFFFF, "RPL STATUS CHANGE"},
+    { 0x065C01, 0xFFFFFF, "SPINDLES SYNCHRONIZED"},
+    { 0x035C02, 0xFFFFFF, "SPINDLES NOT SYNCHRONIZED"},
+    { 0x015D00, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED - Predicted Logical Unit Failure"},
+    { 0x015D01, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED - Predicted Media Failure"},
+    { 0x015D03, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED - Predicted Spare Area Exhaustion"},
+    { 0x015DFF, 0xFFFFFF, "FAILURE PREDICTION THRESHOLD EXCEEDED (FALSE)"},
+    { 0x065E00, 0xFFFFFF, "LOW POWER CONDITION ON"},
+    { 0x065E01, 0xFFFFFF, "IDLE CONDITION ACTIVATED BY TIMER"},
+    { 0x065E02, 0xFFFFFF, "STANDBY CONDITION ACTIVATED BY TIMER"},
+    { 0x065E03, 0xFFFFFF, "IDLE CONDITION ACTIVATED BY COMMAND"},
+    { 0x065E04, 0xFFFFFF, "STANDBY CONDITION ACTIVATED BY COMMAND"},
+    { 0x005F00, 0x00FFFF, "Reserved"},
+    { 0x046000, 0xFFFFFF, "LAMP FAILURE"},
+    { 0x036100, 0xFFFFFF, "VIDEO ACQUISITION ERROR"},
+    { 0x036101, 0xFFFFFF, "UNABLE TO ACQUIRE VIDEO"},
+    { 0x036102, 0xFFFFFF, "OUT OF FOCUS"},
+    { 0x046200, 0xFFFFFF, "SCAN HEAD POSITIONING ERROR"},
+    { 0x056300, 0xFFFFFF, "END OF USER AREA ENCOUNTERED ON THIS TRACK"},
+    { 0x056301, 0xFFFFFF, "PACKET DOES NOT FIT IN AVAILABLE SPACE"},
+    { 0x056400, 0xFFFFFF, "ILLEGAL MODE FOR THIS TRACK"},
+    { 0x056401, 0xFFFFFF, "INVALID PACKET SIZE"},
+    { 0x046500, 0xFFFFFF, "VOLTAGE FAULT"},
+    { 0x046600, 0xFFFFFF, "AUTOMATIC DOCUMENT FEEDER COVER UP"},
+    { 0x046601, 0xFFFFFF, "AUTOMATIC DOCUMENT FEEDER LIFT UP"},
+    { 0x046602, 0xFFFFFF, "DOCUMENT JAM IN AUTOMATIC DOCUMENT FEEDER"},
+    { 0x046603, 0xFFFFFF, "DOCUMENT MISS FEED AUTOMATIC IN DOCUMENT FEEDER"},
+    { 0x046700, 0xFFFFFF, "CONFIGURATION FAILURE"},
+    { 0x046701, 0xFFFFFF, "CONFIGURATION OF INCAPABLE LOGICAL UNITS FAILED"},
+    { 0x046702, 0xFFFFFF, "ADD LOGICAL UNIT FAILED"},
+    { 0x046703, 0xFFFFFF, "MODIFICATION OF LOGICAL UNIT FAILED"},
+    { 0x046704, 0xFFFFFF, "EXCHANGE OF LOGICAL UNIT FAILED"},
+    { 0x046705, 0xFFFFFF, "REMOVE OF LOGICAL UNIT FAILED"},
+    { 0x046706, 0xFFFFFF, "ATTACHMENT OF LOGICAL UNIT FAILED"},
+    { 0x046707, 0xFFFFFF, "CREATION OF LOGICAL UNIT FAILED"},
+    { 0x026800, 0xFFFFFF, "LOGICAL UNIT NOT CONFIGURED"},
+    { 0x046900, 0xFFFFFF, "DATA LOSS ON LOGICAL UNIT"},
+    { 0x046901, 0xFFFFFF, "MULTIPLE LOGICAL UNIT FAILURES"},
+    { 0x046902, 0xFFFFFF, "A PARITY/DATA MISMATCH"},
+    { 0x016A00, 0xFFFFFF, "INFORMATIONAL, REFER TO LOG"},
+    { 0x066B00, 0xFFFFFF, "STATE CHANGE HAS OCCURRED"},
+    { 0x066B01, 0xFFFFFF, "REDUNDANCY LEVEL GOT BETTER"},
+    { 0x066B02, 0xFFFFFF, "REDUNDANCY LEVEL GOT WORSE"},
+    { 0x036C00, 0xFFFFFF, "REBUILD FAILURE OCCURRED"},
+    { 0x036D00, 0xFFFFFF, "RECALCULATE FAILURE OCCURRED"},
+    { 0x046E00, 0xFFFFFF, "COMMAND TO LOGICAL UNIT FAILED"},
+    { 0x056F00, 0xFFFFFF, "COPY PROTECTION KEY EXCHANGE FAILURE - AUTHENTICATION FAILURE"},
+    { 0x056F01, 0xFFFFFF, "COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT PRESENT"},
+    { 0x056F02, 0xFFFFFF, "COPY PROTECTION KEY EXCHANGE FAILURE - KEY NOT ESTABLISHED"},
+    { 0x056F03, 0xFFFFFF, "READ OF SCRAMBLED SECTOR WITHOUT AUTHENTICATION"},
+    { 0x056F04, 0xFFFFFF, "MEDIA REGION CODE IS MISMATCHED TO LOGICAL UNIT REGION"},
+    { 0x056F05, 0xFFFFFF, "DRIVE REGION MUST BE PERMANENT/REGION RESET COUNT ERROR"},
+    { 0x037000, 0xFFFF00, "DECOMPRESSION EXCEPTION SHORT ALGORITHM ID OF NN"},
+    { 0x037100, 0xFFFFFF, "DECOMPRESSION EXCEPTION LONG ALGORITHM ID"},
+    { 0x037200, 0xFFFFFF, "SESSION FIXATION ERROR"},
+    { 0x037201, 0xFFFFFF, "SESSION FIXATION ERROR WRITING LEAD-IN"},
+    { 0x037202, 0xFFFFFF, "SESSION FIXATION ERROR WRITING LEAD-OUT"},
+    { 0x057203, 0xFFFFFF, "SESSION FIXATION ERROR - INCOMPLETE TRACK IN SESSION"},
+    { 0x057204, 0xFFFFFF, "EMPTY OR PARTIALLY WRITTEN RESERVED TRACK"},
+    { 0x057205, 0xFFFFFF, "NO MORE RZONE RESERVATIONS ARE ALLOWED"},
+    { 0x037300, 0xFFFFFF, "CD CONTROL ERROR"},
+    { 0x017301, 0xFFFFFF, "POWER CALIBRATION AREA ALMOST FULL"},
+    { 0x037302, 0xFFFFFF, "POWER CALIBRATION AREA IS FULL"},
+    { 0x037303, 0xFFFFFF, "POWER CALIBRATION AREA ERROR"},
+    { 0x037304, 0xFFFFFF, "PROGRAM MEMORY AREA/RMA UPDATE FAILURE"},
+    { 0x037305, 0xFFFFFF, "PROGRAM MEMORY AREA/RMA IS FULL"},
+    { 0x017306, 0xFFFFFF, "PROGRAM MEMORY AREA/RMA IS (almost) FULL"},
+    { 0x008000, 0x008000, "VENDOR SPECIFIC"},
+    { 0x000000, 0x000000, "Unrecognised sense data"}
+};
+
+
+
+#define IDE_ATAPI_PT_EXCLUSIVE_CD_FILE "/var/lock/xen-cd-exclusive"
+
+#define ATAPI_PT_LOCK_STATE_UNLOCKED		0
+#define ATAPI_PT_LOCK_STATE_LOCKED_BY_ME	1
+#define ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER	2
+
+static int we_have_lock = 0;
+
+static void ide_atapi_pt_ejected(void);
+
+static int get_lock_fd(void)
+{
+    static int lock_fd=-1;
+    if (lock_fd <0) {
+    	lock_fd = open( IDE_ATAPI_PT_EXCLUSIVE_CD_FILE, O_RDWR | O_CREAT, 0666);
+    }
+    return lock_fd;
+}
+
+
+static int get_atapi_pt_lock_state(void)
+{
+    struct flock lock = {0};
+    int lock_fd=get_lock_fd();
+
+    if (lock_fd<0) return ATAPI_PT_LOCK_STATE_UNLOCKED;
+
+    if (we_have_lock)
+        return ATAPI_PT_LOCK_STATE_LOCKED_BY_ME;
+
+    lock.l_type = F_WRLCK;
+    lock.l_whence = SEEK_SET;
+    lock.l_start = 0;
+    lock.l_len = 0;
+
+    fcntl(lock_fd, F_GETLK, &lock);
+
+    if (lock.l_type == F_UNLCK)
+	return ATAPI_PT_LOCK_STATE_UNLOCKED;
+
+    return ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER;
+}
+
+static int get_atapi_pt_lock(void)
+{
+    struct flock lock = {0};
+    int lock_fd=get_lock_fd();
+
+    if (lock_fd<0) return -1;
+
+    if (we_have_lock)
+	return 0;
+
+    lock.l_type = F_WRLCK;
+    lock.l_whence = SEEK_SET;
+    lock.l_start = 0;
+    lock.l_len = 0;
+
+    if (fcntl(lock_fd, F_SETLK, &lock))
+	return -1;
+
+    we_have_lock++;
+
+    return 0;
+}
+
+static int release_atapi_pt_lock(void)
+{
+    struct flock lock = {0};
+    int lock_fd=get_lock_fd();
+
+    if (lock_fd<0) return -1;
+
+    if (!we_have_lock)
+	return 0;
+
+    lock.l_type = F_UNLCK;
+    lock.l_whence = SEEK_SET;
+    lock.l_start = 0;
+    lock.l_len = 0;
+
+    if (fcntl(lock_fd, F_SETLK, &lock))
+	return -1;
+
+    we_have_lock = 0;
+
+    return 0;
+}
+
+
+static const char *atapi_sense_to_str(int key, int asc, int ascq)
+{
+    int i;
+    unsigned long code;
+
+    code = ((key & 0xFF) << 16) | ((asc & 0xFF) << 8) | (ascq & 0xFF);
+
+    for (i = 0; 1; ++i)
+      if ((code & sense_data_texts[i].mask) == sense_data_texts[i].code)
+            return sense_data_texts[i].text;
+}
+
+#ifdef DEBUG_IDE_ATAPI_PT
+static void atapi_dprintf(const char *fmt, ...)
+{
+    struct stat st;
+    char debugbuf[2048];
+    time_t t = time(NULL);
+    struct tm *tmp = localtime(&t);
+    struct timeval tv;
+    va_list args;
+    int l;
+    static int sol = 1;
+    if (debug_enabled == 0)
+        return;
+    if (debug_enabled < 0) {
+        if (stat(IDE_ATAPI_PT_DEBUG_ENABLE_FILE, &st) == 0)
+            debug_enabled = 1;
+        else {
+            debug_enabled = 0;
+            return;
+        }
+    }
+    if (debug_fd<0) {
+        sprintf(debugbuf, IDE_ATAPI_PT_DEBUG_FILE_TEMPLATE, domid);
+        debug_fd=open(debugbuf, O_WRONLY | O_CREAT | O_APPEND, 0666);
+    }
+    l = 0;
+    if (sol) {
+        gettimeofday(&tv, NULL);
+        l = snprintf(debugbuf, sizeof(debugbuf)-1, "[%02d:%02d:%02d.%03ld] ",
+                     tmp->tm_hour, tmp->tm_min, tmp->tm_sec, tv.tv_usec/1000);
+    }
+    va_start(args, fmt);
+    l += vsnprintf(debugbuf+l, sizeof(debugbuf)-1-l, fmt, args);
+    va_end(args);
+    if ((l>0) && debugbuf[l-1] == '\n') {
+        sol = 1;
+    } else {
+        sol = 0;
+    }
+    debugbuf[sizeof(debugbuf)-1] = '\0';
+    write(debug_fd, debugbuf, strlen(debugbuf));
+}
+
+static void atapi_dhexdump(const void* address, uint32_t len)
+{
+    const unsigned char* p = address;
+    int i, j;
+
+    for (i = 0; i < len; i += 16) {
+       for (j = 0; j < 16 && i + j < len; j++)
+           atapi_dprintf("%02x ", p[i + j]);
+       for (; j < 16; j++)
+           atapi_dprintf("   ");
+       atapi_dprintf(" ");
+       for (j = 0; j < 16 && i + j < len; j++)
+           atapi_dprintf("%c", (p[i + j] < ' ' || p[i + j] > 0x7e) ? '.' : p[i + j]);
+       atapi_dprintf("\n");
+    }
+}
+#endif /* DEBUG_IDE_ATAPI_PT */
+
+
+/* For each SCSI command we need to know up to 3 data sizes. These are:
+ * 1. The amount of data to send to the LU.
+ * 2. The size of the buffer provided for data sent back from the LU.
+ * 3. The amount of data the LU wanted to send.
+ *
+ * These are all measured in bytes.
+ *
+ * The table ide_atapi_cmd_data_sizes specifies how to determine these sizes for
+ * each SCSI command. Each size is given by:
+ *
+ *   constant + (base * block_size)
+ *
+ * where base is a value specified within the command data. This is specified in
+ * our table as an offset into the data at which the value starts and the size of
+ * the value, in bytes. All base value are assumed to be MSB first (lowest offset).
+ *
+ * The number of bytes forming the base value can only take values between 0 and 4
+ * inclusive, with 0 indicating that there is no base value.
+ *
+ * The amount of data to send to the LU and the size of the receiving buffer are
+ * both determined from the CDB. A value of 0 means that no data is transfered and
+ * a value of -1 indicates that the table entry is invalid (eg undefined command).
+ *
+ * The amount of data the LU wanted to return is determined from the returned data.
+ * A value of 0 is invalid and a value of -1 indicates that this size is the same
+ * as the receiving buffer size.
+ *
+ * A few commands are too complex for this scheme and so are handled by code in
+ * ide_atapi_pt_cmd() and ide_atapi_pt_do_sg_io().
+ */
+
+struct ide_atapi_pt_size_defn {
+    int len_const;
+    int len_offset;
+    int len_size;
+    int block_size;
+};
+
+#define CDFSZ CD_FRAMESIZE  // define a shorter name to make the following table easier to read
+
+/* The following per command information is taken from the SFF8090 (Mt. Fuji) standard,
+ * versions 4 and 7.
+ */
+static const struct {
+    struct ide_atapi_pt_size_defn dout_size;
+    struct ide_atapi_pt_size_defn buffer_size;
+    struct ide_atapi_pt_size_defn din_size;
+    const char *name;
+} atapi_pt_cmd_info[256] = {
+    // dout         buffer          din             name
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Test Unit Ready"},              // 0x00 GPCMD_TEST_UNIT_READY
+    {{-1}},{{-1}},                                                                   // 0x01-0x02
+    {{ 0, 0, 0, 0}, { 0, 4, 1, 1},  { 8, 7, 1, 1},  "Request Sense"},                // 0x03 GPCMD_REQUEST_SENSE
+    {{12, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Format Unit"},                  // 0x04 GPCMD_FORMAT_UNIT
+    {{-1}},{{-1}},  {{-1}},                                                          // 0x05-0x07
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x08-0x0f
+    {{-1}},{{-1}},                                                                   // 0x10-0x11
+    {{ 0, 0, 0, 0}, { 0, 4, 1, 1},  { 5, 4, 1, 1},  "Inquiry"},                      // 0x12 GPCMD_INQUIRY
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x13-0x1a
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Start/Stop Unit"},              // 0x1b GPCMD_START_STOP_UNIT
+    {{-1}},{{-1}},                                                                   // 0x1c-0x1d
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Prevent/Allow Medium Removal"}, // 0x1e GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL
+    {{-1}},{{-1}},  {{-1}},{{-1}},                                                   // 0x1f-0x22
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 4, 3, 1, 1},  "Read Format Capacities"},       // 0x23 GPCMD_READ_FORMAT_CAPACITIES
+    {{-1}},                                                                          // 0x24
+    {{ 0, 0, 0, 0}, { 8, 0, 0, 0},  { 8, 0, 0, 0},  "Read Cd/Dvd Capacity"},         // 0x25 GPCMD_READ_CDVD_CAPACITY
+    {{-1}},{{-1}},                                                                   // 0x26-0x27
+    {{ 0, 0, 0, 0}, {0,7,2,CDFSZ},  {-1, 0, 0, 0},  "Read 10"},                      // 0x28 GPCMD_READ_10
+    {{-1}},                                                                          // 0x29
+    {{0,7,2,CDFSZ}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Write 10"},                     // 0x2a GPCMD_WRITE_10
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Seek"},                         // 0x2b GPCMD_SEEK
+    {{-1}},{{-1}},                                                                   // 0x2c-0x2d
+    {{0,7,2,CDFSZ}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Write and Verify 10"},          // 0x2e GPCMD_WRITE_AND_VERIFY_10
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Verify 10"},                    // 0x2f GPCMD_VERIFY_10
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},                                          // 0x30-0x34
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Flush Cache"},                  // 0x35 GPCMD_FLUSH_CACHE
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},                                          // 0x36-0x3a
+    {{ 0, 6, 3, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Write Buffer"},                 // 0x3b GPCMD_WRITE_BUFFER
+    {{ 0, 0, 0, 0}, { 0, 6, 3, 1},  { 4, 1, 3, 1},  "Read Buffer"},                  // 0x3c GPCMD_READ_BUFFER
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},                                          // 0x3d-0x41
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 4, 2, 2, 1},  "Read Subchannel"},              // 0x42 GPCMD_READ_SUBCHANNEL
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 2, 0, 2, 1},  "Read Table of Contents"},       // 0x43 GPCMD_READ_TOC_PMA_ATIP
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 8, 0, 0, 0},  "Read Header"},                  // 0x44 GPCMD_READ_HEADER
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Play Audio 10"},                // 0x45 GPCMD_PLAY_AUDIO_10
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 4, 0, 4, 1},  "Get Configuration"},            // 0x46 GPCMD_GET_CONFIGURATION
+    {{ 0, 0, 0, 0}, {-1, 0, 0, 0},  {-1, 0, 0, 0},  "Play Audio MSF"},               // 0x47 GPCMD_PLAY_AUDIO_MSF
+    {{-1}},{{-1}},                                                                   // 0x48-0x49
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 2, 0, 2, 1},  "Get Event Status Notification"},// 0x4a GPCMD_GET_EVENT_STATUS_NOTIFICATION
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Pause/Resume"},                 // 0x4b GPCMD_PAUSE_RESUME
+    {{-1}},{{-1}},                                                                   // 0x4c-0x4d
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Stop Play/Scan"},               // 0x4e GPCMD_STOP_PLAY_SCAN
+    {{-1}},{{-1}},                                                                   // 0x4f-0x50
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 2, 0, 2, 1},  "Read Disc Info"},               // 0x51 GPCMD_READ_DISC_INFO
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 2, 0, 2, 1},  "Read Track Rzone Info"},        // 0x52 GPCMD_READ_TRACK_RZONE_INFO
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Reserve Rzone Track"},          // 0x53 GPCMD_RESERVE_RZONE_TRACK
+    {{ 0, 7, 2, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Send OPC"},                     // 0x54 GPCMD_SEND_OPC
+    {{ 0, 7, 2, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Mode Select 10"},               // 0x55 GPCMD_MODE_SELECT_10
+    {{-1}},{{-1}},                                                                   // 0x56-0x57
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Repair Rzone Track"},           // 0x58 GPCMD_REPAIR_RZONE_TRACK
+    {{-1}},                                                                          // 0x59
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 2, 0, 2, 1},  "Mode Sense 10"},                // 0x5a GPCMD_MODE_SENSE_10
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Close Track"},                  // 0x5b GPCMD_CLOSE_TRACK
+    {{ 0, 0, 0, 0}, { 0, 7, 2, 1},  { 2, 0, 2, 1},  "Read Buffer Capacity"},         // 0x5c GPCMD_READ_BUFFER_CAPACITY
+    {{ 0, 6, 3, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Send Cue Sheet"},               // 0x5d GPCMD_SEND_CUE_SHEET
+    {{-1}},{{-1}},                                                                   // 0x5e-0x5f
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x60-0x67
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x68-0x6f
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x70-0x77
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x78-0x7f
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x80-0x87
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x88-0x8f
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x90-0x97
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0x98-0x9f
+    {{-1}},                                                                          // 0xa0
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Blank"},                        // 0xa1 GPCMD_BLANK
+    {{ 0, 8, 2, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Send Event"},                   // 0xa2 GPCMD_SEND_EVENT
+    {{ 0, 8, 2, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Send Key"},                     // 0xa3 GPCMD_SEND_KEY
+    {{ 0, 0, 0, 0}, { 0, 8, 2, 1},  { 2, 0, 2, 1},  "Report Key"},                   // 0xa4 GPCMD_REPORT_KEY
+    {{-1}},                                                                          // 0xa5
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Load/Unload"},                  // 0xa6 GPCMD_LOAD_UNLOAD
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Set Read-ahead"},               // 0xa7 GPCMD_SET_READ_AHEAD
+    {{ 0, 0, 0, 0}, {0,6,4,CDFSZ},  {-1, 0, 0, 0},  "Read 12"},                      // 0xa8 GPCMD_READ_12
+    {{-1}},                                                                          // 0xa9
+    {{0,6,4,CDFSZ}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Write 12"},                     // 0xaa GPCMD_WRITE_12
+    {{-1}},                                                                          // 0xab
+    {{ 0, 0, 0, 0}, { 0, 8, 2, 1},  { 4, 0, 4, 1},  "Get Performance"},              // 0xac GPCMD_GET_PERFORMANCE
+    {{ 0, 0, 0, 0}, { 0, 8, 2, 1},  { 2, 0, 2, 1},  "Read DVD Structure"},           // 0xad GPCMD_READ_DVD_STRUCTURE
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xae-0xb5
+    {{ 0, 9, 2, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Set Streaming"},                // 0xb6 GPCMD_SET_STREAMING
+    {{-1}},{{-1}},                                                                   // 0xb7-0xb8
+    {{ 0, 0, 0, 0}, {-1, 0, 0, 0},  {-1, 0, 0, 0},  "Read CD MSF"},                  // 0xb9 GPCMD_READ_CD_MSF
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Scan"},                         // 0xba GPCMD_SCAN
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Set Speed"},                    // 0xbb GPCMD_SET_SPEED
+    {{ 0, 0, 0, 0}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Play CD"},                      // 0xbc GPCMD_PLAY_CD
+    {{ 0, 0, 0, 0}, { 0, 8, 2, 1},  { 8, 6, 2, 1},  "Mechanism Status"},             // 0xbd GPCMD_MECHANISM_STATUS
+    {{ 0, 0, 0, 0}, { 0, 6, 3, 1},  {-1, 0, 0, 0},  "Read CD"},                      // 0xbe GPCMD_READ_CD
+    {{ 0, 8, 2, 1}, { 0, 0, 0, 0},  { 0, 0, 0, 0},  "Send DVD Structure"},           // 0xbf GPCMD_SEND_DVD_STRUCTURE
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xc0-0xc7
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xc8-0xcf
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xd0-0xd7
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xd8-0xdf
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xe0-0xe7
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xe8-0xef
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},                   // 0xf0-0xf7
+    {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}},  {{-1}},{{-1}}                    // 0xf8-0xff
+};
+
+// TODO: check these commands:
+//# define GPCMD_PLAYAUDIO_TI		    0x48
+//# define GPCMD_GET_MEDIA_STATUS		    0xda
+
+static const char *atapi_cmd_to_str(uint8_t cmd)
+{
+    if(atapi_pt_cmd_info[cmd].name == NULL)
+        return "Unrecognised command";
+
+    return atapi_pt_cmd_info[cmd].name;
+}
+
+enum {
+    ide_atapi_pt_size_dout,    // size of dout
+    ide_atapi_pt_size_buffer,  // size of din buffer
+    ide_atapi_pt_size_din      // size of din data
+};
+
+static uint32_t ide_atapi_pt_get_data_size(int size_select, uint8_t command, uint8_t *data)
+{
+    const struct ide_atapi_pt_size_defn *size_defn;
+	uint32_t size;
+
+    switch(size_select)
+    {
+    case ide_atapi_pt_size_dout:
+        size_defn = &atapi_pt_cmd_info[command].dout_size;
+        break;
+
+    case ide_atapi_pt_size_buffer:
+        size_defn = &atapi_pt_cmd_info[command].buffer_size;
+        break;
+
+    case ide_atapi_pt_size_din:
+        size_defn = &atapi_pt_cmd_info[command].din_size;
+        break;
+
+    default:
+        DEBUG_PRINTF("Invalid data size selection %d\n", size_select);
+        assert(0);
+        return -1;
+    }
+
+    switch(size_defn->len_size)
+    {
+    case 0:
+        size = 0;
+        break;
+
+    case 1:
+        size = data[size_defn->len_offset];
+        break;
+
+    case 2:
+        size = ube16_to_cpu(data + size_defn->len_offset);
+        break;
+
+    case 3:
+        size = ube24_to_cpu(data + size_defn->len_offset);
+        break;
+
+    case 4:
+        size = ube32_to_cpu(data + size_defn->len_offset);
+        break;
+
+    default:
+        DEBUG_PRINTF("Invalid data size length in table, command 0x%02x, select %d, size %d\n",
+                     command, size_select, size_defn->len_size);
+        assert(0);
+        return -1;
+    }
+
+	size *= size_defn->block_size;
+	size += size_defn->len_const;
+	return size;
+}
+
+static void ide_atapi_pt_set_error(IDEState *s, int sense_key, int asc, int ascq, int error)
+{
+    static uint32_t  serial=0;
+
+    DEBUG_PRINTF("ide_atapi_pt_set_error serial 0x%x\n",serial++);
+    memset(&s->atapi_pt.sense, 0, 18);
+    *((char*)&s->atapi_pt.sense) = 0x70;
+    s->atapi_pt.sense.sense_key  = sense_key;
+    s->atapi_pt.sense.asc        = asc;
+    s->atapi_pt.sense.ascq       = ascq;
+    s->atapi_pt.sense.error_code = error;
+    s->atapi_pt.sense.add_sense_len = 10;
+
+    DEBUG_PRINTF("[\e[1;31mERROR\e[m] (%s)  sense: 0x%02x,%02x,%02x (%s)\n",
+                 atapi_cmd_to_str(s->atapi_pt.request[0]),
+                 s->atapi_pt.sense.sense_key,
+                 s->atapi_pt.sense.asc,
+                 s->atapi_pt.sense.ascq,
+                 atapi_sense_to_str(s->atapi_pt.sense.sense_key,
+                                    s->atapi_pt.sense.asc,
+                                    s->atapi_pt.sense.ascq));
+
+    s->status  = READY_STAT | ERR_STAT;
+    s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;
+    ide_set_irq(s);
+}
+
+static void ide_atapi_pt_error(IDEState *s)
+{
+    s->status  = READY_STAT | ERR_STAT;
+    s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;
+    ide_set_irq(s);
+}
+
+
+/* Thread worker function.
+ * This is the only function that knows which ioctl / other mechanism we use to
+ * send our command.
+ * This is the BSG SG_IO v4 implementation.
+ */
+static int ide_atapi_pt_do_dispatch(volatile IDEState *s)
+{
+    struct sg_io_v4 cmd;
+    BDRVRawState *raw_state = s->bs->opaque;
+    int r = 0;
+    int segment = 0;
+    uint32_t seg_offset = 0;
+    uint32_t lba;
+    uint16_t len;
+    uint8_t  request[ATAPI_PACKET_SIZE];
+    int      is_read = 0;
+    __u32    *cmd_len_p;
+    uint32_t *req_len_p;
+
+    memcpy(request, (void *)s->atapi_pt.request, sizeof(request));
+    is_read = (s->atapi_pt.dout_xfer_len > 0) ? 1 : 0;
+    cmd_len_p = is_read ? &cmd.dout_xfer_len : &cmd.din_xfer_len;
+    req_len_p = (uint32_t*)(is_read ? &s->atapi_pt.dout_xfer_len : &s->atapi_pt.din_xfer_len);
+
+    memset(&cmd, 0, sizeof(cmd));
+    cmd.guard            = 'Q';
+    cmd.protocol         = 0;
+    cmd.subprotocol      = 0;
+    cmd.request_len      = ATAPI_PACKET_SIZE;
+    cmd.request          = (uintptr_t)request;
+    cmd.response         = (uintptr_t)&s->atapi_pt.sense;
+    cmd.max_response_len = sizeof(s->atapi_pt.sense);
+    cmd.timeout          = s->atapi_pt.timeout;
+
+next_segment:
+    /* Send command and wait for reply, SG_IO ioctl*/
+    cmd.din_xferp        = (uintptr_t)(s->io_buffer + seg_offset);
+    cmd.dout_xferp       = (uintptr_t)(s->io_buffer + seg_offset);
+    *cmd_len_p           = min(s->atapi_pt.max_xfer_len, *req_len_p - seg_offset);
+
+    if (*req_len_p > s->atapi_pt.max_xfer_len)
+    {
+	if ((s->atapi_pt.request[0] == GPCMD_WRITE_10) ||
+	    (s->atapi_pt.request[0] == GPCMD_WRITE_AND_VERIFY_10) ||
+	    (s->atapi_pt.request[0] == GPCMD_READ_10)) {
+
+	    DEBUG_PRINTF("SPLITTING OVERLONG '%s' total: %d seg %d: %d, remaining: %d\n",
+			 atapi_cmd_to_str(s->atapi_pt.request[0]),
+			 *req_len_p,
+			 segment++,
+			 *cmd_len_p,
+			 *req_len_p - seg_offset - *cmd_len_p);
+
+	    /* Adjust LBA offset and length */
+	    lba = ube32_to_cpu((uint8_t*)s->atapi_pt.request + 2);
+	    lba += seg_offset / CD_FRAMESIZE;
+	    cpu_to_ube32(request + 2, lba);
+	    len = *cmd_len_p / CD_FRAMESIZE;
+	    cpu_to_ube16(request + 7, len);
+
+	    DEBUG_PRINTF("Adjust LBA from %d to %d, length from %d to %d\n",
+			 ube32_to_cpu((uint8_t*)s->atapi_pt.request + 2), lba,
+			 ube16_to_cpu((uint8_t*)s->atapi_pt.request + 7), len);
+	} else {
+	    DEBUG_PRINTF("FAILING OVERLONG '%s' (%d, max: %d)\n",
+			 atapi_cmd_to_str(s->atapi_pt.request[0]),
+			 *req_len_p,
+			 s->atapi_pt.max_xfer_len);
+	    ide_atapi_pt_set_error((IDEState*)s, SENSE_ILLEGAL_REQUEST,
+				   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+	    r = -1;
+	}
+    }
+    seg_offset += *cmd_len_p;
+
+    if(cmd.dout_xfer_len > 0)
+    {
+	DEBUG_PRINTF("Writing %d bytes      0x", cmd.dout_xfer_len);
+	DEBUG_HEXDUMP(s->io_buffer,
+		      cmd.dout_xfer_len < 0x40 ? cmd.dout_xfer_len : 0x40);
+    }
+    if(cmd.din_xfer_len > 0)
+    {
+	DEBUG_PRINTF("Read buffer %d bytes @ %p\n", cmd.din_xfer_len, cmd.din_xferp);
+    }
+
+    if (cmd.timeout != 15000)
+	DEBUG_PRINTF("Timeout %d msec\n", cmd.timeout);
+
+    if (!r)
+	r = ioctl(raw_state->fd, SG_IO, &cmd);
+
+    if(r)
+	s->atapi_pt.result = r;
+    else if(cmd.driver_status)
+	s->atapi_pt.result = cmd.driver_status;
+    else if(cmd.transport_status)
+	s->atapi_pt.result = cmd.transport_status;
+    else if(cmd.device_status)
+	s->atapi_pt.result = cmd.device_status;
+    else
+	s->atapi_pt.result = 0;
+
+    DEBUG_PRINTF("ioctl %d, driver %d, transport %d, device %d\n",
+		 r, cmd.driver_status, cmd.transport_status, cmd.device_status);
+
+    DEBUG_PRINTF("result %d req_len %d seg_offset %d last segment? %s\n",
+		 s->atapi_pt.result, *req_len_p, seg_offset, (*req_len_p > seg_offset) ? "no" : "yes");
+    if ((!s->atapi_pt.result) && (*req_len_p > seg_offset)) {
+	goto next_segment;
+    }
+
+    if(s->atapi_pt.result)
+    {
+	char *p = (char*)&s->atapi_pt.sense;
+
+	if((p[0] & 0x7F) == 0x70 || (p[0] & 0x7F) == 0x71)
+	{
+	    DEBUG_PRINTF("[\e[1;31mERROR\e[m] (%s)  sense: 0x%02x,%02x,%02x (%s)\n",
+			 atapi_cmd_to_str(s->atapi_pt.request[0]),
+			 s->atapi_pt.sense.sense_key,
+			 s->atapi_pt.sense.asc,
+			 s->atapi_pt.sense.ascq,
+			 atapi_sense_to_str(s->atapi_pt.sense.sense_key,
+					    s->atapi_pt.sense.asc,
+					    s->atapi_pt.sense.ascq));
+	} else if((p[0] & 0x7F) == 0x72 || (p[0] & 0x7F) == 0x73) {
+	    DEBUG_PRINTF("[\e[1;31mERROR SPC-3\e[m] (%s)  sense: 0x%02x,%02x,%02x (%s)\n",
+			 atapi_cmd_to_str(s->atapi_pt.request[0]),
+			 p[1] & 0xF, p[2], p[3],
+			 atapi_sense_to_str(p[1] & 0xF, p[2], p[3]));
+
+	    DEBUG_PRINTF("Suppressing error\n");
+	    s->atapi_pt.result = 0;
+	} else {
+	    DEBUG_PRINTF("[\e[1;31mERROR - unrecognised sense format\e[m] (%s)\n",
+			 atapi_cmd_to_str(s->atapi_pt.request[0]));
+	}
+    }
+    return r;
+}
+
+static time_t status_file_touched(const char *fn)
+{
+        int fd;
+	struct stat buf;
+
+	if ((stat(fn, &buf)) && errno != ENOENT) {
+                DEBUG_PRINTF("Error stating %s\n",fn);
+		return 0;
+	    }
+
+	return buf.st_ctime;
+}
+
+static void notify_media_event(ATAPIPTMediaState newstate, IDEState *s)
+{
+    s->atapi_pt.lastmediastate = newstate;
+    if (s->atapi_pt.shm->mediastate != newstate)
+    {
+	DEBUG_PRINTF("[ATAPI] signal media state change %d->%d\n",
+		     s->atapi_pt.shm->mediastate, newstate);
+    }
+    s->atapi_pt.shm->mediastate = newstate;
+}
+
+static void ide_atapi_pt_cmd_complete(void *arg) /* Mop up result*/
+{
+    IDEState *s = (IDEState *)arg;
+    uint8_t cmd_code = s->atapi_pt.request[0];
+    uint32_t din_actual;
+    static uint32_t serial = 0;
+    time_t etime, ntime;
+    int r;
+
+    assert(s);
+
+    /* Get return code of ioctl from worker thread's fd */
+    serial++;
+    DEBUG_PRINTF("ide_atapi_pt_cmd_complete serial 0x%x read status\n",serial);
+    recv(s->atapi_pt.sgio_dispatch_fd, &r, sizeof(int),0);
+    DEBUG_PRINTF("ide_atapi_pt_cmd_complete serial 0x%x - code %d\n",serial,r);
+
+    if(s->atapi_pt.result)
+    {
+	if (s->atapi_pt.sense.sense_key == 2 && s->atapi_pt.sense.asc == 0x3A)
+	{
+            /* No media, remove exclusivity lock */
+            ide_atapi_pt_ejected();
+	    /* Signal others that the media has been removed */
+	    notify_media_event(MEDIA_ABSENT, s);
+	}
+        ide_atapi_pt_error(s);
+        return;
+    }
+
+    if(s->atapi_pt.request[0] == GPCMD_TEST_UNIT_READY ||
+       s->atapi_pt.request[0] == GPCMD_REQUEST_SENSE ||
+       s->atapi_pt.request[0] == GPCMD_READ_CDVD_CAPACITY ||
+       s->atapi_pt.request[0] == GPCMD_READ_10 ||
+       s->atapi_pt.request[0] == GPCMD_READ_12 ||
+       s->atapi_pt.request[0] == GPCMD_READ_DISC_INFO)
+    {
+	/* If this didn't fail then a media is present,
+	 * make sure others know about this */
+	notify_media_event(MEDIA_PRESENT, s);
+    }
+
+    if(s->atapi_pt.request[0] == GPCMD_GET_EVENT_STATUS_NOTIFICATION)
+    {
+        if(s->io_buffer[2] == 4 && s->io_buffer[4] == 2)
+        {
+            /* This is a "new media" message, tell any other VMs */
+            DEBUG_PRINTF("[ATAPI] new media detected\n");
+
+	    notify_media_event(MEDIA_PRESENT, s);
+        }
+
+        if(s->io_buffer[2] == 4 && s->io_buffer[4] == 3)
+        {
+            /* This is a "media removed" message, tell any other VMs */
+            DEBUG_PRINTF("[ATAPI] media removed\n");
+
+	    notify_media_event(MEDIA_ABSENT, s);
+
+            /* Remove exclusivity lock */
+            ide_atapi_pt_ejected();
+        }
+
+        if((s->io_buffer[2] == 4 && s->io_buffer[4] == 0 && s->io_buffer[5] == 2) ||
+           (s->io_buffer[4] == 0 && s->io_buffer[5] == 0 &&
+            s->io_buffer[6] == 0 && s->io_buffer[7] == 0))
+        {
+            /* This is a no activity message we can hijack if we need to */
+	    if ((s->atapi_pt.lastmediastate != s->atapi_pt.shm->mediastate) &&
+		(s->atapi_pt.shm->mediastate != MEDIA_STATE_UNKNOWN))
+	    {
+		s->atapi_pt.lastmediastate = s->atapi_pt.shm->mediastate;
+
+		if (s->atapi_pt.lastmediastate == MEDIA_ABSENT)
+		{
+		    /* There's been an eject message that we haven't seen yet */
+		    DEBUG_PRINTF("[ATAPI] media removed message spotted\n");
+
+		    s->io_buffer[2] = 4;
+		    s->io_buffer[4] = 3;
+		    s->io_buffer[5] = 1;
+		    s->io_buffer[6] = 0;
+		    s->io_buffer[7] = 0;
+		} else {
+		    DEBUG_PRINTF("[ATAPI] new media message spotted\n");
+
+		    s->io_buffer[2] = 4;
+		    s->io_buffer[4] = 2;
+		    s->io_buffer[5] = 2;
+		    s->io_buffer[6] = 0;
+		    s->io_buffer[7] = 0;
+		}
+	    }
+	}
+    }
+
+    if(s->atapi_pt.din_xfer_len == 0)
+    {
+        // Nothing else to do
+        ide_atapi_cmd_ok(s);
+        return;
+    }
+
+    din_actual = ide_atapi_pt_get_data_size(ide_atapi_pt_size_din, cmd_code, s->io_buffer);
+
+    /* din_xfer_len is the size of the buffer provided for the din data,
+     * din_actual in the size of the data the LU tried to send to us. Either one
+     * may be bigger. */
+
+    if(s->atapi_pt.request[0] == GPCMD_READ_BUFFER)
+    {
+        switch(s->atapi_pt.request[1] & 7)
+        {
+        case 0: // data with header, as specified in atapi_data_sizes table
+            break;
+
+        case 2: // data only
+            din_actual = s->atapi_pt.din_xfer_len;
+            break;
+
+        case 3: // header only
+            din_actual = 4;
+            break;
+
+        case 1: // vendor specific
+        default:
+            DEBUG_PRINTF("\e[3;31mIllegal read buffer mode %d\e[m\n",
+                         s->io_buffer[1] & 7);
+            ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+            return;
+        }
+    }
+
+    if(din_actual == (__u32)-1)
+        din_actual = s->atapi_pt.din_xfer_len;
+
+    DEBUG_PRINTF("Read %d bytes of data (buffer size %d)\n",
+                 din_actual, s->atapi_pt.din_xfer_len);
+
+    if(s->atapi_pt.din_xfer_len >= 0x80 && din_actual >= 0x80)
+        DEBUG_HEXDUMP(s->io_buffer, 0x80);
+    else if(s->atapi_pt.din_xfer_len < din_actual)
+        DEBUG_HEXDUMP(s->io_buffer, s->atapi_pt.din_xfer_len);
+    else
+        DEBUG_HEXDUMP(s->io_buffer, din_actual);
+
+    ide_atapi_cmd_reply(s, din_actual, s->atapi_pt.din_xfer_len);
+}
+
+
+static void *ide_atapi_pt_sgio_worker_thread(void *arg)
+{
+    int r;
+    fd_set rfds;
+    sigset_t set;
+    static uint32_t serial=0;
+    volatile IDEState *s = (volatile IDEState *)arg;
+
+    if (sigfillset(&set)) { DEBUG_PRINTF("sigfillset\n"); return NULL; }
+    if (pthread_sigmask(SIG_BLOCK, &set, NULL)) { DEBUG_PRINTF("sigprocmask"); return NULL; }
+
+    FD_ZERO(&rfds);
+
+    for(;;) {
+	struct timeval zero={0};
+        recv(s->atapi_pt.sgio_worker_fd,&r,sizeof(int),0);
+
+	FD_SET(s->atapi_pt.sgio_worker_fd,&rfds);
+
+	while (select(s->atapi_pt.sgio_worker_fd+1,&rfds,NULL,NULL,&zero)==1) {
+        	recv(s->atapi_pt.sgio_worker_fd,&r,sizeof(int),MSG_DONTWAIT);
+	}
+
+	DEBUG_PRINTF("ide_atapi_pt_sgio_worker_thread: in serial 0x%x\n",serial++);
+	r=ide_atapi_pt_do_dispatch(s);
+	DEBUG_PRINTF("ide_atapi_pt_sgio_worker_thread: out serial 0x%x response %d\n",serial-1,r);
+
+        write(s->atapi_pt.sgio_worker_fd, &r, sizeof(int));
+    }
+return NULL;
+}
+
+
+/* Functions to manage worker thread */
+
+static int ide_atapi_pt_aio_flush(void *unused)
+{
+    return 0;
+}
+
+
+static void ide_atapi_pt_setup_sgio_thread(IDEState *s)
+{
+    int fds[2];
+    BDRVRawState *raw_state;
+    struct stat st;
+    char shm_name[1280];
+
+    if(socketpair(PF_UNIX,SOCK_DGRAM,0,fds) < 0) {
+	    fprintf(stderr, "atapi-pt failed to create socketpair: %m\n");
+	    exit(1);
+    }
+    s->atapi_pt.sgio_dispatch_fd = fds[0];
+    s->atapi_pt.sgio_worker_fd = fds[1];
+
+    if (pthread_create(&s->atapi_pt.sgio_thread, NULL, ide_atapi_pt_sgio_worker_thread, (void *)s))
+    {
+	    fprintf(stderr, "Create CD-ROM worker thread failed\n");
+	    exit(1);
+    }
+    qemu_aio_set_fd_handler(s->atapi_pt.sgio_dispatch_fd, ide_atapi_pt_cmd_complete, NULL, ide_atapi_pt_aio_flush, (void *)s);
+
+    /* Initialize the changed media shm */
+    raw_state = s->bs->opaque;
+    if (fstat(raw_state->fd, &st)) {
+	    fprintf(stderr, "Failed to fstat() the atapi-pt device (fd=%d): %s\n", raw_state->fd,
+		    strerror(errno));
+	    exit(1);
+    }
+    snprintf(shm_name, sizeof(shm_name)-1, IDE_ATAPI_PT_SHM_NAME_TEMPLATE,
+	     major(st.st_rdev), minor(st.st_rdev));
+    shm_name[sizeof(shm_name)-1] = '\0';
+    s->atapi_pt.shmfd = shm_open(shm_name, O_CREAT | O_RDWR, 0666);
+    if (s->atapi_pt.shmfd < 0) {
+	fprintf(stderr, "Open ATAPI-PT SHM failed: %s\n", strerror(errno));
+	exit(1);
+    }
+    ftruncate(s->atapi_pt.shmfd, sizeof(*(s->atapi_pt.shm)));
+    s->atapi_pt.shm = mmap(NULL, sizeof(*(s->atapi_pt.shm)), PROT_READ|PROT_WRITE,
+			   MAP_SHARED, s->atapi_pt.shmfd, 0);
+    if (s->atapi_pt.shm == MAP_FAILED) {
+	fprintf(stderr, "Map ATAPI-PT SHM failed: %s\n", strerror(errno));
+	exit(1);
+    }
+    s->atapi_pt.lastmediastate = s->atapi_pt.shm->mediastate;
+
+    /* Find out the maximum block size the hardware supports. This is needed for USB
+     * drives where it is 120kb (less than the normal 128kb for some reason)
+     */
+    if (ioctl(raw_state->fd, SG_GET_RESERVED_SIZE, &(s->atapi_pt.max_xfer_len))) {
+	fprintf(stderr, "ATAPI-PT get max xfer len failed: %s\n", strerror(errno));
+	exit(1);
+    }
+    s->atapi_pt.max_xfer_len = (s->atapi_pt.max_xfer_len + CD_FRAMESIZE-1) & ~(CD_FRAMESIZE-1);
+    DEBUG_PRINTF("ATAPI-PT max_xfer_len: %d (%d CD-sectors)\n", s->atapi_pt.max_xfer_len,
+		 s->atapi_pt.max_xfer_len/CD_FRAMESIZE);
+}
+
+static void ide_atapi_pt_do_sg_io(IDEState *s)
+{
+    static uint32_t serial=0;
+    int r='K';
+	DEBUG_PRINTF("ide_atapi_pt_do_sg_io 0x%x\n",serial++);
+
+    /* Poke worker thread to send command using SG_IO ioctl */
+    send(s->atapi_pt.sgio_dispatch_fd,&r,sizeof(int),MSG_NOSIGNAL);
+}
+
+
+/* Functions to fetch dout data from where-ever it comes from */
+
+static void ide_atapi_pt_dout_fetch_pio_done(IDEState *s)
+{
+    ide_transfer_stop(s);
+    ide_atapi_pt_do_sg_io(s);
+}
+
+static void ide_atapi_pt_dout_fetch_dma_done(void *opaque, int ret)
+{
+    BMDMAState *bm = opaque;
+    IDEState *s = bm->ide_if;
+    int i = 0;
+
+    if (ret < 0) {
+        ide_atapi_io_error(s, ret);
+        return;
+    }
+
+    i = dma_buf_rw(bm, 0);
+    ide_atapi_pt_do_sg_io(s);
+}
+
+static void ide_atapi_pt_wcmd(IDEState *s)
+{
+    if (s->atapi_dma)
+    {
+        /* DMA */
+        s->io_buffer_index = 0;
+        s->io_buffer_size = s->atapi_pt.dout_xfer_len;
+        ide_dma_start(s, ide_atapi_pt_dout_fetch_dma_done);
+        return;
+    }
+
+    /* PIO */
+    s->packet_transfer_size = s->atapi_pt.dout_xfer_len;
+    s->io_buffer_size = 0;
+    s->elementary_transfer_size = 0;
+    s->io_buffer_index = 0;
+    s->status |= DRQ_STAT;
+    s->status &= ~BUSY_STAT;
+    s->nsector = (s->nsector & ~7) &
+        ~ATAPI_INT_REASON_IO &
+        ~ATAPI_INT_REASON_CD;
+    ide_transfer_start(s, s->io_buffer, s->atapi_pt.dout_xfer_len,
+                       ide_atapi_pt_dout_fetch_pio_done);
+    ide_set_irq(s);
+    return;
+}
+
+
+/* Functions to handle atapi commands */
+
+/* Return value < 0 => illegal flag combo */
+static int ide_atapi_pt_read_cd_block_size(const uint8_t *io_buffer)
+{
+    int sector_type = (io_buffer[1] >> 2) & 7;
+    int error_flags = (io_buffer[9] >> 1) & 3;
+    int flags_bits = io_buffer[9] & ~7;
+    int block_size = 0;
+
+    // expected sector type
+    switch (sector_type)
+    {
+    case 0: // Any type
+        switch (flags_bits)
+        {
+        case 0x0: block_size = 0; break;
+        case 0x10: block_size = 2048; break;
+        case 0xf8: block_size = 2352; break;
+
+        default: return -1; // illegal
+        }
+        break;
+
+    case 1: // CD-DA
+        block_size = (flags_bits) ? 2352 : 0;
+        break;
+
+    case 2: // Mode 1
+        switch (flags_bits)
+        {
+        case 0x0: block_size = 0; break;
+        case 0x10:
+        case 0x50: block_size = 2048; break;
+        case 0x18:
+        case 0x58: block_size = 2336; break;
+        case 0x20:
+        case 0x60: block_size = 4; break;
+        case 0x30:
+        case 0x70:
+        case 0x78: block_size = 2052; break;
+        case 0x38: block_size = 2340; break;
+        case 0x40: block_size = 0; break;
+        case 0xa0: block_size = 16; break;
+        case 0xb0: block_size = 2064; break;
+        case 0xb8: block_size = 2352; break;
+        case 0xe0: block_size = 16; break;
+        case 0xf0: block_size = 2064; break;
+        case 0xf8: block_size = 2352; break;
+
+        default: return -1; // illegal
+        }
+        break;
+
+    case 3: // Mode 2
+        switch (flags_bits)
+        {
+        case 0x0: block_size = 0; break;
+        case 0x10:
+        case 0x50:
+        case 0x18:
+        case 0x58: block_size = 2336; break;
+        case 0x20:
+        case 0x60: block_size = 4; break;
+        case 0x30:
+        case 0x70:
+        case 0x78:
+        case 0x38: block_size = 2340; break;
+        case 0x40: block_size = 0; break;
+        case 0xa0: block_size = 16; break;
+        case 0xb0:
+        case 0xb8: block_size = 2352; break;
+        case 0xe0: block_size = 16; break;
+        case 0xf0:
+        case 0xf8: block_size = 2352; break;
+        default: return -1; // illegal
+        }
+        break;
+
+    case 4: // Mode 2 Form 1
+        switch (flags_bits)
+        {
+        case 0x0: block_size = 0; break;
+        case 0x10: block_size = 2048; break;
+        case 0x18: block_size = 2328; break;
+        case 0x20: block_size = 4; break;
+        case 0x40: block_size = 8; break;
+        case 0x50: block_size = 2056; break;
+        case 0x58: block_size = 2336; break;
+        case 0x60: block_size = 12; break;
+        case 0x70: block_size = 2060; break;
+        case 0x78: block_size = 2340; break;
+        case 0xa0: block_size = 16; break;
+        case 0xe0: block_size = 24; break;
+        case 0xf0: block_size = 2072; break;
+        case 0xf8: block_size = 2352; break;
+        default: return -1; // illegal
+        }
+        break;
+
+    case 5: // Mode 2 Form 2
+        switch (flags_bits)
+        {
+        case 0x0: block_size = 0; break;
+        case 0x10:
+        case 0x18: block_size = 2328; break;
+        case 0x20: block_size = 4; break;
+        case 0x40: block_size = 8; break;
+        case 0x50:
+        case 0x58: block_size = 2336; break;
+        case 0x60: block_size = 12; break;
+        case 0x70:
+        case 0x78: block_size = 2340; break;
+        case 0xa0: block_size = 16; break;
+        case 0xe0: block_size = 24; break;
+        case 0xf0:
+        case 0xf8: block_size = 2352; break;
+        default: return -1; // illegal
+        }
+        break;
+
+    default:
+        return -1;
+    }
+
+    switch (error_flags)
+    {
+    case 1: block_size += 294; break;
+    case 2: block_size += 296; break;
+    }
+
+    return block_size;
+}
+
+
+static void ide_atapi_pt_ejected(void)
+{
+    release_atapi_pt_lock();
+}
+
+
+static void ide_atapi_pt_cmd(IDEState *s)
+{
+    uint8_t cmd_code;
+    FILE *fp;
+    int block_size;
+
+    memcpy(s->atapi_pt.request, s->io_buffer, ATAPI_PACKET_SIZE);
+    cmd_code = s->atapi_pt.request[0];
+    s->atapi_pt.timeout = 15000;
+    s->status |= BUSY_STAT;
+
+    DEBUG_PRINTF("[ATAPI] sending command: 0x%02x (\e[0;32m%s\e[m) dma=%d domain=%d\n",
+                 cmd_code, atapi_cmd_to_str(cmd_code), s->atapi_dma, domid);
+    DEBUG_PRINTF("    ");
+    DEBUG_HEXDUMP(s->atapi_pt.request, ATAPI_PACKET_SIZE);
+
+    if(cmd_code == GPCMD_REQUEST_SENSE && ((char*)&s->atapi_pt.sense)[0] != 0)
+    {
+        int actual_size;
+
+        // send the previous sense command
+        DEBUG_PRINTF("=== REQUEST SENSE ===  "
+                     "atapi_cmd_error: sense=0x%x asc=0x%x error=0x%x\n",
+                     s->atapi_pt.sense.sense_key,
+                     s->atapi_pt.sense.asc,
+                     s->atapi_pt.sense.error_code);
+
+        int max_size = ide_atapi_pt_get_data_size(ide_atapi_pt_size_buffer,
+                                                  GPCMD_REQUEST_SENSE,
+                                                  s->atapi_pt.request);
+
+        int size = ide_atapi_pt_get_data_size(ide_atapi_pt_size_din,
+                                              GPCMD_REQUEST_SENSE,
+                                              (uint8_t *)&s->atapi_pt.sense);
+
+        memcpy(s->io_buffer, &s->atapi_pt.sense, sizeof(s->atapi_pt.sense));
+
+        actual_size = (size < max_size) ? size : max_size;
+        DEBUG_PRINTF("%d bytes sense data: 0x", actual_size);
+        DEBUG_HEXDUMP(s->io_buffer, actual_size);
+
+        ide_atapi_cmd_reply(s, size, max_size);
+
+	// Make sure we don't send the same reply again
+	*(char*)(&s->atapi_pt.sense) = '\0';
+	return;
+    }
+
+    // Make sure we don't re-use an old Request Sense reply
+    // if another command was processed in between
+    *(char*)(&s->atapi_pt.sense) = '\0';
+
+    s->atapi_pt.dout_xfer_len = ide_atapi_pt_get_data_size(ide_atapi_pt_size_dout,
+                                                           cmd_code, s->atapi_pt.request);
+
+    s->atapi_pt.din_xfer_len = ide_atapi_pt_get_data_size(ide_atapi_pt_size_buffer,
+                                                          cmd_code, s->atapi_pt.request);
+
+
+
+    if(get_atapi_pt_lock_state() == ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER)
+    {
+        uint8_t sense[18] = {0x70, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0x3a, 1, 0, 0, 0, 0};
+
+        if(cmd_code == GPCMD_INQUIRY && s->atapi_pt.request[1] == 0)
+        {
+            uint8_t inquiry_data[96] = {0x05, 0x80, 0x05, 0x32, 0x5b, 0x00, 0x00, 0x00, 0x48, 0x4c, 0x2d, 0x44, 0x54, 0x2d, 0x53, 0x54,
+                                        0x43, 0x44, 0x52, 0x57, 0x44, 0x56, 0x44, 0x20, 0x4d, 0x55, 0x31, 0x30, 0x4e, 0x20, 0x20, 0x20,
+                                        0x41, 0x31, 0x30, 0x36, 0x41, 0x42, 0x4c, 0x44, 0x41, 0x20, 0x20, 0x20, 0x30, 0x38, 0x2f, 0x31,
+                                        0x31, 0x2f, 0x31, 0x38, 0x20, 0x20, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+                                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+            DEBUG_PRINTF("Sending fake inquiry reply:\n");
+            DEBUG_HEXDUMP(inquiry_data, 96);
+            memcpy(s->io_buffer, inquiry_data, 96);
+            memset(&s->atapi_pt.sense, 0, sizeof(sense));
+            ide_atapi_cmd_reply(s, 96, s->atapi_pt.din_xfer_len);
+  	return;
+
+        }
+
+        if(cmd_code == GPCMD_MODE_SENSE_10)
+        {
+            sense[2] = 5;
+            sense[12] = 0x24;
+			sense[13] = 0;
+        }
+
+        DEBUG_PRINTF("Blocking command due to exclusivity lock\n");
+        memcpy(&s->atapi_pt.sense, sense, sizeof(sense));
+        ide_atapi_pt_set_error(s, sense[2], sense[12], sense[13], 0x70);
+	return;
+    }
+
+    // If we're not writing, flush cache is a no-op.
+    // Win VMs run it on shutdown, so
+    // we ignore this so other VM's don't get shafted
+    if (cmd_code == GPCMD_FLUSH_CACHE && !we_have_lock) {
+	DEBUG_PRINTF("Ignoring flush while not holding write lock\n");
+	ide_atapi_cmd_ok(s);
+	return;
+    }
+
+    /* Claim exclusive use if we're doing any kind of writing */
+    if(cmd_code == GPCMD_BLANK || cmd_code == GPCMD_CLOSE_TRACK || cmd_code == GPCMD_FLUSH_CACHE ||
+       cmd_code == GPCMD_FORMAT_UNIT || cmd_code == GPCMD_SEND_DVD_STRUCTURE || cmd_code == GPCMD_SEND_OPC ||
+       cmd_code == GPCMD_WRITE_10 || cmd_code == GPCMD_WRITE_12 || cmd_code == GPCMD_WRITE_AND_VERIFY_10 ||
+       cmd_code == GPCMD_WRITE_BUFFER)
+    {
+        if(s->bs->read_only) {
+	    DEBUG_PRINTF("Denying write command to read-only guest\n");
+	    ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+				   ASC_ILLEGAL_OPCODE, 0, 0x70);
+	    return;
+	}
+
+        DEBUG_PRINTF("Claiming exclusive lock while writing\n");
+	if (get_atapi_pt_lock()) {
+            DEBUG_PRINTF("Could not open CD exclusivity lock file for writing\n");
+#if 0
+	    // FIXME XXX - make this throw an error
+            memcpy(&s->atapi_pt.sense, sense, 18);
+            ide_atapi_pt_set_error(s, sense[2], sense[12], sense[13], 0x70);
+		return;
+#endif
+        }
+    }
+
+    if(cmd_code == GPCMD_START_STOP_UNIT) {
+	if ((s->atapi_pt.request[4] & 0x3) == 0x0) {
+	    // Stop motor command: Win7 guest sends this on shutdown,
+	    // we ignore this so other VM's don't get shafted
+	    DEBUG_PRINTF("Ignoring stop motor command\n");
+	    ide_atapi_cmd_ok(s);
+	    return;
+	}
+    }
+
+    //    DEBUG_PRINTF("dout_xfer_len = %d, buffer size = %d\n",
+    //                 s->atapi_pt.dout_xfer_len, s->atapi_pt.din_xfer_len);
+
+    /* A few commands need special attention */
+    switch(cmd_code)
+    {
+    case GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
+        // we don't allow locking, to prevent a VM from hogging the drive
+        DEBUG_PRINTF("Disallowing tray (un)lock\n");
+        ide_atapi_cmd_ok(s);
+        return;
+
+    case GPCMD_FLUSH_CACHE: // bigger timeout while flushing write cache
+        s->atapi_pt.timeout = 1000 * 60;
+        break;
+
+    case GPCMD_SEND_OPC: // bigger timeout while sending OPC
+        s->atapi_pt.timeout = 1000 * 60;
+        break;
+
+    case GPCMD_FORMAT_UNIT: // bigger timeout while formatting
+	if ((s->io_buffer[1] & 2) == 0) // and only if Immed bit not set
+	    s->atapi_pt.timeout = 1000 * 60 * 20;
+	// If Format Code == 7 the drive expects 4 more bytes.
+	// Not sure which spec that's defined in, the ATAPI spec
+	// requires it to be 1.
+	if ((s->atapi_pt.request[1] & 7) != 1) {
+	    s->atapi_pt.dout_xfer_len += 4;
+	}
+        break;
+
+    case GPCMD_BLANK: // bigger timeout while blanking
+        s->atapi_pt.timeout = 1000 * 60 * 80; // 80 mins
+        break;
+
+    case GPCMD_CLOSE_TRACK:
+        s->atapi_pt.timeout = 1000 * 60 * 5; // 5 mins
+        break;
+
+    case GPCMD_WRITE_BUFFER:
+        if((s->io_buffer[1] & 7) != 0 && // Combined header and data mode
+           (s->io_buffer[1] & 7) != 2)   // Data mode
+        {
+            DEBUG_PRINTF("\e[3;31mIllegal write buffer mode %d\e[m\n",
+                         s->io_buffer[1] & 7);
+            ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+	return;
+        }
+
+        break;
+
+    case GPCMD_WRITE_10:  // bigger timout while writing
+        s->atapi_pt.timeout = 1000 * 60;
+        break;
+
+    case GPCMD_READ_CD:
+        // We read blocks, not bytes
+        block_size = ide_atapi_pt_read_cd_block_size(s->io_buffer);
+        if(block_size < 0)
+        {
+            DEBUG_PRINTF("\e[3;31mIllegal read CD flags\e[m [1]=0x%02x, [9]=0x%02x\n",
+                         s->io_buffer[1], s->io_buffer[9]);
+            ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+            return;
+        }
+        s->atapi_pt.din_xfer_len *= block_size;
+        break;
+
+    case GPCMD_READ_CD_MSF:
+    {
+        // command fields
+        int starting_frame =
+            MSF_TO_FRAMES(s->io_buffer[3], s->io_buffer[4], s->io_buffer[5]);
+        int ending_frame =
+            MSF_TO_FRAMES(s->io_buffer[6], s->io_buffer[7], s->io_buffer[8]);
+        int block_count = ending_frame - starting_frame;
+
+        block_size = ide_atapi_pt_read_cd_block_size(s->io_buffer);
+        if(block_size < 0)
+        {
+            DEBUG_PRINTF("\e[3;31mIllegal read CD MSF flags\e[m [1]=0x%02x, [9]=0x%02x\n",
+                         s->io_buffer[1], s->io_buffer[9]);
+            ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+            return;
+        }
+        s->atapi_pt.din_xfer_len = block_count * block_size;
+        break;
+    }
+
+    case GPCMD_PLAY_AUDIO_MSF:
+    {
+        int starting_frame =
+            MSF_TO_FRAMES(s->io_buffer[3], s->io_buffer[4], s->io_buffer[5]);
+        int ending_frame =
+            MSF_TO_FRAMES(s->io_buffer[6], s->io_buffer[7], s->io_buffer[8]);
+        int block_count = ending_frame - starting_frame;
+        s->atapi_pt.din_xfer_len = block_count * CD_FRAMESIZE;
+        break;
+    }
+
+    case GPCMD_GET_PERFORMANCE:
+        // din_xfer_len is currently the max number of descriptors
+        switch(s->io_buffer[10])
+        {
+        case 0:  // performance
+            if((s->io_buffer[1] & 3) == 0)  // nominal performance, 16 byte descriptors
+                s->atapi_pt.din_xfer_len *= 16;
+            else  // exceptions, 6 byte descriptors
+                s->atapi_pt.din_xfer_len *= 6;
+
+            break;
+
+        case 1:  // unusable area
+            s->atapi_pt.din_xfer_len *= 8;  // 8 byte descriptors
+            break;
+
+        case 2:  // defect status
+            s->atapi_pt.din_xfer_len *= 2048;  // 2048 byte descriptors
+            break;
+
+        case 3:  // write speed
+            s->atapi_pt.din_xfer_len *= 16;  // 16 byte descriptors
+            break;
+
+        case 4:  // DBI data
+            s->atapi_pt.din_xfer_len *= 8;  // 8 byte descriptors
+            break;
+
+        default:
+            DEBUG_PRINTF("\e[3;31mReserved get performance type %d\e[m\n",
+                         s->io_buffer[10]);
+            ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                                   ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+	return;
+
+        }
+
+        s->atapi_pt.din_xfer_len += 8;  // 8 bytes of header
+        break;
+
+    case GPCMD_LOAD_UNLOAD:
+        if((s->io_buffer[4] & 3) == 2)  /* Eject command, remove exclusivity lock */
+            ide_atapi_pt_ejected();
+
+        break;
+    }
+
+    /* Clear sense data */
+    memset(&s->atapi_pt.sense, 0, sizeof(s->atapi_pt.sense));
+
+    if(s->atapi_pt.dout_xfer_len == (__u32)-1)
+    {
+        DEBUG_PRINTF("[\e[3;31mUNHANDLED SCSI COMMAND\e[m]\n");
+        DEBUG_PRINTF("    ");
+        DEBUG_HEXDUMP(s->atapi_pt.request, ATAPI_PACKET_SIZE);
+        ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+                               ASC_ILLEGAL_OPCODE, 0, 0x70);
+	return;
+    }
+
+    if(s->atapi_pt.dout_xfer_len > 0)
+    {
+        /* dout data is required, get it from somewhere */
+        ide_atapi_pt_wcmd(s);
+        return;
+    }
+
+    ide_atapi_pt_do_sg_io(s);
+
+}
+
diff --git a/hw/ide.c b/hw/ide.c
index 791666b..c8be324 100644
--- a/hw/ide.c
+++ b/hw/ide.c
@@ -22,6 +22,7 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
+
 #include "hw.h"
 #include "pc.h"
 #include "pci.h"
@@ -37,6 +38,16 @@
 #include "dma.h"
 #include "qemu-xen.h"
 
+#ifdef __linux__
+# include "block/raw-posix.h"
+
+# include <linux/cdrom.h>
+# include <linux/bsg.h>
+# include <linux/ioctl.h>
+#endif /* __linux__ */
+
+#include <assert.h>
+
 /* debug IDE devices */
 //#define DEBUG_IDE
 //#define DEBUG_IDE_ATAPI
@@ -222,83 +233,94 @@
 
 #define ATAPI_PACKET_SIZE 12
 
-/* The generic packet command opcodes for CD/DVD Logical Units,
- * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
-#define GPCMD_BLANK			    0xa1
-#define GPCMD_CLOSE_TRACK		    0x5b
-#define GPCMD_FLUSH_CACHE		    0x35
-#define GPCMD_FORMAT_UNIT		    0x04
-#define GPCMD_GET_CONFIGURATION		    0x46
-#define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
-#define GPCMD_GET_PERFORMANCE		    0xac
-#define GPCMD_INQUIRY			    0x12
-#define GPCMD_LOAD_UNLOAD		    0xa6
-#define GPCMD_MECHANISM_STATUS		    0xbd
-#define GPCMD_MODE_SELECT_10		    0x55
-#define GPCMD_MODE_SENSE_10		    0x5a
-#define GPCMD_PAUSE_RESUME		    0x4b
-#define GPCMD_PLAY_AUDIO_10		    0x45
-#define GPCMD_PLAY_AUDIO_MSF		    0x47
-#define GPCMD_PLAY_AUDIO_TI		    0x48
-#define GPCMD_PLAY_CD			    0xbc
-#define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
-#define GPCMD_READ_10			    0x28
-#define GPCMD_READ_12			    0xa8
-#define GPCMD_READ_CDVD_CAPACITY	    0x25
-#define GPCMD_READ_CD			    0xbe
-#define GPCMD_READ_CD_MSF		    0xb9
-#define GPCMD_READ_DISC_INFO		    0x51
-#define GPCMD_READ_DVD_STRUCTURE	    0xad
-#define GPCMD_READ_FORMAT_CAPACITIES	    0x23
-#define GPCMD_READ_HEADER		    0x44
-#define GPCMD_READ_TRACK_RZONE_INFO	    0x52
-#define GPCMD_READ_SUBCHANNEL		    0x42
-#define GPCMD_READ_TOC_PMA_ATIP		    0x43
-#define GPCMD_REPAIR_RZONE_TRACK	    0x58
-#define GPCMD_REPORT_KEY		    0xa4
-#define GPCMD_REQUEST_SENSE		    0x03
-#define GPCMD_RESERVE_RZONE_TRACK	    0x53
-#define GPCMD_SCAN			    0xba
-#define GPCMD_SEEK			    0x2b
-#define GPCMD_SEND_DVD_STRUCTURE	    0xad
-#define GPCMD_SEND_EVENT		    0xa2
-#define GPCMD_SEND_KEY			    0xa3
-#define GPCMD_SEND_OPC			    0x54
-#define GPCMD_SET_READ_AHEAD		    0xa7
-#define GPCMD_SET_STREAMING		    0xb6
-#define GPCMD_START_STOP_UNIT		    0x1b
-#define GPCMD_STOP_PLAY_SCAN		    0x4e
-#define GPCMD_TEST_UNIT_READY		    0x00
-#define GPCMD_VERIFY_10			    0x2f
-#define GPCMD_WRITE_10			    0x2a
-#define GPCMD_WRITE_AND_VERIFY_10	    0x2e
+#ifndef _LINUX_CDROM_H
+/*********************************************************************
+ * Generic Packet commands, MMC commands, and such
+ *********************************************************************/
+
+ /* The generic packet command opcodes for CD/DVD Logical Units,
+  * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
+# define GPCMD_BLANK			    0xa1
+# define GPCMD_CLOSE_TRACK		    0x5b
+# define GPCMD_FLUSH_CACHE		    0x35
+# define GPCMD_FORMAT_UNIT		    0x04
+# define GPCMD_GET_CONFIGURATION	    0x46
+# define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
+# define GPCMD_GET_PERFORMANCE		    0xac
+# define GPCMD_INQUIRY			    0x12
+# define GPCMD_LOAD_UNLOAD		    0xa6
+# define GPCMD_MECHANISM_STATUS		    0xbd
+# define GPCMD_MODE_SELECT_10		    0x55
+# define GPCMD_MODE_SENSE_10		    0x5a
+# define GPCMD_PAUSE_RESUME		    0x4b
+# define GPCMD_PLAY_AUDIO_10		    0x45
+# define GPCMD_PLAY_AUDIO_MSF		    0x47
+# define GPCMD_PLAY_AUDIO_TI		    0x48
+# define GPCMD_PLAY_CD			    0xbc
+# define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL 0x1e
+# define GPCMD_READ_10			    0x28
+# define GPCMD_READ_12			    0xa8
+# define GPCMD_READ_BUFFER		    0x3c
+# define GPCMD_READ_BUFFER_CAPACITY	    0x5c
+# define GPCMD_READ_CDVD_CAPACITY	    0x25
+# define GPCMD_READ_CD			    0xbe
+# define GPCMD_READ_CD_MSF		    0xb9
+# define GPCMD_READ_DISC_INFO		    0x51
+# define GPCMD_READ_DVD_STRUCTURE	    0xad
+# define GPCMD_READ_FORMAT_CAPACITIES	    0x23
+# define GPCMD_READ_HEADER		    0x44
+# define GPCMD_READ_TRACK_RZONE_INFO	    0x52
+# define GPCMD_READ_SUBCHANNEL		    0x42
+# define GPCMD_READ_TOC_PMA_ATIP	    0x43
+# define GPCMD_REPAIR_RZONE_TRACK	    0x58
+# define GPCMD_REPORT_KEY		    0xa4
+# define GPCMD_REQUEST_SENSE		    0x03
+# define GPCMD_RESERVE_RZONE_TRACK	    0x53
+# define GPCMD_SEND_CUE_SHEET		    0x5d
+# define GPCMD_SCAN			    0xba
+# define GPCMD_SEEK			    0x2b
+# define GPCMD_SEND_DVD_STRUCTURE	    0xbf
+# define GPCMD_SEND_EVENT		    0xa2
+# define GPCMD_SEND_KEY			    0xa3
+# define GPCMD_SEND_OPC			    0x54
+# define GPCMD_SET_READ_AHEAD		    0xa7
+# define GPCMD_SET_STREAMING		    0xb6
+# define GPCMD_START_STOP_UNIT		    0x1b
+# define GPCMD_STOP_PLAY_SCAN		    0x4e
+# define GPCMD_TEST_UNIT_READY		    0x00
+# define GPCMD_VERIFY_10		    0x2f
+# define GPCMD_WRITE_10			    0x2a
+# define GPCMD_WRITE_12			    0xaa
+# define GPCMD_WRITE_AND_VERIFY_10	    0x2e
+# define GPCMD_WRITE_BUFFER		    0x3b
 /* This is listed as optional in ATAPI 2.6, but is (curiously)
  * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
  * Table 377 as an MMC command for SCSi devices though...  Most ATAPI
  * drives support it. */
-#define GPCMD_SET_SPEED			    0xbb
+# define GPCMD_SET_SPEED			    0xbb
 /* This seems to be a SCSI specific CD-ROM opcode
  * to play data at track/index */
-#define GPCMD_PLAYAUDIO_TI		    0x48
+# define GPCMD_PLAYAUDIO_TI		    0x48
 /*
  * From MS Media Status Notification Support Specification. For
  * older drives only.
  */
-#define GPCMD_GET_MEDIA_STATUS		    0xda
-#define GPCMD_MODE_SENSE_6		    0x1a
+# define GPCMD_GET_MEDIA_STATUS		    0xda
 
 /* Mode page codes for mode sense/set */
-#define GPMODE_R_W_ERROR_PAGE		0x01
-#define GPMODE_WRITE_PARMS_PAGE		0x05
-#define GPMODE_AUDIO_CTL_PAGE		0x0e
-#define GPMODE_POWER_PAGE		0x1a
-#define GPMODE_FAULT_FAIL_PAGE		0x1c
-#define GPMODE_TO_PROTECT_PAGE		0x1d
-#define GPMODE_CAPABILITIES_PAGE	0x2a
-#define GPMODE_ALL_PAGES		0x3f
-/* Not in Mt. Fuji, but in ATAPI 2.6 -- depricated now in favor
+# define GPMODE_VENDOR_PAGE		0x00
+# define GPMODE_R_W_ERROR_PAGE		0x01
+# define GPMODE_WRITE_PARMS_PAGE		0x05
+# define GPMODE_WCACHING_PAGE		0x08
+# define GPMODE_AUDIO_CTL_PAGE		0x0e
+# define GPMODE_POWER_PAGE		0x1a
+# define GPMODE_FAULT_FAIL_PAGE		0x1c
+# define GPMODE_TO_PROTECT_PAGE		0x1d
+# define GPMODE_CAPABILITIES_PAGE	0x2a
+# define GPMODE_ALL_PAGES		0x3f
+/* Not in Mt. Fuji, but in ATAPI 2.6 -- deprecated now in favor
  * of MODE_SENSE_POWER_PAGE */
-#define GPMODE_CDROM_PAGE		0x0d
+# define GPMODE_CDROM_PAGE		0x0d
 
 /*
  * Based on values from <linux/cdrom.h> but extending CD_MINS
@@ -310,10 +332,13 @@
  */
 
 /* Some generally useful CD-ROM information */
-#define CD_MINS                       80 /* max. minutes per CD */
-#define CD_SECS                       60 /* seconds per minute */
-#define CD_FRAMES                     75 /* frames per second */
-#define CD_FRAMESIZE                2048 /* bytes per frame, "cooked" mode */
+# define CD_MINS                       80 /* max. minutes per CD */
+# define CD_SECS                       60 /* seconds per minute */
+# define CD_FRAMES                     75 /* frames per second */
+# define CD_FRAMESIZE                2048 /* bytes per frame, "cooked" mode */
+
+#endif /* !_LINUX_CDROM_H */
+
 #define CD_MAX_BYTES       (CD_MINS * CD_SECS * CD_FRAMES * CD_FRAMESIZE)
 #define CD_MAX_SECTORS     (CD_MAX_BYTES / 512)
 
@@ -352,12 +377,15 @@
 #define MMC_PROFILE_HDDVD_RW_DL         0x005A
 #define MMC_PROFILE_INVALID             0xFFFF
 
+
 #define ATAPI_INT_REASON_CD             0x01 /* 0 = data transfer */
 #define ATAPI_INT_REASON_IO             0x02 /* 1 = transfer to the host */
 #define ATAPI_INT_REASON_REL            0x04
 #define ATAPI_INT_REASON_TAG            0xf8
 
 /* same constants as bochs */
+#define ASC_NONE                             0x00
+#define ASC_READ_ERROR                       0x11
 #define ASC_ILLEGAL_OPCODE                   0x20
 #define ASC_LOGICAL_BLOCK_OOR                0x21
 #define ASC_INV_FIELD_IN_CMD_PACKET          0x24
@@ -372,15 +400,63 @@
 #define CFA_INVALID_ADDRESS     0x21
 #define CFA_ADDRESS_OVERFLOW    0x2f
 
-#define SENSE_NONE            0
-#define SENSE_NOT_READY       2
-#define SENSE_ILLEGAL_REQUEST 5
-#define SENSE_UNIT_ATTENTION  6
+/* Sense keys */
+#define SENSE_NONE             0
+#define SENSE_RECOVERED_ERROR  1
+#define SENSE_NOT_READY        2
+#define SENSE_MEDIUM_ERROR     3
+#define SENSE_HARDWARE_ERROR   4
+#define SENSE_ILLEGAL_REQUEST  5
+#define SENSE_UNIT_ATTENTION   6
+#define SENSE_DATA_PROTECT     7
+#define SENSE_BLANK_CHECK      8
+#define SENSE_VENDOR_SPECIFIC  9
+#define SENSE_COPY_ABORTED     10
+#define SENSE_ABORTED_COMMAND  11
+#define SENSE_VOLUME_OVERFLOW  13
+#define SENSE_MISCOMPARE       14
+
+#define IO_BUFFER_MAX_SIZE      (IDE_DMA_BUF_SECTORS * 512 + 4)
 
 struct IDEState;
 
 typedef void EndTransferFunc(struct IDEState *);
 
+#ifdef __linux__
+typedef enum {
+	MEDIA_STATE_UNKNOWN = 0x0,
+	MEDIA_PRESENT = 0x1,
+	MEDIA_ABSENT = 0x2
+} ATAPIPTMediaState;
+
+typedef struct ATAPIPTShm
+{
+    ATAPIPTMediaState    mediastate;
+} ATAPIPTShm;
+
+typedef struct ATAPIPassThroughState
+{
+    uint8_t              request[ATAPI_PACKET_SIZE];
+    struct request_sense sense;
+    uint32_t             dout_xfer_len;
+    uint32_t             din_xfer_len;
+    uint32_t             timeout;  /* in milliseconds */
+    uint32_t             result;   /* 0 => OK */
+
+    int                  shmfd;
+    ATAPIPTShm *         volatile shm;
+    ATAPIPTMediaState    lastmediastate;
+
+    uint32_t             max_xfer_len;
+
+    pthread_t            sgio_thread;
+    pthread_mutex_t      sgio_mutex;
+    pthread_cond_t       sgio_cv;
+    int                  sgio_worker_fd;
+    int                  sgio_dispatch_fd;
+} ATAPIPassThroughState;
+#endif /* __linux__ */
+
 /* NOTE: IDEState represents in fact one drive */
 typedef struct IDEState {
     /* ide config */
@@ -430,6 +506,10 @@ typedef struct IDEState {
     int lba;
     int cd_sector_size;
     int atapi_dma; /* true if dma is requested for the packet cmd */
+#ifdef __linux__
+    ATAPIPassThroughState atapi_pt;
+#endif /* __linux__ */
+    void (*atapi_cmd)(struct IDEState *); // the ATAPI cmd handler
     /* ATA DMA state */
     int io_buffer_size;
     QEMUSGList sg;
@@ -941,6 +1021,8 @@ static inline void ide_set_irq(IDEState *s)
         if (bm) {
             bm->status |= BM_STATUS_INT;
         }
+        //        if (s->is_cdrom)
+        //            puts("@@@@@@@@ CDROM IRQ");
         qemu_irq_raise(s->irq);
     }
 }
@@ -1322,9 +1404,9 @@ static void ide_sector_write(IDEState *s)
            that at the expense of slower write performances. Use this
            option _only_ to install Windows 2000. You must disable it
            for normal use. */
-        qemu_mod_timer(s->sector_write_timer, 
+        qemu_mod_timer(s->sector_write_timer,
                        qemu_get_clock(vm_clock) + (ticks_per_sec / 1000));
-    } else 
+    } else
 #endif
     {
         ide_set_irq(s);
@@ -1500,6 +1582,13 @@ static inline int ube16_to_cpu(const uint8_t *buf)
     return (buf[0] << 8) | buf[1];
 }
 
+#ifdef __linux__ /* only atapi-pt uses it so let's avoid unused warning */
+static inline int ube24_to_cpu(const uint8_t *buf)
+{
+    return (buf[0] << 16) | (buf[1] << 8) | buf[2];
+}
+#endif /* __linux */
+
 static inline int ube32_to_cpu(const uint8_t *buf)
 {
     return (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];
@@ -1568,12 +1657,14 @@ static void ide_atapi_io_error(IDEState *s, int ret)
 static void ide_atapi_cmd_reply_end(IDEState *s)
 {
     int byte_count_limit, size, ret;
+
 #ifdef DEBUG_IDE_ATAPI
     printf("reply: tx_size=%d elem_tx_size=%d index=%d\n",
            s->packet_transfer_size,
            s->elementary_transfer_size,
            s->io_buffer_index);
 #endif
+
     if (s->packet_transfer_size <= 0) {
         /* end of transfer */
         ide_transfer_stop(s);
@@ -1583,63 +1674,65 @@ static void ide_atapi_cmd_reply_end(IDEState *s)
 #ifdef DEBUG_IDE_ATAPI
         printf("status=0x%x\n", s->status);
 #endif
-    } else {
-        /* see if a new sector must be read */
-        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {
-            ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);
-            if (ret < 0) {
-                ide_transfer_stop(s);
-                ide_atapi_io_error(s, ret);
-                return;
-            }
-            s->lba++;
-            s->io_buffer_index = 0;
+        return;
+    }
+
+    /* see if a new sector must be read */
+    if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {
+        ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);
+        if (ret < 0) {
+            ide_transfer_stop(s);
+            ide_atapi_io_error(s, ret);
+            return;
         }
-        if (s->elementary_transfer_size > 0) {
-            /* there are some data left to transmit in this elementary
-               transfer */
-            size = s->cd_sector_size - s->io_buffer_index;
-            if (size > s->elementary_transfer_size)
-                size = s->elementary_transfer_size;
-            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,
-                               size, ide_atapi_cmd_reply_end);
-            s->packet_transfer_size -= size;
-            s->elementary_transfer_size -= size;
-            s->io_buffer_index += size;
-        } else {
-            /* a new transfer is needed */
-            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;
-            byte_count_limit = s->lcyl | (s->hcyl << 8);
+        s->lba++;
+        s->io_buffer_index = 0;
+    }
+
+    if (s->elementary_transfer_size > 0) {
+        /* there are some data left to transmit in this elementary
+           transfer */
+        size = s->cd_sector_size - s->io_buffer_index;
+        if (size > s->elementary_transfer_size)
+            size = s->elementary_transfer_size;
+        ide_transfer_start(s, s->io_buffer + s->io_buffer_index,
+                           size, ide_atapi_cmd_reply_end);
+        s->packet_transfer_size -= size;
+        s->elementary_transfer_size -= size;
+        s->io_buffer_index += size;
+    } else {
+        /* a new transfer is needed */
+        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;
+        byte_count_limit = s->lcyl | (s->hcyl << 8);
 #ifdef DEBUG_IDE_ATAPI
-            printf("byte_count_limit=%d\n", byte_count_limit);
+        printf("byte_count_limit=%d\n", byte_count_limit);
 #endif
-            if (byte_count_limit == 0xffff)
+        if (byte_count_limit == 0xffff)
+            byte_count_limit--;
+        size = s->packet_transfer_size;
+        if (size > byte_count_limit) {
+            /* byte count limit must be even if this case */
+            if (byte_count_limit & 1)
                 byte_count_limit--;
-            size = s->packet_transfer_size;
-            if (size > byte_count_limit) {
-                /* byte count limit must be even if this case */
-                if (byte_count_limit & 1)
-                    byte_count_limit--;
-                size = byte_count_limit;
-            }
-            s->lcyl = size;
-            s->hcyl = size >> 8;
-            s->elementary_transfer_size = size;
-            /* we cannot transmit more than one sector at a time */
-            if (s->lba != -1) {
-                if (size > (s->cd_sector_size - s->io_buffer_index))
-                    size = (s->cd_sector_size - s->io_buffer_index);
-            }
-            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,
-                               size, ide_atapi_cmd_reply_end);
-            s->packet_transfer_size -= size;
-            s->elementary_transfer_size -= size;
-            s->io_buffer_index += size;
-            ide_set_irq(s);
+            size = byte_count_limit;
+        }
+        s->lcyl = size;
+        s->hcyl = size >> 8;
+        s->elementary_transfer_size = size;
+        /* we cannot transmit more than one sector at a time */
+        if (s->lba != -1) {
+            if (size > (s->cd_sector_size - s->io_buffer_index))
+                size = (s->cd_sector_size - s->io_buffer_index);
+        }
+        ide_transfer_start(s, s->io_buffer + s->io_buffer_index,
+                           size, ide_atapi_cmd_reply_end);
+        s->packet_transfer_size -= size;
+        s->elementary_transfer_size -= size;
+        s->io_buffer_index += size;
+        ide_set_irq(s);
 #ifdef DEBUG_IDE_ATAPI
-            printf("status=0x%x\n", s->status);
+        printf("status=0x%x\n", s->status);
 #endif
-        }
     }
 }
 
@@ -1883,6 +1976,10 @@ static int ide_dvd_read_structure(IDEState *s, int format,
     }
 }
 
+#ifdef __linux__
+# include "atapi-pt.c"
+#endif
+
 static void ide_atapi_cmd(IDEState *s)
 {
     const uint8_t *packet;
@@ -1923,7 +2020,6 @@ static void ide_atapi_cmd(IDEState *s)
                                 ASC_MEDIUM_NOT_PRESENT);
         }
         break;
-    case GPCMD_MODE_SENSE_6:
     case GPCMD_MODE_SENSE_10:
         {
             int action, code;
@@ -1936,9 +2032,9 @@ static void ide_atapi_cmd(IDEState *s)
             switch(action) {
             case 0: /* current values */
                 switch(code) {
-                case 0x01: /* error recovery */
+                case 0x01: /* read write error recovery parameters */
                     cpu_to_ube16(&buf[0], 16 + 6);
-                    buf[2] = 0x70;
+                    buf[2] = 0x70; /* Obselete: medium type code */
                     buf[3] = 0;
                     buf[4] = 0;
                     buf[5] = 0;
@@ -1955,17 +2051,17 @@ static void ide_atapi_cmd(IDEState *s)
                     buf[15] = 0x00;
                     ide_atapi_cmd_reply(s, 16, max_len);
                     break;
-                case 0x2a:
+                case 0x2a: /* CD/DVD capabilities & mechanical status */
                     cpu_to_ube16(&buf[0], 28 + 6);
-                    buf[2] = 0x70;
+                    buf[2] = 0x70; /* Obselete: medium type code */
                     buf[3] = 0;
                     buf[4] = 0;
                     buf[5] = 0;
                     buf[6] = 0;
                     buf[7] = 0;
 
-                    buf[8] = 0x2a;
-                    buf[9] = 0x12;
+                    buf[8] = 0x2a; /* page code */
+                    buf[9] = 0x12; /* page lenght */
                     buf[10] = 0x00;
                     buf[11] = 0x00;
 
@@ -1988,6 +2084,7 @@ static void ide_atapi_cmd(IDEState *s)
                     buf[27] = 0;
                     ide_atapi_cmd_reply(s, 28, max_len);
                     break;
+
                 default:
                     goto error_cmd;
                 }
@@ -2112,7 +2209,7 @@ static void ide_atapi_cmd(IDEState *s)
         break;
     case GPCMD_MECHANISM_STATUS:
         {
-            max_len = ube16_to_cpu(packet + 8);
+	    max_len = ube16_to_cpu(packet + 8);
             cpu_to_ube16(buf, 0);
             /* no current LBA */
             buf[2] = 0;
@@ -2127,7 +2224,6 @@ static void ide_atapi_cmd(IDEState *s)
         {
             int format, msf, start_track, len;
             uint64_t total_sectors;
-
             bdrv_get_geometry(s->bs, &total_sectors);
             total_sectors >>= 2;
             if (total_sectors == 0) {
@@ -2281,7 +2377,7 @@ static void ide_atapi_cmd(IDEState *s)
                 max_len = 512;
 
             memset(buf, 0, max_len);
-            /* 
+            /*
              * the number of sectors from the media tells us which profile
              * to use as current.  0 means there is no media
              */
@@ -2486,7 +2582,11 @@ static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
 
         /* Only DEVICE RESET is allowed while BSY or/and DRQ are set */
         if ((s->status & (BUSY_STAT|DRQ_STAT)) && val != WIN_DEVICE_RESET)
+        {
+            if (s->is_cdrom)
+                puts("------ DEVICE BUSY");
             break;
+        }
 
         switch(val) {
         case WIN_IDENTIFY:
@@ -2756,7 +2856,7 @@ static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
             else
                 s->status = READY_STAT | SEEK_STAT;
             s->error = 0x01; /* Device 0 passed, Device 1 passed or not
-                              * present. 
+                              * present.
                               */
             ide_set_irq(s);
             break;
@@ -2777,7 +2877,7 @@ static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
             s->atapi_dma = s->feature & 1;
             s->nsector = 1;
             ide_transfer_start(s, s->io_buffer, ATAPI_PACKET_SIZE,
-                               ide_atapi_cmd);
+                               s->atapi_cmd);
             break;
         /* CF-ATA commands */
         case CFA_REQ_EXT_ERROR_CODE:
@@ -3162,8 +3262,21 @@ static void ide_init2(IDEState *ide_state,
 
             if (bdrv_get_type_hint(s->bs) == BDRV_TYPE_CDROM) {
                 s->is_cdrom = 1;
+                s->atapi_cmd = ide_atapi_cmd;
 		bdrv_set_change_cb(s->bs, cdrom_change_cb, s);
             }
+#ifdef __linux__
+            else if (bdrv_get_type_hint(s->bs) == BDRV_TYPE_CDROM_PT) {
+                ide_atapi_pt_setup_sgio_thread(s);
+                //              BDRVRawState *raw_state = s->bs->opaque;
+                s->is_cdrom = 1;
+                s->atapi_cmd = ide_atapi_pt_cmd;
+                bdrv_set_change_cb(s->bs, cdrom_change_cb, s);
+                //                qemu_set_fd_handler(raw_state->fd,
+                //                                  (IOHandler *)ide_atapi_pt_sg_io_finished,
+                //                                  NULL, s);
+            }
+#endif /* __linux__ */
         }
         s->drive_serial = drive_serial++;
         strncpy(s->drive_serial_str, drive_get_serial(s->bs),
diff --git a/vl.c b/vl.c
index aa8cf37..40c8651 100644
--- a/vl.c
+++ b/vl.c
@@ -2183,8 +2183,12 @@ static int bt_parse(const char *opt)
 #define HD_ALIAS "index=%d,media=disk"
 #ifdef TARGET_PPC
 #define CDROM_ALIAS "index=1,media=cdrom"
+#define CDROM_PT_ALIAS "index=1,media=cdrompt"
+#define CDROM_PT_RO_ALIAS "index=1,media=cdrompt,denywrite=1"
 #else
-#define CDROM_ALIAS "index=2,media=cdrom"
+#define CDROM_ALIAS "media=cdrom"
+#define CDROM_PT_ALIAS "media=cdrompt"
+#define CDROM_PT_RO_ALIAS "media=cdrompt,denywrite=1"
 #endif
 #define FD_ALIAS "index=%d,if=floppy"
 #define PFLASH_ALIAS "if=pflash"
@@ -2322,7 +2326,7 @@ int drive_init(struct drive_opt *arg, int snapshot, void *opaque)
     char serial[21];
     const char *mediastr = "";
     BlockInterfaceType type;
-    enum { MEDIA_DISK, MEDIA_CDROM } media;
+    enum { MEDIA_DISK, MEDIA_CDROM, MEDIA_CDROM_PT } media;
     int bus_id, unit_id;
     int cyls, heads, secs, translation;
     BlockDriverState *bdrv;
@@ -2332,12 +2336,14 @@ int drive_init(struct drive_opt *arg, int snapshot, void *opaque)
     int index;
     int cache;
     int bdrv_flags, onerror;
+    int denywrite = 0;
     int drives_table_idx;
     char *str = arg->opt;
     static const char * const params[] = { "bus", "unit", "if", "index",
                                            "cyls", "heads", "secs", "trans",
                                            "media", "snapshot", "file",
                                            "cache", "format", "serial", "werror",
+					   "denywrite",
                                            NULL };
 
     if (check_params(buf, sizeof(buf), params, str) < 0) {
@@ -2479,12 +2485,18 @@ int drive_init(struct drive_opt *arg, int snapshot, void *opaque)
 	        return -1;
             }
 	    media = MEDIA_CDROM;
+        } else if (!strcmp(buf, "cdrompt")) {
+	    media = MEDIA_CDROM_PT;
 	} else {
 	    fprintf(stderr, "qemu: '%s' invalid media\n", str);
 	    return -1;
 	}
     }
 
+    if (get_param_value(buf, sizeof(buf), "denywrite", str)) {
+        denywrite = strtol(buf, NULL, 0);
+    }
+
     if (get_param_value(buf, sizeof(buf), "snapshot", str)) {
         if (!strcmp(buf, "on"))
 	    snapshot = 1;
@@ -2634,6 +2646,9 @@ int drive_init(struct drive_opt *arg, int snapshot, void *opaque)
 	case MEDIA_CDROM:
             bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);
 	    break;
+        case MEDIA_CDROM_PT:
+            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM_PT);
+            break;
 	}
         break;
     case IF_SD:
@@ -2664,6 +2679,13 @@ int drive_init(struct drive_opt *arg, int snapshot, void *opaque)
         bdrv_flags |= BDRV_O_CACHE_WB;
     else if (cache == 3) /* not specified */
         bdrv_flags |= BDRV_O_CACHE_DEF;
+    if (denywrite) {
+        bdrv_flags |= BDRV_O_RDONLY;
+    } else {
+        bdrv_flags |= BDRV_O_RDWR;
+    }
+
+    fprintf(stderr, "**** vl open(%s)\n", file);
     if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {
         fprintf(stderr, "qemu: could not open disk image %s\n",
                         file);
@@ -4237,6 +4259,8 @@ enum {
     QEMU_OPTION_hdc,
     QEMU_OPTION_hdd,
     QEMU_OPTION_cdrom,
+    QEMU_OPTION_cdrom_pt,
+    QEMU_OPTION_cdrom_pt_ro,
     QEMU_OPTION_drive,
     QEMU_OPTION_mtdblock,
     QEMU_OPTION_sd,
@@ -4358,6 +4382,8 @@ static const QEMUOption qemu_options[] = {
     { "hdc", HAS_ARG, QEMU_OPTION_hdc },
     { "hdd", HAS_ARG, QEMU_OPTION_hdd },
     { "cdrom", HAS_ARG, QEMU_OPTION_cdrom },
+    { "cdrom-pt", HAS_ARG, QEMU_OPTION_cdrom_pt },
+    { "cdrom-pt-ro", HAS_ARG, QEMU_OPTION_cdrom_pt_ro },
     { "drive", HAS_ARG, QEMU_OPTION_drive },
     { "mtdblock", HAS_ARG, QEMU_OPTION_mtdblock },
     { "sd", HAS_ARG, QEMU_OPTION_sd },
@@ -5114,6 +5140,12 @@ int main(int argc, char **argv, char **envp)
             case QEMU_OPTION_cdrom:
                 drive_add(optarg, CDROM_ALIAS);
                 break;
+            case QEMU_OPTION_cdrom_pt:
+                drive_add(optarg, CDROM_PT_ALIAS);
+                break;
+            case QEMU_OPTION_cdrom_pt_ro:
+                drive_add(optarg, CDROM_PT_RO_ALIAS);
+                break;
             case QEMU_OPTION_boot:
                 boot_devices = optarg;
                 /* We just do some generic consistency checks */
