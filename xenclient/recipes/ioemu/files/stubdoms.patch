diff --git a/audio/alsaaudio.c b/audio/alsaaudio.c
index 5964c30..9c3db9c 100644
--- a/audio/alsaaudio.c
+++ b/audio/alsaaudio.c
@@ -21,8 +21,13 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
-#include <alsa/asoundlib.h>
 #include "qemu-common.h"
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/mman.h>
+#include <libv4v.h>
+#include <alsa/asoundlib.h>
 #include "audio.h"
 
 #define AUDIO_CAP "alsa"
@@ -84,6 +89,224 @@ struct alsa_params_obt {
     snd_pcm_uframes_t samples;
 };
 
+extern int running_in_stubdomain;
+
+#define V4V_TYPE 'W'
+#define V4VIOCSETRINGSIZE       _IOW (V4V_TYPE,  1, uint32_t)
+
+#define AUDIO_PORT 5001
+
+#define V4V_AUDIO_RING_SIZE (V4V_ROUNDUP((((4096)*64) - sizeof(v4v_ring_t)-V4V_ROUNDUP(1))))
+
+/* Messages definition */
+#define AUDIO_INIT                             0x00
+#define AUDIO_ALSA_OPEN                        0x01
+#define AUDIO_VOLUME                           0x02
+#define AUDIO_VOLUME_MONO                      0x03
+
+#define AUDIO_SND_PCM_CLOSE                    0x04
+#define AUDIO_SND_PCM_PREPARE                  0x05
+#define AUDIO_SND_PCM_DROP                     0x06
+#define AUDIO_SND_PCM_AVAIL_UPDATE             0x07
+#define AUDIO_SND_PCM_STATE                    0x08
+#define AUDIO_SND_PCM_WRITEI                   0x09
+#define AUDIO_SND_PCM_READI                    0x10
+#define AUDIO_SND_PCM_RESUME                   0x11
+
+#define MAX_V4V_MSG_SIZE (V4V_AUDIO_RING_SIZE)
+
+struct audio_helper {
+    int fd;
+    v4v_addr_t remote_addr;
+    v4v_addr_t local_addr;
+    uint8_t io_buf[MAX_V4V_MSG_SIZE];
+    int stubdom_id;
+};
+
+struct audio_helper *ah;
+
+static int common_snd_pcm_op (snd_pcm_t *handle, uint8_t op)
+{
+    uint8_t *v4v_buf = ah->io_buf;
+    int r;
+
+    v4v_buf[0] = op;
+    v4v_buf += 1;
+
+    memcpy(v4v_buf, &handle, sizeof(handle));
+    v4v_buf += sizeof(handle);
+
+    r = v4v_sendto(ah->fd, ah->io_buf, v4v_buf - ah->io_buf,
+		   0, &ah->remote_addr);
+
+    r = v4v_recvfrom(ah->fd, ah->io_buf, MAX_V4V_MSG_SIZE, 0, &ah->remote_addr);
+
+    v4v_buf = ah->io_buf;
+    v4v_buf++;
+
+    memcpy(&r, v4v_buf, sizeof(r));
+
+    return r;
+}
+
+static int snd_pcm_close_wrapper (snd_pcm_t *handle)
+{
+    if (running_in_stubdomain) {
+	return common_snd_pcm_op(handle, AUDIO_SND_PCM_CLOSE);
+    } else {
+	return snd_pcm_close (handle);
+    }
+}
+
+static int snd_pcm_prepare_wrapper (snd_pcm_t *handle)
+{
+    if (running_in_stubdomain) {
+	return common_snd_pcm_op(handle, AUDIO_SND_PCM_PREPARE);
+    } else {
+	return snd_pcm_prepare (handle);
+    }
+}
+
+static int snd_pcm_resume_wrapper (snd_pcm_t *handle)
+{
+    if (running_in_stubdomain) {
+	return common_snd_pcm_op(handle, AUDIO_SND_PCM_RESUME);
+    } else {
+	return snd_pcm_resume (handle);
+    }
+}
+
+static int snd_pcm_drop_wrapper (snd_pcm_t *handle)
+{
+    if (running_in_stubdomain) {
+	return common_snd_pcm_op(handle, AUDIO_SND_PCM_DROP);
+    } else {
+	return snd_pcm_drop (handle);
+    }
+}
+
+static int snd_pcm_avail_update_wrapper (snd_pcm_t *handle)
+{
+    if (running_in_stubdomain) {
+	return common_snd_pcm_op(handle, AUDIO_SND_PCM_AVAIL_UPDATE);
+    } else {
+	return snd_pcm_avail_update (handle);
+    }
+}
+
+static int snd_pcm_state_wrapper (snd_pcm_t *handle)
+{
+    if (running_in_stubdomain) {
+	return common_snd_pcm_op(handle, AUDIO_SND_PCM_STATE);
+    } else {
+	return snd_pcm_state (handle);
+    }
+}
+
+static int audio_helper_open(void)
+{
+    int ret;
+    uint32_t v4v_ring_size = V4V_AUDIO_RING_SIZE;
+    ah = malloc(sizeof(struct audio_helper));
+    if (ah == NULL) {
+	fprintf(stderr, "audio_stubdom_open: no memory to allocate stubdom_helper\n");
+    }
+
+    ah->fd = v4v_socket(SOCK_DGRAM);
+    if (ah->fd == -1) {
+	fprintf(stderr, "audio_stubdom_open: failed to open socket\n");
+	ret = -1;
+	return ret;
+    }
+
+    ah->local_addr.port = V4V_PORT_NONE;
+    ah->local_addr.domain = V4V_DOMID_ANY;
+
+    ah->remote_addr.port = AUDIO_PORT;
+    ah->remote_addr.domain = 0;
+
+    ret = ioctl(ah->fd, V4VIOCSETRINGSIZE, &v4v_ring_size);
+    fprintf(stderr, "%s:%d ioctl=%d\n", __FUNCTION__, __LINE__, ret);
+
+    ret = v4v_bind(ah->fd, &ah->local_addr, 0);
+
+    if (ret == -1) {
+	fprintf(stderr, "%s:%d v4v_bind=%d\n", __FUNCTION__, __LINE__, ret);
+	return ret;
+    }
+
+    return 0;
+}
+
+static int snd_pcm_writei_wrapper (snd_pcm_t *handle, uint8_t *dst, int len)
+{
+    if (running_in_stubdomain) {
+	uint8_t *v4v_buf = ah->io_buf;
+	int r;
+
+	v4v_buf[0] = AUDIO_SND_PCM_WRITEI;
+	v4v_buf += 1;
+
+	memcpy(v4v_buf, &handle, sizeof(handle));
+	v4v_buf += sizeof(handle);
+
+	memcpy(v4v_buf, &len, sizeof(int));
+	v4v_buf += sizeof(int);
+
+	memcpy(v4v_buf, dst, (len*4));
+	v4v_buf += (len*4);
+
+	r = v4v_sendto(ah->fd, ah->io_buf, v4v_buf - ah->io_buf,
+		       0, &ah->remote_addr);
+
+	r = v4v_recvfrom(ah->fd, ah->io_buf, MAX_V4V_MSG_SIZE, 0, &ah->remote_addr);
+
+	v4v_buf = ah->io_buf;
+	v4v_buf++;
+
+	memcpy(&r, v4v_buf, sizeof(r));
+
+	return r;
+    } else {
+	return snd_pcm_writei(handle, dst, len);
+    }
+}
+
+static int snd_pcm_readi_wrapper (snd_pcm_t *handle, uint8_t *src, int len)
+{
+    if (running_in_stubdomain) {
+	uint8_t *v4v_buf = ah->io_buf;
+	int r;
+
+	v4v_buf[0] = AUDIO_SND_PCM_READI;
+	v4v_buf += 1;
+
+	memcpy(v4v_buf, &handle, sizeof(handle));
+	v4v_buf += sizeof(handle);
+
+	memcpy(v4v_buf, &len, sizeof(int));
+	v4v_buf += sizeof(int);
+
+	r = v4v_sendto(ah->fd, ah->io_buf, v4v_buf - ah->io_buf,
+		       0, &ah->remote_addr);
+
+	r = v4v_recvfrom(ah->fd, ah->io_buf, MAX_V4V_MSG_SIZE, 0, &ah->remote_addr);
+
+	v4v_buf = ah->io_buf;
+	v4v_buf++;
+
+	memcpy(&r, v4v_buf, sizeof(r));
+	v4v_buf += sizeof(int);
+
+	if (r >= 0)
+	    memcpy(src, v4v_buf, (r*4));
+
+	return r;
+    } else {
+	return snd_pcm_readi(handle, src, len);
+    }
+}
+
 static void GCC_FMT_ATTR (2, 3) alsa_logerr (int err, const char *fmt, ...)
 {
     va_list ap;
@@ -115,7 +338,7 @@ static void GCC_FMT_ATTR (3, 4) alsa_logerr2 (
 
 static void alsa_anal_close (snd_pcm_t **handlep)
 {
-    int err = snd_pcm_close (*handlep);
+    int err = snd_pcm_close_wrapper (*handlep);
     if (err) {
         alsa_logerr (err, "Failed to close PCM handle %p\n", *handlep);
     }
@@ -263,8 +486,8 @@ static void alsa_set_threshold (snd_pcm_t *handle, snd_pcm_uframes_t threshold)
     }
 }
 
-static int alsa_open (int in, struct alsa_params_req *req,
-                      struct alsa_params_obt *obt, snd_pcm_t **handlep)
+static int alsa_open_local (int in, struct alsa_params_req *req,
+							struct alsa_params_obt *obt, snd_pcm_t **handlep)
 {
     snd_pcm_t *handle;
     snd_pcm_hw_params_t *hw_params;
@@ -295,7 +518,7 @@ static int alsa_open (int in, struct alsa_params_req *req,
 
     /* Close and then open again: volume control seems to only work
      * after the device has been closed once. */
-    err = snd_pcm_close(handle);
+    err = snd_pcm_close_wrapper(handle);
     if (err < 0) {
 	alsa_logerr2 (err, typ, "Failed to close `%s':\n", pcm_name);
 	return -1;
@@ -459,7 +682,7 @@ static int alsa_open (int in, struct alsa_params_req *req,
         goto err;
     }
 
-    err = snd_pcm_prepare (handle);
+    err = snd_pcm_prepare_wrapper (handle);
     if (err < 0) {
         alsa_logerr2 (err, typ, "Could not prepare handle %p\n", handle);
         goto err;
@@ -515,9 +738,55 @@ static int alsa_open (int in, struct alsa_params_req *req,
     return -1;
 }
 
+static int alsa_open (int in, struct alsa_params_req *req,
+                      struct alsa_params_obt *obt, snd_pcm_t **handlep)
+{
+    if (running_in_stubdomain) {
+	uint8_t *v4v_buf = ah->io_buf;
+	snd_pcm_t *handle;
+	int r;
+
+	v4v_buf[0] = AUDIO_ALSA_OPEN;
+	v4v_buf += 1;
+
+	memcpy(v4v_buf, &in, sizeof(in));
+	v4v_buf += sizeof(in);
+
+	memcpy(v4v_buf, req, sizeof(*req));
+	v4v_buf += sizeof(*req);
+
+	memcpy(v4v_buf, obt, sizeof(*obt));
+	v4v_buf += sizeof(*obt);
+
+	r = v4v_sendto(ah->fd, ah->io_buf, v4v_buf - ah->io_buf,
+		       0, &ah->remote_addr);
+
+	r = v4v_recvfrom(ah->fd, ah->io_buf, MAX_V4V_MSG_SIZE, 0, &ah->remote_addr);
+
+	v4v_buf = ah->io_buf;
+	v4v_buf++;
+
+	memcpy(obt, v4v_buf, sizeof(*obt));
+	v4v_buf += sizeof(*obt);
+
+	memcpy(&handle, v4v_buf, sizeof(handle));
+	v4v_buf += sizeof(handle);
+
+	memcpy(&r, v4v_buf, sizeof(r));
+	v4v_buf += sizeof(r);
+
+	*handlep = handle;
+
+	return r;
+    } else {
+	return alsa_open_local(in, req, obt, handlep);
+    }
+}
+
+
 static int alsa_recover (snd_pcm_t *handle)
 {
-    int err = snd_pcm_prepare (handle);
+    int err = snd_pcm_prepare_wrapper (handle);
     if (err < 0) {
         alsa_logerr (err, "Failed to prepare handle %p\n", handle);
         return -1;
@@ -529,11 +798,11 @@ static snd_pcm_sframes_t alsa_get_avail (snd_pcm_t *handle)
 {
     snd_pcm_sframes_t avail;
 
-    avail = snd_pcm_avail_update (handle);
+    avail = snd_pcm_avail_update_wrapper (handle);
     if (avail < 0) {
         if (avail == -EPIPE) {
             if (!alsa_recover (handle)) {
-                avail = snd_pcm_avail_update (handle);
+                avail = snd_pcm_avail_update_wrapper (handle);
             }
         }
 
@@ -549,10 +818,10 @@ static snd_pcm_sframes_t alsa_get_avail (snd_pcm_t *handle)
 
 static void alsa_resume(snd_pcm_t *h)
 {
-    snd_pcm_drop(h);
-    snd_pcm_prepare(h);
-    snd_pcm_resume(h);
-    if (snd_pcm_state(h) == SND_PCM_STATE_SUSPENDED)
+    snd_pcm_drop_wrapper(h);
+    snd_pcm_prepare_wrapper(h);
+    snd_pcm_resume_wrapper(h);
+    if (snd_pcm_state_wrapper(h) == SND_PCM_STATE_SUSPENDED)
     {
         fprintf(stderr, "alsa: try to resume but failed\n");
         exit(1);
@@ -568,7 +837,7 @@ static int alsa_run_out (HWVoiceOut *hw)
     struct st_sample *src;
     snd_pcm_sframes_t avail;
 
-    if (snd_pcm_state(alsa->handle) == SND_PCM_STATE_SUSPENDED)
+    if (snd_pcm_state_wrapper(alsa->handle) == SND_PCM_STATE_SUSPENDED)
         alsa_resume(alsa->handle);
 
     live = audio_pcm_hw_get_live_out (hw);
@@ -594,9 +863,8 @@ static int alsa_run_out (HWVoiceOut *hw)
         dst = advance (alsa->pcm_buf, rpos << hw->info.shift);
 
         hw->clip (dst, src, len);
-
         while (len) {
-            written = snd_pcm_writei (alsa->handle, dst, len);
+            written = snd_pcm_writei_wrapper (alsa->handle, dst, len);
 
             if (written <= 0) {
                 switch (written) {
@@ -702,14 +970,14 @@ static int alsa_voice_ctl (snd_pcm_t *handle, const char *typ, int pause)
     int err;
 
     if (pause) {
-        err = snd_pcm_drop (handle);
+        err = snd_pcm_drop_wrapper (handle);
         if (err < 0) {
             alsa_logerr (err, "Could not stop %s\n", typ);
             return -1;
         }
     }
     else {
-        err = snd_pcm_prepare (handle);
+        err = snd_pcm_prepare_wrapper (handle);
         if (err < 0) {
             alsa_logerr (err, "Could not prepare handle for %s\n", typ);
             return -1;
@@ -817,7 +1085,7 @@ static int alsa_run_in (HWVoiceIn *hw)
         return 0;
     }
 
-    if (!avail && (snd_pcm_state (alsa->handle) == SND_PCM_STATE_PREPARED)) {
+    if (!avail && (snd_pcm_state_wrapper (alsa->handle) == SND_PCM_STATE_PREPARED)) {
         avail = hw->samples;
     }
 
@@ -846,7 +1114,7 @@ static int alsa_run_in (HWVoiceIn *hw)
         dst = hw->conv_buf + bufs[i].add;
 
         while (len) {
-            nread = snd_pcm_readi (alsa->handle, src, len);
+            nread = snd_pcm_readi_wrapper (alsa->handle, src, len);
 
             if (nread <= 0) {
                 switch (nread) {
@@ -917,8 +1185,35 @@ static int alsa_ctl_in (HWVoiceIn *hw, int cmd, ...)
     return -1;
 }
 
+static void send_conf(void)
+{
+    uint8_t *v4v_buf = ah->io_buf;
+
+    v4v_buf[0] = AUDIO_INIT;
+    v4v_buf += 1;
+
+    memcpy(v4v_buf, &conf, sizeof(conf));
+    v4v_buf += sizeof(conf);
+
+    /* memcpy(v4v_buf, conf.pcm_name_in, strlen(conf.pcm_name_in) + 1); */
+    /* v4v_buf += (strlen(conf.pcm_name_in) + 1); */
+
+    /* memcpy(v4v_buf, conf.pcm_name_out, strlen(conf.pcm_name_out) + 1); */
+    /* v4v_buf += (strlen(conf.pcm_name_out) + 1); */
+
+    /* memcpy(v4v_buf, conf.volume_control, strlen(conf.volume_control) + 1); */
+    /* v4v_buf += (strlen(conf.volume_control) + 1); */
+
+    v4v_sendto(ah->fd, ah->io_buf, v4v_buf - ah->io_buf,
+	       0, &ah->remote_addr);
+}
+
 static void *alsa_audio_init (void)
 {
+    if (running_in_stubdomain) {
+	audio_helper_open();
+	send_conf();
+    }
     return &conf;
 }
 
@@ -927,7 +1222,7 @@ static void alsa_audio_fini (void *opaque)
     (void) opaque;
 }
 
-void alsa_volume(int rvol, int lvol, int mute)
+static void alsa_volume_local(int rvol, int lvol, int mute)
 {
     static snd_mixer_t *handle = NULL;
     static const char *card = "default";
@@ -994,9 +1289,32 @@ void alsa_volume(int rvol, int lvol, int mute)
     }
 }
 
+void alsa_volume(int rvol, int lvol, int mute)
+{
+    if (running_in_stubdomain) {
+	uint8_t *v4v_buf = ah->io_buf;
+
+	v4v_buf[0] = AUDIO_VOLUME;
+	v4v_buf += 1;
 
+	memcpy(v4v_buf, &rvol, sizeof(int));
+	v4v_buf += sizeof(int);
 
-void alsa_volume_mono(int chn, int vol, int mute)
+	memcpy(v4v_buf, &lvol, sizeof(int));
+	v4v_buf += sizeof(int);
+
+	memcpy(v4v_buf, &mute, sizeof(int));
+	v4v_buf += sizeof(int);
+
+	v4v_sendto(ah->fd, ah->io_buf, v4v_buf - ah->io_buf,
+		   0, &ah->remote_addr);
+    } else {
+	alsa_volume_local(rvol, lvol, mute);
+    }
+}
+
+
+static void alsa_volume_mono_local(int chn, int vol, int mute)
 {
 
     static snd_mixer_t *handle = NULL;
@@ -1082,7 +1400,29 @@ void alsa_volume_mono(int chn, int vol, int mute)
     
 }
 
+void alsa_volume_mono(int chn, int vol, int mute)
+{
+    if (running_in_stubdomain) {
+	uint8_t *v4v_buf = ah->io_buf;
+
+	v4v_buf[0] = AUDIO_VOLUME_MONO;
+	v4v_buf += 1;
+
+	memcpy(v4v_buf, &chn, sizeof(int));
+	v4v_buf += sizeof(int);
 
+	memcpy(v4v_buf, &vol, sizeof(int));
+	v4v_buf += sizeof(int);
+
+	memcpy(v4v_buf, &mute, sizeof(int));
+	v4v_buf += sizeof(int);
+
+	v4v_sendto(ah->fd, ah->io_buf, v4v_buf - ah->io_buf,
+		   0, &ah->remote_addr);
+    } else {
+	alsa_volume_mono_local(chn, vol, mute);
+    }
+}
 
 
 static struct audio_option alsa_options[] = {
diff --git a/block-raw-posix.c b/block-raw-posix.c
index 6898d6e..e0d1f18 100644
--- a/block-raw-posix.c
+++ b/block-raw-posix.c
@@ -98,6 +98,7 @@
 #define FD_OPEN_TIMEOUT 1000
 
 #include "block/raw-posix.h"
+extern int running_in_stubdomain;
 
 static int posix_aio_init(void);
 
@@ -980,7 +981,13 @@ static int hdev_open(BlockDriverState *bs, const char *filename, int flags)
         bs->sg = 1;
     }
 #endif
-    fd = open(filename, open_flags, 0644);
+    if (strstart(filename, "/dev/bsg", NULL) && running_in_stubdomain) {
+      /* in this case the open will be a remote open and will be 
+	 done inside ide_atapi_pt_setup_sgio_thread() in atapi_pt.c */
+      fd = 1234;
+    } else {
+      fd = open(filename, open_flags, 0644);
+    }
     if (fd < 0) {
         ret = -errno;
         if (ret == -EROFS)
diff --git a/block.c b/block.c
index e835bbd..580d11d 100644
--- a/block.c
+++ b/block.c
@@ -41,6 +41,8 @@
 #define SECTOR_BITS 9
 #define SECTOR_SIZE (1 << SECTOR_BITS)
 
+extern int running_in_stubdomain;
+
 static AIOPool vectored_aio_pool;
 
 typedef struct BlockDriverAIOCBSync {
@@ -292,6 +294,8 @@ static BlockDriver *find_image_format(const char *filename)
        recognized as a host CDROM */
     if (strstart(filename, "/dev/cdrom", NULL))
         return &bdrv_host_device;
+    if (strstart(filename, "/dev/bsg", NULL) && running_in_stubdomain)
+        return &bdrv_host_device;
 #ifdef _WIN32
     if (is_windows_drive(filename))
         return &bdrv_host_device;
@@ -386,7 +390,7 @@ int bdrv_open2(BlockDriverState *bs, const char *filename, int flags,
             is_protocol = 1;
 
         bdrv_delete(bs1);
-
+  
         get_tmp_filename(tmp_filename, sizeof(tmp_filename));
 
         /* Real path is meaningless for protocols */
@@ -407,14 +411,14 @@ int bdrv_open2(BlockDriverState *bs, const char *filename, int flags,
     if (flags & BDRV_O_EXCLUSIVE) {
 	 bs->exclusive = 1;
     }
-
     pstrcpy(bs->filename, sizeof(bs->filename), filename);
     if (flags & BDRV_O_FILE) {
         drv = find_protocol(filename);
-        if (!drv)
+        if (!drv) {
             drv = &bdrv_raw;
+	}
     } else if (!drv) {
-        drv = find_image_format(filename);
+       drv = find_image_format(filename);
     }
     if (!drv) {
         ret = -ENOENT;
diff --git a/hw/atapi-pt.c b/hw/atapi-pt.c
index f0b622e..b1b318b 100644
--- a/hw/atapi-pt.c
+++ b/hw/atapi-pt.c
@@ -10,10 +10,49 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/mman.h>
+#include <libv4v.h>
 #include "xen.h"
 
 /* Even when defined debugging is only enabled if /etc/debugcdrom exists */
 #define DEBUG_IDE_ATAPI_PT
+//#define STUBDOM_ATAPI_PT_DEBUG
+//#define ATAPI_PT_LOCK_DBG
+
+#ifdef ATAPI_PT_LOCK_DBG
+#define ATAPI_PT_LOCK_DBG printf
+#else
+#define ATAPI_PT_LOCK_DBG(...)
+#endif
+
+#define V4V_TYPE 'W'
+#define V4VIOCSETRINGSIZE       _IOW (V4V_TYPE,  1, uint32_t)
+
+#define ATAPI_CDROM_PORT 5000
+#define V4V_ATAPI_PT_RING_SIZE (V4V_ROUNDUP((((4096)*64) - sizeof(v4v_ring_t)-V4V_ROUNDUP(1))))
+
+#define ATAPI_PT_OPEN                        0x00
+#define ATAPI_PT_CLOSE                       0x01
+#define ATAPI_PT_IOCTL_SG_IO                 0x03
+#define ATAPI_PT_IOCTL_SG_GET_RESERVED_SIZE  0x04
+#define ATAPI_PT_GET_PHYS_LOCK               0x05
+#define ATAPI_PT_GET_PHYS_LOCK_STATE         0x06
+#define ATAPI_PT_RELEASE_PHYS_LOCK           0x07
+#define ATAPI_PT_SET_GLOB_MEDIA_STATE        0x08
+#define ATAPI_PT_GET_GLOB_MEDIA_STATE        0x09
+
+
+#define MAX_V4V_MSG_SIZE (V4V_ATAPI_PT_RING_SIZE)
+struct stubdom_helper {
+	int atapi_pt_fd;
+	v4v_addr_t remote_addr;
+	v4v_addr_t local_addr;
+	uint8_t io_buf[MAX_V4V_MSG_SIZE];
+        uint32_t max_xfer_len;
+	int stubdom_id;
+        uint8_t dev_id;
+};
+
+extern int running_in_stubdomain;
 
 #define MSF_TO_FRAMES(M, S, F) (((M) * CD_SECS + (S)) * CD_FRAMES + (F))
 static int log_fd=-1;
@@ -390,36 +429,32 @@ static const struct {
 
 
 
-#define IDE_ATAPI_PT_EXCLUSIVE_CD_FILE "/var/lock/xen-cd-exclusive"
+#define IDE_ATAPI_PT_EXCLUSIVE_CD_FILE_TEMPLATE "/var/lock/xen-cd-exclusive-%04x:%04x"
 
 #define ATAPI_PT_LOCK_STATE_UNLOCKED		0
 #define ATAPI_PT_LOCK_STATE_LOCKED_BY_ME	1
 #define ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER	2
 
-static int we_have_lock = 0;
-
-static void ide_atapi_pt_ejected(void);
+static int atapi_pt_lock_state = ATAPI_PT_LOCK_STATE_UNLOCKED;
 
-static int get_lock_fd(void)
+static int get_lock_fd(IDEState *s)
 {
     static int lock_fd=-1;
-    if (lock_fd <0) {
-    	lock_fd = open( IDE_ATAPI_PT_EXCLUSIVE_CD_FILE, O_RDWR | O_CREAT, 0666);
-    }
+    if (lock_fd)
+      close(lock_fd);
+
+    lock_fd = open( s->atapi_pt.lock_file_name, O_RDWR | O_CREAT, 0666);
+
     return lock_fd;
 }
 
-
-static int get_atapi_pt_lock_state(void)
+static int get_phys_pt_lock_state(IDEState *s)
 {
     struct flock lock = {0};
-    int lock_fd=get_lock_fd();
+    int lock_fd=get_lock_fd(s);
 
     if (lock_fd<0) return ATAPI_PT_LOCK_STATE_UNLOCKED;
 
-    if (we_have_lock)
-        return ATAPI_PT_LOCK_STATE_LOCKED_BY_ME;
-
     lock.l_type = F_WRLCK;
     lock.l_whence = SEEK_SET;
     lock.l_start = 0;
@@ -433,15 +468,32 @@ static int get_atapi_pt_lock_state(void)
     return ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER;
 }
 
-static int get_atapi_pt_lock(void)
+static int get_atapi_pt_lock_state(IDEState *s)
 {
-    struct flock lock = {0};
-    int lock_fd=get_lock_fd();
+  if (s->atapi_pt.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+    return ATAPI_PT_LOCK_STATE_LOCKED_BY_ME;
+  }
+   
+  if (running_in_stubdomain) {
+    struct stubdom_helper *sh = s->atapi_pt.sh;
+    sh->io_buf[0] = ATAPI_PT_GET_PHYS_LOCK_STATE;
+    sh->io_buf[1] = sh->dev_id;
+    v4v_sendto(sh->atapi_pt_fd, sh->io_buf, 2, 0, &sh->remote_addr);
+    v4v_recvfrom(sh->atapi_pt_fd, sh->io_buf, MAX_V4V_MSG_SIZE, 0, &sh->remote_addr);
+    s->atapi_pt.lock_state = sh->io_buf[1];
+  } else { 
+    s->atapi_pt.lock_state = get_phys_pt_lock_state(s); 
+  }
+  ATAPI_PT_LOCK_DBG("ATAPI-PT  get_atapi_pt_lock_state=%d\n", s->atapi_pt.lock_state);
+  return s->atapi_pt.lock_state;
+}
 
-    if (lock_fd<0) return -1;
+static int get_phys_pt_lock(IDEState *s)
+{
+    struct flock lock = {0};
+    int lock_fd=get_lock_fd(s);
 
-    if (we_have_lock)
-	return 0;
+    if (lock_fd<0) return ATAPI_PT_LOCK_STATE_UNLOCKED;
 
     lock.l_type = F_WRLCK;
     lock.l_whence = SEEK_SET;
@@ -449,36 +501,111 @@ static int get_atapi_pt_lock(void)
     lock.l_len = 0;
 
     if (fcntl(lock_fd, F_SETLK, &lock))
-	return -1;
-
-    we_have_lock++;
+	return ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER;
 
-    return 0;
+    return ATAPI_PT_LOCK_STATE_LOCKED_BY_ME;
 }
 
-static int release_atapi_pt_lock(void)
+static void release_phys_pt_lock(IDEState *s)
 {
     struct flock lock = {0};
-    int lock_fd=get_lock_fd();
+    int lock_fd=get_lock_fd(s);
 
-    if (lock_fd<0) return -1;
-
-    if (!we_have_lock)
-	return 0;
+    if (lock_fd<0) return;
 
     lock.l_type = F_UNLCK;
     lock.l_whence = SEEK_SET;
     lock.l_start = 0;
     lock.l_len = 0;
 
-    if (fcntl(lock_fd, F_SETLK, &lock))
-	return -1;
+    fcntl(lock_fd, F_SETLK, &lock);
+}
+
+/* This is the only function (with release_atapi_pt_lock) able to modify 
+   s->atapi_pt.lock_state */
+static int get_atapi_pt_lock(IDEState *s)
+{
+  if (s->atapi_pt.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+    if (running_in_stubdomain) {
+      struct stubdom_helper *sh = s->atapi_pt.sh;
+      sh->io_buf[0] = ATAPI_PT_GET_PHYS_LOCK;
+      sh->io_buf[1] = sh->dev_id;
+      v4v_sendto(sh->atapi_pt_fd, sh->io_buf, 2, 0, &sh->remote_addr);
+      v4v_recvfrom(sh->atapi_pt_fd, sh->io_buf, MAX_V4V_MSG_SIZE, 0, &sh->remote_addr);
+      s->atapi_pt.lock_state = sh->io_buf[1];
+    } else { 
+      s->atapi_pt.lock_state = get_phys_pt_lock(s); 
+    }
+  }
+  return s->atapi_pt.lock_state;
+}
 
-    we_have_lock = 0;
+/* This is the only function (with get_atapi_pt_lock) able to modify 
+   s->atapi_pt.lock_state */
+static void release_atapi_pt_lock(IDEState *s)
+{
+  ATAPI_PT_LOCK_DBG("ATAPI-PT  release_atapi_pt_lock domid=%d\n", domid);
+  if (s->atapi_pt.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+    if (running_in_stubdomain) {
+      struct stubdom_helper *sh = s->atapi_pt.sh;
+      sh->io_buf[0] = ATAPI_PT_RELEASE_PHYS_LOCK;
+      sh->io_buf[1] = sh->dev_id;
+      v4v_sendto(sh->atapi_pt_fd, sh->io_buf, 2, 0, &sh->remote_addr);
+    } else {
+      release_phys_pt_lock(s); 
+    }
+  }
+  s->atapi_pt.lock_state = ATAPI_PT_LOCK_STATE_UNLOCKED;
+}
 
-    return 0;
+static int set_global_media_state(IDEState *s, int new_state)
+{
+    ATAPI_PT_LOCK_DBG("ATAPI-PT  set_global_media_state new_state=%d\n", new_state);
+    if (running_in_stubdomain) {
+      struct stubdom_helper *sh = s->atapi_pt.sh;
+      sh->io_buf[0] = ATAPI_PT_SET_GLOB_MEDIA_STATE;
+      sh->io_buf[1] = sh->dev_id;
+      sh->io_buf[2] = new_state;
+      v4v_sendto(sh->atapi_pt_fd, sh->io_buf, 3, 0, &sh->remote_addr);
+    } else {
+      s->atapi_pt.shm->mediastate = new_state;
+    }
+  
 }
 
+static int get_global_media_state(IDEState *s)
+{
+  int ret;
+    if (running_in_stubdomain) {
+      struct stubdom_helper *sh = s->atapi_pt.sh;
+      sh->io_buf[0] = ATAPI_PT_GET_GLOB_MEDIA_STATE;
+      sh->io_buf[1] = sh->dev_id;
+      v4v_sendto(sh->atapi_pt_fd, sh->io_buf, 2, 0, &sh->remote_addr);
+      v4v_recvfrom(sh->atapi_pt_fd, sh->io_buf, MAX_V4V_MSG_SIZE, 0, &sh->remote_addr);
+      ret = sh->io_buf[1];
+    } else {
+      ret = s->atapi_pt.shm->mediastate;
+    }
+  ATAPI_PT_LOCK_DBG("ATAPI-PT  get_global_media_state state=%d\n", ret);
+  return ret;
+}
+
+static void try_to_get_exclusive_lock(IDEState *s)
+{
+  char *tmp;
+  char xs_path[1024];
+  int lock_state;
+  sprintf(xs_path, "/local/domain/%d/switcher/have_focus", domid);
+  tmp = xenstore_read(xs_path);
+  ATAPI_PT_LOCK_DBG("ATAPI-PT  try_to_get_exclusive_lock domid=%d state=%d\n", domid, s->atapi_pt.lock_state);
+  if (tmp != NULL) {
+    if (strtol(tmp, NULL, 0) == 1) {
+      lock_state =  get_atapi_pt_lock(s);
+      ATAPI_PT_LOCK_DBG("ATAPI-PT  get_atapi_pt_lock=%d\n", lock_state);
+    }
+    free(tmp);
+  }
+}
 
 static const char *atapi_sense_to_str(int key, int asc, int ascq)
 {
@@ -493,6 +620,11 @@ static const char *atapi_sense_to_str(int key, int asc, int ascq)
 }
 
 #ifdef DEBUG_IDE_ATAPI_PT
+
+#ifdef STUBDOM_ATAPI_PT_DEBUG
+# define atapi_dprintf printf
+#else
+
 static void atapi_dprintf(const char *fmt, ...)
 {
     struct stat st;
@@ -534,6 +666,7 @@ static void atapi_dprintf(const char *fmt, ...)
     debugbuf[sizeof(debugbuf)-1] = '\0';
     write(debug_fd, debugbuf, strlen(debugbuf));
 }
+#endif /* STUBDOM_ATAPI_PT_DEBUG */
 
 static void atapi_dhexdump(const void* address, uint32_t len)
 {
@@ -553,6 +686,61 @@ static void atapi_dhexdump(const void* address, uint32_t len)
 }
 #endif /* DEBUG_IDE_ATAPI_PT */
 
+static int atapi_stubdom_open(IDEState *s, char *filename)
+{
+  int ret;
+  int dev_name_len = strlen(filename);
+  uint32_t v4v_ring_size = V4V_ATAPI_PT_RING_SIZE;
+  struct stubdom_helper *sh = s->atapi_pt.sh;
+  sh = malloc(sizeof(struct stubdom_helper));
+  if (sh == NULL) {
+    DEBUG_PRINTF("atapi_stubdom_open: no memory to allocate stubdom_helper\n");
+  }
+
+  s->atapi_pt.sh = sh;
+
+  sh->atapi_pt_fd = v4v_socket(SOCK_DGRAM);
+  if (sh->atapi_pt_fd == -1) {
+    DEBUG_PRINTF("atapi_stubdom_open: failed to open socket\n");
+    ret = -1;
+    return ret;
+  }
+
+  sh->local_addr.port = V4V_PORT_NONE;
+  sh->local_addr.domain = V4V_DOMID_ANY;
+  
+  sh->remote_addr.port = ATAPI_CDROM_PORT;
+  sh->remote_addr.domain = 0;
+  
+  ret = ioctl(sh->atapi_pt_fd, V4VIOCSETRINGSIZE, &v4v_ring_size);
+  DEBUG_PRINTF("%s:%d ioctl=%d\n", __FUNCTION__, __LINE__, ret);
+
+  ret = v4v_bind(sh->atapi_pt_fd, &sh->local_addr, 0);
+
+  if (ret == -1) {
+    DEBUG_PRINTF("%s:%d v4v_bind=%d\n", __FUNCTION__, __LINE__, ret);
+    return ret;
+  }	
+  
+  sh->io_buf[0] = ATAPI_PT_OPEN;
+
+  memcpy(&sh->io_buf[1], filename, dev_name_len);
+  sh->io_buf[dev_name_len + 1] = '\0';
+
+  v4v_sendto(sh->atapi_pt_fd, sh->io_buf, dev_name_len + 2, 0, &sh->remote_addr);  
+  
+  v4v_recvfrom(sh->atapi_pt_fd, sh->io_buf, MAX_V4V_MSG_SIZE, 0, &sh->remote_addr);
+
+  sh->max_xfer_len = (sh->io_buf[1] << 24) | (sh->io_buf[2] << 16) |
+    (sh->io_buf[3] << 8) | (sh->io_buf[4]); 
+
+  sh->dev_id = sh->io_buf[5];
+
+  DEBUG_PRINTF("sh->max_xfer_len=%d\n", sh->max_xfer_len);
+
+  return 0;
+}
+
 
 /* For each SCSI command we need to know up to 3 data sizes. These are:
  * 1. The amount of data to send to the LU.
@@ -828,14 +1016,16 @@ static int ide_atapi_pt_do_dispatch(volatile IDEState *s)
     uint32_t lba;
     uint16_t len;
     uint8_t  request[ATAPI_PACKET_SIZE];
-    int      is_read = 0;
+    int      is_dout = 0;
     __u32    *cmd_len_p;
     uint32_t *req_len_p;
+    int current_transfer_len;
+    uint8_t *copy_of_cmd_din_xferp;
 
     memcpy(request, (void *)s->atapi_pt.request, sizeof(request));
-    is_read = (s->atapi_pt.dout_xfer_len > 0) ? 1 : 0;
-    cmd_len_p = is_read ? &cmd.dout_xfer_len : &cmd.din_xfer_len;
-    req_len_p = (uint32_t*)(is_read ? &s->atapi_pt.dout_xfer_len : &s->atapi_pt.din_xfer_len);
+    is_dout = (s->atapi_pt.dout_xfer_len > 0) ? 1 : 0;
+    cmd_len_p = is_dout ? &cmd.dout_xfer_len : &cmd.din_xfer_len;
+    req_len_p = (uint32_t*)(is_dout ? &s->atapi_pt.dout_xfer_len : &s->atapi_pt.din_xfer_len);
 
     memset(&cmd, 0, sizeof(cmd));
     cmd.guard            = 'Q';
@@ -851,6 +1041,7 @@ next_segment:
     /* Send command and wait for reply, SG_IO ioctl*/
     cmd.din_xferp        = (uintptr_t)(s->io_buffer + seg_offset);
     cmd.dout_xferp       = (uintptr_t)(s->io_buffer + seg_offset);
+    copy_of_cmd_din_xferp = cmd.din_xferp;
     *cmd_len_p           = min(s->atapi_pt.max_xfer_len, *req_len_p - seg_offset);
 
     if (*req_len_p > s->atapi_pt.max_xfer_len)
@@ -893,18 +1084,65 @@ next_segment:
 	DEBUG_PRINTF("Writing %d bytes      0x", cmd.dout_xfer_len);
 	DEBUG_HEXDUMP(s->io_buffer,
 		      cmd.dout_xfer_len < 0x40 ? cmd.dout_xfer_len : 0x40);
+	current_transfer_len = cmd.dout_xfer_len;
     }
     if(cmd.din_xfer_len > 0)
     {
 	DEBUG_PRINTF("Read buffer %d bytes @ %p\n", cmd.din_xfer_len, cmd.din_xferp);
+	current_transfer_len = cmd.din_xfer_len;
     }
 
     if (cmd.timeout != 15000)
 	DEBUG_PRINTF("Timeout %d msec\n", cmd.timeout);
 
     if (!r)
-	r = ioctl(raw_state->fd, SG_IO, &cmd);
+      if (running_in_stubdomain) {
+	struct stubdom_helper *sh = s->atapi_pt.sh;
+	uint8_t *v4v_buf = sh->io_buf;
+
+	v4v_buf[0] = ATAPI_PT_IOCTL_SG_IO;
+	v4v_buf[1] = sh->dev_id;
+	v4v_buf += 2;
+
+	memcpy(v4v_buf, &cmd, sizeof(cmd));
+	v4v_buf += sizeof(cmd);
+
+	memcpy(v4v_buf, request, cmd.request_len);
+	v4v_buf += cmd.request_len;
+
+	if (is_dout) {
+	  /* lets copy the write data into v4v buf since they
+	   *  were pointers mmaped from the kernel driver.
+	   */
+	  memcpy(v4v_buf, cmd.dout_xferp, current_transfer_len);
+	  v4v_buf += current_transfer_len;
+	}
 
+	r = v4v_sendto(sh->atapi_pt_fd, sh->io_buf, v4v_buf - sh->io_buf,
+		   0, &sh->remote_addr);
+
+	r = v4v_recvfrom(sh->atapi_pt_fd, sh->io_buf, MAX_V4V_MSG_SIZE, 0, &sh->remote_addr);
+
+	v4v_buf = sh->io_buf;
+
+	r = v4v_buf[1];
+	v4v_buf += 2;
+
+	memcpy(&cmd, v4v_buf, sizeof(cmd));
+	v4v_buf += sizeof(cmd);
+
+	
+	memcpy((uint8_t *)&s->atapi_pt.sense, v4v_buf, cmd.max_response_len);
+	v4v_buf += cmd.max_response_len;
+
+	if (!is_dout) {
+	  memcpy(copy_of_cmd_din_xferp, v4v_buf,
+		 current_transfer_len);
+	  v4v_buf += current_transfer_len;
+	}
+      } else {
+	r = ioctl(raw_state->fd, SG_IO, &cmd);
+      }
     if(r)
 	s->atapi_pt.result = r;
     else if(cmd.driver_status)
@@ -968,24 +1206,15 @@ static time_t status_file_touched(const char *fn)
 	return buf.st_ctime;
 }
 
-static void notify_media_event(ATAPIPTMediaState newstate, IDEState *s)
-{
-    s->atapi_pt.lastmediastate = newstate;
-    if (s->atapi_pt.shm->mediastate != newstate)
-    {
-	DEBUG_PRINTF("[ATAPI] signal media state change %d->%d\n",
-		     s->atapi_pt.shm->mediastate, newstate);
-    }
-    s->atapi_pt.shm->mediastate = newstate;
-}
-
 static void ide_atapi_pt_cmd_complete(void *arg) /* Mop up result*/
 {
     IDEState *s = (IDEState *)arg;
     uint8_t cmd_code = s->atapi_pt.request[0];
     uint32_t din_actual;
     static uint32_t serial = 0;
+    int global_media_state;
     time_t etime, ntime;
+    char *tmp;
     int r;
 
     assert(s);
@@ -1001,9 +1230,9 @@ static void ide_atapi_pt_cmd_complete(void *arg) /* Mop up result*/
 	if (s->atapi_pt.sense.sense_key == 2 && s->atapi_pt.sense.asc == 0x3A)
 	{
             /* No media, remove exclusivity lock */
-            ide_atapi_pt_ejected();
-	    /* Signal others that the media has been removed */
-	    notify_media_event(MEDIA_ABSENT, s);
+	  set_global_media_state(s, MEDIA_ABSENT);
+	  s->atapi_pt.lastmediastate = MEDIA_ABSENT;
+	  release_atapi_pt_lock(s);
 	}
         ide_atapi_pt_error(s);
         return;
@@ -1016,9 +1245,16 @@ static void ide_atapi_pt_cmd_complete(void *arg) /* Mop up result*/
        s->atapi_pt.request[0] == GPCMD_READ_12 ||
        s->atapi_pt.request[0] == GPCMD_READ_DISC_INFO)
     {
-	/* If this didn't fail then a media is present,
-	 * make sure others know about this */
-	notify_media_event(MEDIA_PRESENT, s);
+      /* If this didn't fail then a media is present */
+      if (s->atapi_pt.lastmediastate != MEDIA_PRESENT) {
+	set_global_media_state(s, MEDIA_PRESENT);
+	s->atapi_pt.lastmediastate = MEDIA_PRESENT;
+	if ( s->bs->exclusive == 1) {
+	  /* If the status has just changed to present and we are 
+	     in an exclusive world try to get the lock */
+	  try_to_get_exclusive_lock(s);
+	}
+      }
     }
 
     if(s->atapi_pt.request[0] == GPCMD_GET_EVENT_STATUS_NOTIFICATION)
@@ -1028,53 +1264,69 @@ static void ide_atapi_pt_cmd_complete(void *arg) /* Mop up result*/
             /* This is a "new media" message, tell any other VMs */
             DEBUG_PRINTF("[ATAPI] new media detected\n");
 
-	    notify_media_event(MEDIA_PRESENT, s);
-        }
+	    if (s->atapi_pt.lastmediastate != MEDIA_PRESENT) {
+	      set_global_media_state(s, MEDIA_PRESENT);
+	      s->atapi_pt.lastmediastate = MEDIA_PRESENT;
+	      if ( s->bs->exclusive == 1) {
+		/* If the status has just changed to present and we are 
+		   in an exclusive world try to get the lock */
+		try_to_get_exclusive_lock(s);
+	      }
+	    }
+	}
 
         if(s->io_buffer[2] == 4 && s->io_buffer[4] == 3)
         {
             /* This is a "media removed" message, tell any other VMs */
             DEBUG_PRINTF("[ATAPI] media removed\n");
-
-	    notify_media_event(MEDIA_ABSENT, s);
-
-            /* Remove exclusivity lock */
-            ide_atapi_pt_ejected();
-        }
+	    if (s->atapi_pt.lastmediastate != MEDIA_ABSENT) {
+	      set_global_media_state(s, MEDIA_ABSENT);
+	      s->atapi_pt.lastmediastate = MEDIA_ABSENT;
+	      if (s->bs->exclusive == 1) {
+		release_atapi_pt_lock(s);
+	      }
+	    }
+	}
 
         if((s->io_buffer[2] == 4 && s->io_buffer[4] == 0 && s->io_buffer[5] == 2) ||
            (s->io_buffer[4] == 0 && s->io_buffer[5] == 0 &&
             s->io_buffer[6] == 0 && s->io_buffer[7] == 0))
         {
             /* This is a no activity message we can hijack if we need to */
-	    if ((s->atapi_pt.lastmediastate != s->atapi_pt.shm->mediastate) &&
-		(s->atapi_pt.shm->mediastate != MEDIA_STATE_UNKNOWN))
+	    global_media_state = get_global_media_state(s);
+	    if ((s->atapi_pt.lastmediastate != global_media_state) &&
+	    	(global_media_state != MEDIA_STATE_UNKNOWN))
 	    {
-		s->atapi_pt.lastmediastate = s->atapi_pt.shm->mediastate;
-
-		if (s->atapi_pt.lastmediastate == MEDIA_ABSENT)
-		{
-		    /* There's been an eject message that we haven't seen yet */
-		    DEBUG_PRINTF("[ATAPI] media removed message spotted\n");
-
-		    s->io_buffer[2] = 4;
-		    s->io_buffer[4] = 3;
-		    s->io_buffer[5] = 1;
-		    s->io_buffer[6] = 0;
-		    s->io_buffer[7] = 0;
-		    release_atapi_pt_lock();
-		} else {
-		    DEBUG_PRINTF("[ATAPI] new media message spotted\n");
-		    if (s->bs->exclusive != 1 ||
-			(s->bs->exclusive == 1 && get_atapi_pt_lock_state() != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME))
-		    {
-			s->io_buffer[2] = 4;
-			s->io_buffer[4] = 2;
-			s->io_buffer[5] = 2;
-			s->io_buffer[6] = 0;
-			s->io_buffer[7] = 0;
+	    	s->atapi_pt.lastmediastate = global_media_state;
+
+	    	if (s->atapi_pt.lastmediastate == MEDIA_ABSENT)
+	    	{
+	    	    /* There's been an eject message that we haven't seen yet */
+	    	    DEBUG_PRINTF("[ATAPI] media removed message spotted\n");
+
+	    	    s->io_buffer[2] = 4;
+	    	    s->io_buffer[4] = 3;
+	    	    s->io_buffer[5] = 1;
+	    	    s->io_buffer[6] = 0;
+	    	    s->io_buffer[7] = 0;
+		    if (s->bs->exclusive == 1) {
+		      release_atapi_pt_lock(s);
+		    }
+	    	} else {
+	    	    DEBUG_PRINTF("[ATAPI] new media message spotted\n");
+	    	    if (s->bs->exclusive != 1 ||
+	    		(s->bs->exclusive == 1 && s->atapi_pt.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME))
+	    	    {
+	    		s->io_buffer[2] = 4;
+	    		s->io_buffer[4] = 2;
+	    		s->io_buffer[5] = 2;
+	    		s->io_buffer[6] = 0;
+	    		s->io_buffer[7] = 0;
+	    	    }
+		    if (s->bs->exclusive == 1) {
+		      try_to_get_exclusive_lock(s);
 		    }
-		}
+	    	}
 	    }
 	}
     }
@@ -1197,37 +1449,49 @@ static void ide_atapi_pt_setup_sgio_thread(IDEState *s)
     qemu_aio_set_fd_handler(s->atapi_pt.sgio_dispatch_fd, ide_atapi_pt_cmd_complete, NULL, ide_atapi_pt_aio_flush, (void *)s);
 
     /* Initialize the changed media shm */
-    raw_state = s->bs->opaque;
-    if (fstat(raw_state->fd, &st)) {
-	    fprintf(stderr, "Failed to fstat() the atapi-pt device (fd=%d): %s\n", raw_state->fd,
-		    strerror(errno));
-	    exit(1);
-    }
-    snprintf(shm_name, sizeof(shm_name)-1, IDE_ATAPI_PT_SHM_NAME_TEMPLATE,
-	     major(st.st_rdev), minor(st.st_rdev));
-    shm_name[sizeof(shm_name)-1] = '\0';
-    s->atapi_pt.shmfd = shm_open(shm_name, O_CREAT | O_RDWR, 0666);
-    if (s->atapi_pt.shmfd < 0) {
-	fprintf(stderr, "Open ATAPI-PT SHM failed: %s\n", strerror(errno));
-	exit(1);
-    }
-    ftruncate(s->atapi_pt.shmfd, sizeof(*(s->atapi_pt.shm)));
-    s->atapi_pt.shm = mmap(NULL, sizeof(*(s->atapi_pt.shm)), PROT_READ|PROT_WRITE,
-			   MAP_SHARED, s->atapi_pt.shmfd, 0);
-    if (s->atapi_pt.shm == MAP_FAILED) {
-	fprintf(stderr, "Map ATAPI-PT SHM failed: %s\n", strerror(errno));
-	exit(1);
-    }
-    s->atapi_pt.lastmediastate = s->atapi_pt.shm->mediastate;
-
-    /* Find out the maximum block size the hardware supports. This is needed for USB
-     * drives where it is 120kb (less than the normal 128kb for some reason)
-     */
-    if (ioctl(raw_state->fd, SG_GET_RESERVED_SIZE, &(s->atapi_pt.max_xfer_len))) {
-	fprintf(stderr, "ATAPI-PT get max xfer len failed: %s\n", strerror(errno));
+      /* All SHM stuff wil be done from the stubdom-helper in dom0 */
+    if(running_in_stubdomain) {
+      struct stubdom_helper *sh;
+
+      atapi_stubdom_open(s, s->bs->filename);
+      sh = s->atapi_pt.sh;
+      s->atapi_pt.max_xfer_len = sh->max_xfer_len;
+      //s->atapi_pt.max_xfer_len = 4096 * 24;
+      s->atapi_pt.lock_state = ATAPI_PT_LOCK_STATE_UNLOCKED;
+    } else {
+      raw_state = s->bs->opaque;
+      if (fstat(raw_state->fd, &st)) {
+	fprintf(stderr, "Failed to fstat() the atapi-pt device (fd=%d): %s\n", raw_state->fd,
+		strerror(errno));
 	exit(1);
+      }
+      snprintf(shm_name, sizeof(shm_name)-1, IDE_ATAPI_PT_SHM_NAME_TEMPLATE,
+	       major(st.st_rdev), minor(st.st_rdev));
+      shm_name[sizeof(shm_name)-1] = '\0';
+      s->atapi_pt.shmfd = shm_open(shm_name, O_CREAT | O_RDWR, 0666);
+      if (s->atapi_pt.shmfd < 0) {
+    	fprintf(stderr, "Open ATAPI-PT SHM failed: %s\n", strerror(errno));
+    	exit(1);
+      }
+      ftruncate(s->atapi_pt.shmfd, sizeof(*(s->atapi_pt.shm)));
+      s->atapi_pt.shm = mmap(NULL, sizeof(*(s->atapi_pt.shm)), PROT_READ|PROT_WRITE,
+			     MAP_SHARED, s->atapi_pt.shmfd, 0);
+      if (s->atapi_pt.shm == MAP_FAILED) {
+    	fprintf(stderr, "Map ATAPI-PT SHM failed: %s\n", strerror(errno));
+    	exit(1);
+      }
+      
+      /* Find out the maximum block size the hardware supports. This is needed for USB */
+      /* drives where it is 120kb (less than the normal 128kb for some reason) */
+      if (ioctl(raw_state->fd, SG_GET_RESERVED_SIZE, &(s->atapi_pt.max_xfer_len))) {
+    	fprintf(stderr, "ATAPI-PT get max xfer len failed: %s\n", strerror(errno));
+    	exit(1);
+      }
+      s->atapi_pt.max_xfer_len = (s->atapi_pt.max_xfer_len + CD_FRAMESIZE-1) & ~(CD_FRAMESIZE-1);
+      snprintf(s->atapi_pt.lock_file_name, sizeof(shm_name)-1, IDE_ATAPI_PT_EXCLUSIVE_CD_FILE_TEMPLATE,
+              major(st.st_rdev), minor(st.st_rdev));
     }
-    s->atapi_pt.max_xfer_len = (s->atapi_pt.max_xfer_len + CD_FRAMESIZE-1) & ~(CD_FRAMESIZE-1);
+    s->atapi_pt.lastmediastate = MEDIA_STATE_UNKNOWN;
     DEBUG_PRINTF("ATAPI-PT max_xfer_len: %d (%d CD-sectors)\n", s->atapi_pt.max_xfer_len,
 		 s->atapi_pt.max_xfer_len/CD_FRAMESIZE);
 }
@@ -1428,13 +1692,6 @@ static int ide_atapi_pt_read_cd_block_size(const uint8_t *io_buffer)
     return block_size;
 }
 
-
-static void ide_atapi_pt_ejected(void)
-{
-    release_atapi_pt_lock();
-}
-
-
 static void ide_atapi_pt_cmd(IDEState *s)
 {
     uint8_t cmd_code;
@@ -1448,45 +1705,35 @@ static void ide_atapi_pt_cmd(IDEState *s)
     s->atapi_pt.timeout = 15000;
     s->status |= BUSY_STAT;
 
+    get_atapi_pt_lock_state(s);
+
     /* Check if we want exclusive read access */
     if (s->bs->exclusive == 1)
     {
-	if (laststate != MEDIA_PRESENT &&
-	    s->atapi_pt.shm->mediastate == MEDIA_PRESENT)
-	{
-	    /* We just inserted a CD, try to get the lock if we're
-	     * focused */
-	    tmp = xenstore_read("/local/domain/0/switcher/focus");
-	    if (strtol(tmp, NULL, 0) == domid)
-		get_atapi_pt_lock();
-	}
-	laststate = s->atapi_pt.shm->mediastate;
-	
-	/* Always allow drive-related requests */
-	if (cmd_code != GPCMD_TEST_UNIT_READY &&
-	    cmd_code != GPCMD_GET_CONFIGURATION &&
-	    cmd_code != GPCMD_GET_PERFORMANCE &&
-	    cmd_code != GPCMD_MECHANISM_STATUS &&
-	    cmd_code != GPCMD_REQUEST_SENSE &&
-	    cmd_code != GPCMD_MODE_SENSE_10 &&
-	    cmd_code != GPCMD_INQUIRY &&
-	    cmd_code != GPCMD_GET_EVENT_STATUS_NOTIFICATION &&
-	    cmd_code != GPCMD_REPORT_KEY &&
-	    cmd_code != GPCMD_READ_CDVD_CAPACITY &&
-	    cmd_code != GPCMD_READ_FORMAT_CAPACITIES)
-	{
-	    /* Have lock? */
-	    if ((get_atapi_pt_lock_state() != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) &&
-		/* Allow EJECT when nobody has the lock */
-		(get_atapi_pt_lock_state() != ATAPI_PT_LOCK_STATE_UNLOCKED || cmd_code != GPCMD_START_STOP_UNIT))
-	    {
-		DEBUG_PRINTF("[ATAPI] refusing command: 0x%02x (\e[0;32m%s\e[m) dma=%d domain=%d\n",
-			     cmd_code, atapi_cmd_to_str(cmd_code), s->atapi_dma, domid);
-		ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
-				       ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
-		return;
-	    }
-	}
+    	/* Always allow drive-related requests */
+    	if (cmd_code != GPCMD_TEST_UNIT_READY &&
+    	    cmd_code != GPCMD_GET_CONFIGURATION &&
+    	    cmd_code != GPCMD_GET_PERFORMANCE &&
+    	    cmd_code != GPCMD_MECHANISM_STATUS &&
+    	    cmd_code != GPCMD_REQUEST_SENSE &&
+    	    cmd_code != GPCMD_MODE_SENSE_10 &&
+    	    cmd_code != GPCMD_INQUIRY &&
+    	    cmd_code != GPCMD_GET_EVENT_STATUS_NOTIFICATION &&
+    	    cmd_code != GPCMD_REPORT_KEY &&
+    	    cmd_code != GPCMD_READ_CDVD_CAPACITY &&
+    	    cmd_code != GPCMD_READ_FORMAT_CAPACITIES)
+    	{
+    	    /* Have lock? */
+	  if ((s->atapi_pt.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) &&
+	      (s->atapi_pt.lock_state != ATAPI_PT_LOCK_STATE_UNLOCKED || cmd_code != GPCMD_START_STOP_UNIT))
+    	    {
+    		DEBUG_PRINTF("[ATAPI] refusing command: 0x%02x (\e[0;32m%s\e[m) dma=%d domain=%d\n",
+    			     cmd_code, atapi_cmd_to_str(cmd_code), s->atapi_dma, domid);
+    		ide_atapi_pt_set_error(s, SENSE_ILLEGAL_REQUEST,
+    				       ASC_INV_FIELD_IN_CMD_PACKET, 0, 0x70);
+    		return;
+    	    }
+    	}
     }
 
     DEBUG_PRINTF("[ATAPI] sending command: 0x%02x (\e[0;32m%s\e[m) dma=%d domain=%d\n",
@@ -1538,7 +1785,7 @@ static void ide_atapi_pt_cmd(IDEState *s)
 
 
 
-    if(get_atapi_pt_lock_state() == ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER)
+    if(s->atapi_pt.lock_state == ATAPI_PT_LOCK_STATE_LOCKED_BY_OTHER)
     {
         uint8_t sense[18] = {0x70, 0, 2, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0x3a, 1, 0, 0, 0, 0};
 
@@ -1556,7 +1803,7 @@ static void ide_atapi_pt_cmd(IDEState *s)
             memcpy(s->io_buffer, inquiry_data, 96);
             memset(&s->atapi_pt.sense, 0, sizeof(sense));
             ide_atapi_cmd_reply(s, 96, s->atapi_pt.din_xfer_len);
-  	return;
+    	return;
 
         }
 
@@ -1564,22 +1811,23 @@ static void ide_atapi_pt_cmd(IDEState *s)
         {
             sense[2] = 5;
             sense[12] = 0x24;
-			sense[13] = 0;
+    			sense[13] = 0;
         }
 
         DEBUG_PRINTF("Blocking command due to exclusivity lock\n");
         memcpy(&s->atapi_pt.sense, sense, sizeof(sense));
         ide_atapi_pt_set_error(s, sense[2], sense[12], sense[13], 0x70);
-	return;
+    	return;
     }
 
-    // If we're not writing, flush cache is a no-op.
-    // Win VMs run it on shutdown, so
-    // we ignore this so other VM's don't get shafted
-    if (cmd_code == GPCMD_FLUSH_CACHE && !we_have_lock) {
-	DEBUG_PRINTF("Ignoring flush while not holding write lock\n");
-	ide_atapi_cmd_ok(s);
-	return;
+    /* If we're not writing, flush cache is a no-op. */
+    /* Win VMs run it on shutdown, so */
+    /* we ignore this so other VM's don't get shafted */
+    if (cmd_code == GPCMD_FLUSH_CACHE &&
+	s->atapi_pt.lock_state != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
+    	DEBUG_PRINTF("Ignoring flush while not holding write lock\n");
+    	ide_atapi_cmd_ok(s);
+    	return;
     }
 
     /* Claim exclusive use if we're doing any kind of writing */
@@ -1596,7 +1844,7 @@ static void ide_atapi_pt_cmd(IDEState *s)
 	}
 
         DEBUG_PRINTF("Claiming exclusive lock while writing\n");
-	if (get_atapi_pt_lock()) {
+	if (get_atapi_pt_lock(s) != ATAPI_PT_LOCK_STATE_LOCKED_BY_ME) {
             DEBUG_PRINTF("Could not open CD exclusivity lock file for writing\n");
 #if 0
 	    // FIXME XXX - make this throw an error
@@ -1762,7 +2010,7 @@ static void ide_atapi_pt_cmd(IDEState *s)
 
     case GPCMD_LOAD_UNLOAD:
         if((s->io_buffer[4] & 3) == 2)  /* Eject command, remove exclusivity lock */
-            ide_atapi_pt_ejected();
+	  release_atapi_pt_lock(s);
 
         break;
     }
diff --git a/hw/ide.c b/hw/ide.c
index a220d8a..245a743 100644
--- a/hw/ide.c
+++ b/hw/ide.c
@@ -452,14 +452,15 @@ typedef struct ATAPIPassThroughState
     int                  shmfd;
     ATAPIPTShm *         volatile shm;
     ATAPIPTMediaState    lastmediastate;
-
+    int                  lock_state;
     uint32_t             max_xfer_len;
-
+    void *               sh; /* stubdom_helper related*/
     pthread_t            sgio_thread;
     pthread_mutex_t      sgio_mutex;
     pthread_cond_t       sgio_cv;
     int                  sgio_worker_fd;
     int                  sgio_dispatch_fd;
+    char                 lock_file_name[256];
 } ATAPIPassThroughState;
 #endif /* __linux__ */
 
diff --git a/hw/pass-through.c b/hw/pass-through.c
index d673f19..3644a83 100644
--- a/hw/pass-through.c
+++ b/hw/pass-through.c
@@ -84,6 +84,7 @@
  */
 
 #include "pass-through.h"
+#include "pci-remote.h"
 #include "pci/header.h"
 #include "pci/pci.h"
 #include "pt-msi.h"
@@ -100,6 +101,7 @@
 extern int gfx_passthru;
 int igd_passthru = 0;
 extern int surfman;
+extern int running_in_stubdomain;
 
 struct php_dev {
     struct pt_dev *pt_dev;
@@ -1052,7 +1054,7 @@ int bdf_to_devfn(char *bdf_str)
 
 static uint8_t pci_read_intx(struct pt_dev *ptdev)
 {
-    return pci_read_byte(ptdev->pci_dev, PCI_INTERRUPT_PIN);
+    return rpci_read_byte(ptdev->pci_dev, PCI_INTERRUPT_PIN);
 }
 
 /* The PCI Local Bus Specification, Rev. 3.0,
@@ -1551,7 +1553,7 @@ static void pt_pci_write_config(PCIDevice *d, uint32_t address, uint32_t val,
     }
 
     /* read I/O device register value */
-    ret = pci_read_block(pci_dev, address, (uint8_t *)&read_val, len);
+    ret = rpci_read_block(pci_dev, address, (uint8_t *)&read_val, len);
 
     if (!ret)
     {
@@ -1638,7 +1640,7 @@ static void pt_pci_write_config(PCIDevice *d, uint32_t address, uint32_t val,
 
 out:
     if (!(reg && reg->no_wb)) {  /* unknown regs are passed through */
-        ret = pci_write_block(pci_dev, address, (uint8_t *)&val, len);
+        ret = rpci_write_block(pci_dev, address, (uint8_t *)&val, len);
 
         if (!ret)
             PT_LOG("Error: pci_write_block failed. return value[%d].\n", ret);
@@ -1722,7 +1724,7 @@ static uint32_t pt_pci_read_config(PCIDevice *d, uint32_t address, int len)
     }
 
     /* read I/O device register value */
-    ret = pci_read_block(pci_dev, address, (uint8_t *)&val, len);
+    ret = rpci_read_block(pci_dev, address, (uint8_t *)&val, len);
 
     if (!ret)
     {
@@ -1913,11 +1915,11 @@ static int pt_register_regions(struct pt_dev *assigned_device)
     {
 
         /* Re-set BAR reported by OS, otherwise ROM can't be read. */
-        bar_data = pci_read_long(pci_dev, PCI_ROM_ADDRESS);
+        bar_data = rpci_read_long(pci_dev, PCI_ROM_ADDRESS);
         if ( (bar_data & PCI_ROM_ADDRESS_MASK) == 0 )
         {
             bar_data |= (pci_dev->rom_base_addr & PCI_ROM_ADDRESS_MASK);
-            pci_write_long(pci_dev, PCI_ROM_ADDRESS, bar_data);
+            rpci_write_long(pci_dev, PCI_ROM_ADDRESS, bar_data);
         }
 
         assigned_device->bases[PCI_ROM_SLOT].e_physbase =
@@ -1990,18 +1992,18 @@ static uint8_t find_cap_offset(struct pci_dev *pci_dev, uint8_t cap)
     int pos = PCI_CAPABILITY_LIST;
     int status;
 
-    status = pci_read_byte(pci_dev, PCI_STATUS);
+    status = rpci_read_byte(pci_dev, PCI_STATUS);
     if ( (status & PCI_STATUS_CAP_LIST) == 0 )
         return 0;
 
     while ( max_cap-- )
     {
-        pos = pci_read_byte(pci_dev, pos);
+        pos = rpci_read_byte(pci_dev, pos);
         if ( pos < 0x40 )
             break;
 
         pos &= ~3;
-        id = pci_read_byte(pci_dev, pos + PCI_CAP_LIST_ID);
+        id = rpci_read_byte(pci_dev, pos + PCI_CAP_LIST_ID);
 
         if ( id == 0xff )
             break;
@@ -2021,7 +2023,7 @@ static uint32_t find_ext_cap_offset(struct pci_dev *pci_dev, uint32_t cap)
 
     do
     {
-        header = pci_read_long(pci_dev, pos);
+        header = rpci_read_long(pci_dev, pos);
         /*
          * If we have no capabilities, this is indicated by cap ID,
          * cap version and next pointer all being 0.
@@ -2065,13 +2067,18 @@ u32 pt_pci_host_read(int bus, int dev, int fn, u32 addr, int len)
 
     struct pci_dev *pci_dev;
     u32 val = -1;
+    len = (len > 4) ? 4 : len;
 
-    pci_access_init();
-    pci_dev = pci_get_dev(dpci_infos.pci_access, 0, bus, dev, fn);
-    if ( !pci_dev )
-        return 0;
+    if (running_in_stubdomain) {
+        rpci_read_block_(&val, 0, bus, dev, fn, addr, len);
+    } else {
+        pci_access_init();
+        pci_dev = pci_get_dev(dpci_infos.pci_access, 0, bus, dev, fn);
+        if ( !pci_dev )
+            return 0;
 
-    pci_read_block(pci_dev, addr, (u8 *) &val, len);
+        rpci_read_block(pci_dev, addr, (u8 *) &val, len);
+    }
     return val;
 }
 
@@ -2080,12 +2087,19 @@ int pt_pci_host_write(int bus, int dev, int fn, u32 addr, u32 val, int len)
     struct pci_dev *pci_dev;
     int ret = 0;
 
-    pci_access_init();
-    pci_dev = pci_get_dev(dpci_infos.pci_access, 0, bus, dev, fn);
-    if ( !pci_dev )
-        return 0;
+    if (len>4) len=4;
+
+    if (running_in_stubdomain) {
+        ret = rpci_write_block_(&val, 0, bus, dev, fn, addr, len);
+    } else {
+        pci_access_init();
+        pci_dev = pci_get_dev(dpci_infos.pci_access, 0, bus, dev, fn);
+        if ( !pci_dev )
+            return 0;
+
+        ret = pci_write_block(pci_dev, addr, (u8 *) &val, len);
+    }
 
-    ret = pci_write_block(pci_dev, addr, (u8 *) &val, len);
     return ret;
 }
 
@@ -2221,7 +2235,7 @@ static int check_power_state(struct pt_dev *ptdev)
     uint16_t cur_state = 0;
 
     /* get current power state */
-    read_val = pci_read_word(ptdev->pci_dev,
+    read_val = rpci_read_word(ptdev->pci_dev,
                                 (pm_state->pm_base + PCI_PM_CTRL));
     cur_state = read_val & PCI_PM_CTRL_STATE_MASK;
 
@@ -2243,7 +2257,7 @@ static void aer_save_one_register(struct pt_dev *ptdev, int offset)
     uint32_t aer_base = ptdev->pm_state->aer_base;
 
     *(uint32_t*)(d->config + (aer_base + offset))
-        = pci_read_long(ptdev->pci_dev, (aer_base + offset));
+        = rpci_read_long(ptdev->pci_dev, (aer_base + offset));
 }
 
 /* save AER registers */
@@ -2266,7 +2280,7 @@ static void aer_restore_one_register(struct pt_dev *ptdev, int offset)
     uint32_t config = 0;
 
     config = *(uint32_t*)(d->config + (aer_base + offset));
-    pci_write_long(ptdev->pci_dev, (aer_base + offset), config);
+    rpci_write_long(ptdev->pci_dev, (aer_base + offset), config);
 }
 
 /* restore AER registers */
@@ -2348,7 +2362,7 @@ static void pt_config_restore(struct pt_dev *ptdev)
             real_offset = (reg_grp_entry->base_offset + reg->offset);
 
             /* read I/O device register value */
-            ret = pci_read_block(ptdev->pci_dev, real_offset,
+            ret = rpci_read_block(ptdev->pci_dev, real_offset,
                         (uint8_t *)&read_val, reg->size);
 
             if (!ret)
@@ -2394,7 +2408,7 @@ static void pt_config_restore(struct pt_dev *ptdev)
                 real_offset, val, reg->size);
 #endif
 
-            ret = pci_write_block(ptdev->pci_dev, real_offset,
+            ret = rpci_write_block(ptdev->pci_dev, real_offset,
                             (uint8_t *)&val, reg->size);
 
             if (!ret)
@@ -2847,23 +2861,23 @@ static uint32_t pt_pmcsr_reg_init(struct pt_dev *ptdev,
             & (uint8_t)PCI_PM_CTRL_NO_SOFT_RESET);
 
     /* wake up real physical device */
-    switch ( pci_read_word(ptdev->pci_dev, real_offset) 
+    switch ( rpci_read_word(ptdev->pci_dev, real_offset) 
              & PCI_PM_CTRL_STATE_MASK )
     {
     case 0:
         break;
     case 1:
         PT_LOG("Power state transition D1 -> D0active\n");
-        pci_write_word(ptdev->pci_dev, real_offset, 0);
+        rpci_write_word(ptdev->pci_dev, real_offset, 0);
         break;
     case 2:
         PT_LOG("Power state transition D2 -> D0active\n");
-        pci_write_word(ptdev->pci_dev, real_offset, 0);
+        rpci_write_word(ptdev->pci_dev, real_offset, 0);
         usleep(200);
         break;
     case 3:
         PT_LOG("Power state transition D3hot -> D0active\n");
-        pci_write_word(ptdev->pci_dev, real_offset, 0);
+        rpci_write_word(ptdev->pci_dev, real_offset, 0);
         usleep(10 * 1000);
         pt_init_pci_config(ptdev);
         break;
@@ -2945,7 +2959,7 @@ static uint32_t pt_msgctrl_reg_init(struct pt_dev *ptdev,
     if (reg_field & PCI_MSI_FLAGS_ENABLE)
     {
         PT_LOG("MSI enabled already, disable first\n");
-        pci_write_word(pdev, real_offset, reg_field & ~PCI_MSI_FLAGS_ENABLE);
+        rpci_write_word(pdev, real_offset, reg_field & ~PCI_MSI_FLAGS_ENABLE);
     }
     ptdev->msi->flags |= (reg_field | MSI_FLAG_UNINIT);
     ptdev->msi->ctrl_offset = real_offset;
@@ -2994,7 +3008,7 @@ static uint32_t pt_msixctrl_reg_init(struct pt_dev *ptdev,
     if (reg_field & PCI_MSIX_ENABLE)
     {
         PT_LOG("MSIX enabled already, disable first\n");
-        pci_write_word(pdev, real_offset, reg_field & ~PCI_MSIX_ENABLE);
+        rpci_write_word(pdev, real_offset, reg_field & ~PCI_MSIX_ENABLE);
     }
 
     ptdev->msix->ctrl_offset = real_offset;
@@ -3752,7 +3766,7 @@ static int pt_pmcsr_reg_write(struct pt_dev *ptdev,
     else
     {
         /* write power state to I/O device register */
-        pci_write_word(ptdev->pci_dev,
+        rpci_write_word(ptdev->pci_dev,
                         (pm_state->pm_base + PCI_PM_CTRL), *value);
 
         /* in case of transition related to D2,
@@ -3767,7 +3781,7 @@ static int pt_pmcsr_reg_write(struct pt_dev *ptdev,
         check_power_state(ptdev);
 
         /* recreate value for writing to I/O device register */
-        *value = pci_read_word(ptdev->pci_dev,
+        *value = rpci_read_word(ptdev->pci_dev,
                                 (pm_state->pm_base + PCI_PM_CTRL));
     }
 
@@ -3785,7 +3799,7 @@ static int msi_is_enable(struct pt_dev *dev)
     if (!address)
         return 0;
 
-    val = pci_read_word(dev->pci_dev, address);
+    val = rpci_read_word(dev->pci_dev, address);
     return val & PCI_MSI_FLAGS_ENABLE;
 }
 
@@ -4272,7 +4286,7 @@ static struct pt_dev * register_real_device(PCIBus *e_bus,
 
     /* Initialize virtualized PCI configuration (Extended 256 Bytes) */
     for ( i = 0; i < PCI_CONFIG_SIZE; i++ )
-        assigned_device->dev.config[i] = pci_read_byte(pci_dev, i);
+        assigned_device->dev.config[i] = rpci_read_byte(pci_dev, i);
 
     /* Handle real device's MMIO/PIO BARs */
     pt_register_regions(assigned_device);
@@ -4307,7 +4321,7 @@ static struct pt_dev * register_real_device(PCIBus *e_bus,
             PT_LOG("Error: Mapping irq failed, rc = %d\n", rc);
 
             /* Disable PCI intx assertion (turn on bit10 of devctl) */
-            pci_write_word(pci_dev, PCI_COMMAND,
+            rpci_write_word(pci_dev, PCI_COMMAND,
                 *(uint16_t *)(&assigned_device->dev.config[PCI_COMMAND])
                 | PCI_COMMAND_DISABLE_INTx);
             machine_irq = 0;
@@ -4337,7 +4351,7 @@ static struct pt_dev * register_real_device(PCIBus *e_bus,
             PT_LOG("Error: Binding of interrupt failed! rc=%d\n", rc);
 
             /* Disable PCI intx assertion (turn on bit10 of devctl) */
-            pci_write_word(pci_dev, PCI_COMMAND,
+            rpci_write_word(pci_dev, PCI_COMMAND,
                 *(uint16_t *)(&assigned_device->dev.config[PCI_COMMAND])
                 | PCI_COMMAND_DISABLE_INTx);
             mapped_machine_irq[machine_irq]--;
diff --git a/hw/pc.c b/hw/pc.c
index 8c16ebd..1297c18 100644
--- a/hw/pc.c
+++ b/hw/pc.c
@@ -43,6 +43,9 @@
 #include "hpet_emul.h"
 #include "xenmou.h"
 #include "xen_uart_16550.h"
+#include "pci-remote.h"
+
+extern int running_in_stubdomain;
 
 #ifdef CONFIG_PASSTHROUGH
 #include "pass-through.h"
@@ -62,7 +65,7 @@
 #define BIOS_CFG_IOPORT 0x510
 #define FW_CFG_ACPI_TABLES (FW_CFG_ARCH_LOCAL + 0)
 
-#define MAX_IDE_BUS 2
+#define MAX_IDE_BUS 6
 
 #ifdef HAS_TPM
 void tpm_tis_init(SetIRQFunc *set_irq, void *opaque, int irq);
@@ -813,6 +816,12 @@ static void pc_init1(ram_addr_t ram_size, int vga_ram_size,
     BlockDriverState *fd[MAX_FD];
     int rc;
 
+    /* connect to pci config service */
+    if ( -1 == pci_remote_init(running_in_stubdomain)) {
+        fprintf(stderr, "Error: failed to connect to pci config service\n");
+        exit(1);
+    }
+
     if (ram_size >= 0xe0000000 ) {
         above_4g_mem_size = ram_size - 0xe0000000;
         below_4g_mem_size = 0xe0000000;
diff --git a/hw/pci-remote.c b/hw/pci-remote.c
new file mode 100644
index 0000000..01f803f
--- /dev/null
+++ b/hw/pci-remote.c
@@ -0,0 +1,301 @@
+#include "pci-remote.h"
+#include "hw.h"
+#include "pci/pci.h"
+#include <libv4v.h>
+
+#define RPCI_BYTE 0
+#define RPCI_WORD 1
+#define RPCI_LONG 2
+#define RPCI_BLCK 3
+#define RPCI_PORT 5559
+
+struct remotepci_req {
+    unsigned read:1;
+    unsigned write:1;
+    unsigned align:6;
+    u_int16_t domain;
+    u_int8_t bus, dev, func;
+    u_int16_t offset;
+    union {
+        u_int32_t len;
+        u_int32_t v;
+    };
+} __attribute__((packed));
+
+
+static
+int nrecv(int fd, void *buf, size_t n)
+{
+    while (n) {
+        ssize_t r = v4v_recv( fd, buf, n, 0 );
+        if (r == -1) {
+            if (errno == EAGAIN) continue;
+            perror("v4v_recv");
+            return r;
+        } else if (r == 0) {
+            return 0; // EOF
+        } else {
+            n -= r; buf += r;
+        }
+        
+    }
+    return 1;
+}
+
+static
+int nsend(int fd, void *buf, size_t n)
+{
+    while (n) {
+        ssize_t r = v4v_send( fd, buf, n, 0 );
+        if (r == -1) {
+            if (errno == EAGAIN) continue;
+            perror("v4v_send");
+            return r;
+        } else {
+            n -= r; buf += r;
+        }
+    }
+    return 1;
+}
+
+static
+int pci_sock = -1;
+
+static
+int local = 0;
+
+int pci_remote_init(int remote)
+{
+    local = !remote;
+
+    if (remote) {
+        v4v_addr_t addr;
+        pci_sock = v4v_socket(SOCK_STREAM);
+        if (pci_sock == -1) {
+            perror("pci_remote_init: socket");
+            return -1;
+        }
+        memset( &addr, 0, sizeof(addr) );
+        addr.port = RPCI_PORT;
+        addr.domain = 0;
+        if (-1 == v4v_connect(pci_sock, &addr)) {
+            perror("pci_remote_init: connect");
+            return -1;
+        }
+        fprintf(stderr, "using remote pci access\n");
+    } else {
+        fprintf(stderr, "using local pci access\n");
+    }
+    return 0;
+}
+
+static 
+void preq(struct remotepci_req *req, int read, int align, int domain, int bus, int dev, int func, int off)
+{
+    memset(req, 0, sizeof(struct remotepci_req));
+    if (read) {
+        req->read = 1;
+    } else {
+        req->write = 1;
+    }
+    req->align = align;
+    req->domain = domain;
+    req->bus = bus;
+    req->dev = dev;
+    req->func = func;
+    req->offset = off;
+}
+
+static
+int pget(void *buf, int n)
+{
+    if (nrecv(pci_sock, buf, n) <= 0) {
+        perror("pci-remote: pget");
+        return 0;
+    }
+    return 1;
+}
+
+static
+int pput(void *buf, int n)
+{
+    if (nsend(pci_sock, buf, n) < 0) {
+        perror("pci-remote: pput");
+        return 0;
+    }
+    return 1;
+}
+
+static
+int rpci_read_byte_( u_int8_t *buf, int domain, int bus, int dev, int func, int pos )
+{
+    struct remotepci_req req;
+    preq(&req, 1, RPCI_BYTE, domain, bus, dev, func, pos);
+
+    int r = pput( &req, sizeof(req) );
+    r &= pget( buf, 1 );
+    return r;
+}
+
+static
+int rpci_read_word_( u_int16_t *buf, int domain, int bus, int dev, int func, int pos )
+{
+    struct remotepci_req req;
+    preq(&req, 1, RPCI_WORD, domain, bus, dev, func, pos);
+
+    int r = pput( &req, sizeof(req) );
+    r &= pget( buf, 2 );
+    return r;
+}
+
+static
+int rpci_read_long_( u_int32_t *buf, int domain, int bus, int dev, int func, int pos )
+{
+    struct remotepci_req req;
+    preq(&req, 1, RPCI_LONG, domain, bus, dev, func, pos);
+
+    int r = pput( &req, sizeof(req) );
+    r &= pget( buf, 4 );
+    return r;
+}
+
+int rpci_read_block_( void *buf, int domain, int bus, int dev, int func, int pos, int len )
+{
+    struct remotepci_req req;
+    u_int8_t status;
+    preq(&req, 1, RPCI_BLCK, domain, bus, dev, func, pos);
+    req.len = len;
+    
+    int r = pput( &req, sizeof(req) );
+    r &= pget( &status, 1 );
+    if (r && status != 0) {
+        fprintf(stderr, "rpci_read_block: remote failed to read %02x:%02x:%02x pos=%d len=%d\n", bus, dev, func, pos, len);
+        return 0;
+    }
+    r &= pget( buf, len );
+    return r;
+}
+
+static
+int rpci_write_byte_(int domain, int bus, int dev, int func, int pos, u_int16_t v)
+{
+    struct remotepci_req req;
+    preq(&req, 0, RPCI_BYTE, domain, bus, dev, func, pos);
+    req.v = v;
+    return pput( &req, sizeof(req) );
+}
+
+static
+int rpci_write_word_(int domain, int bus, int dev, int func, int pos, u_int16_t v)
+{
+    struct remotepci_req req;
+    preq(&req, 0, RPCI_WORD, domain, bus, dev, func, pos);
+    req.v = v;
+    return pput( &req, sizeof(req) );
+}
+
+static
+int rpci_write_long_(int domain, int bus, int dev, int func, int pos, u_int32_t v)
+{
+    struct remotepci_req req;
+    preq(&req, 0, RPCI_LONG, domain, bus, dev, func, pos);
+    req.v = v;
+    return pput( &req, sizeof(req) );
+}
+
+int rpci_write_block_(void *buf, int domain, int bus, int dev, int func, int pos, int len)
+{
+    struct remotepci_req req;
+    preq(&req, 0, RPCI_BLCK, domain, bus, dev, func, pos);
+    req.len = len;
+    int r = pput( &req, sizeof(req) );
+    r &= pput(buf, len);
+    if (r) {
+        int status = 0;
+        r &= pget( &status, 1 );
+        if (status != 0) {
+            r = 0; // error on remote end
+        }
+    }
+    return r;
+}
+
+/* wrappers */
+
+u_int8_t rpci_read_byte(struct pci_dev *dev, int off)
+{
+    if (local) {
+        return pci_read_byte(dev, off);
+    } else {
+        u_int8_t v = 0;
+        rpci_read_byte_(&v, dev->domain, dev->bus, dev->dev, dev->func, off);
+        return v;
+    }
+}
+
+u_int16_t rpci_read_word(struct pci_dev *dev, int off)
+{
+    if (local) {
+        return pci_read_word(dev, off);
+    } else {
+        u_int16_t v = 0;
+        rpci_read_word_(&v, dev->domain, dev->bus, dev->dev, dev->func, off);
+        return v;
+    }
+}
+
+u_int32_t rpci_read_long(struct pci_dev *dev, int off)
+{
+    if (local) {
+        return pci_read_long(dev, off);
+    } else {
+        u_int32_t v = 0;
+        rpci_read_long_(&v, dev->domain, dev->bus, dev->dev, dev->func, off);
+        return v;
+    }
+}
+
+int rpci_read_block(struct pci_dev *dev, int off, u_int8_t *buf, int len)
+{
+    if (local) {
+        return pci_read_block(dev, off, buf, len);
+    } else {
+        return rpci_read_block_(buf, dev->domain, dev->bus, dev->dev, dev->func, off, len);
+    }
+}
+
+int rpci_write_byte(struct pci_dev *dev, int off, u_int8_t v)
+{
+    if (local) {
+        return pci_write_byte(dev, off, v);
+    } else {
+        return rpci_write_byte_(dev->domain, dev->bus, dev->dev, dev->func, off, v);
+    }
+}
+
+int rpci_write_word(struct pci_dev *dev, int off, u_int16_t v)
+{
+    if (local) {
+        return pci_write_word(dev, off, v);
+    } else {
+        return rpci_write_word_(dev->domain, dev->bus, dev->dev, dev->func, off, v);
+    }
+}
+
+int rpci_write_long(struct pci_dev *dev, int off, u_int32_t v)
+{
+    if (local) {
+        return pci_write_long(dev, off, v);
+    } else {
+        return rpci_write_long_(dev->domain, dev->bus, dev->dev, dev->func, off, v);
+    }
+}
+
+int rpci_write_block(struct pci_dev *dev, int off, u_int8_t *buf, int len)
+{
+    if (local) {
+        return pci_write_block(dev, off, buf, len);
+    } else {
+        return rpci_write_block_(buf, dev->domain, dev->bus, dev->dev, dev->func, off, len);
+    }
+}
diff --git a/hw/pci-remote.h b/hw/pci-remote.h
new file mode 100644
index 0000000..a870526
--- /dev/null
+++ b/hw/pci-remote.h
@@ -0,0 +1,24 @@
+#ifndef _PCIREMOTE_H_
+#define _PCIREMOTE_H_
+
+#include "pci/pci.h"
+#include <sys/types.h>
+
+int pci_remote_init(int remote);
+
+/* these do remote or local reads/writes depending on configuration */
+u_int8_t rpci_read_byte(struct pci_dev *dev, int off);
+u_int16_t rpci_read_word(struct pci_dev *dev, int off);
+u_int32_t rpci_read_long(struct pci_dev *dev, int off);
+int rpci_read_block(struct pci_dev *dev, int off, u_int8_t *buf, int len);
+
+int rpci_write_byte(struct pci_dev *dev, int off, u_int8_t v);
+int rpci_write_word(struct pci_dev *dev, int off, u_int16_t v);
+int rpci_write_long(struct pci_dev *dev, int off, u_int32_t v);
+int rpci_write_block(struct pci_dev *dev, int off, u_int8_t *buf, int len);
+
+/* warning: always does remote call */
+int rpci_read_block_(void *buf, int domain, int bus, int dev, int func, int pos, int len);
+int rpci_write_block_(void *buf, int domain, int bus, int dev, int func, int pos, int len);
+
+#endif
diff --git a/hw/pt-msi.c b/hw/pt-msi.c
index d9e7a32..ec23d64 100644
--- a/hw/pt-msi.c
+++ b/hw/pt-msi.c
@@ -33,10 +33,10 @@ void msi_set_enable(struct pt_dev *dev, int en)
     if (!address)
         return;
 
-    val = pci_read_word(dev->pci_dev, address);
+    val = rpci_read_word(dev->pci_dev, address);
     val &= ~PCI_MSI_FLAGS_ENABLE;
     val |= en & PCI_MSI_FLAGS_ENABLE;
-    pci_write_word(dev->pci_dev, address, val);
+    rpci_write_word(dev->pci_dev, address, val);
 }
 
 static void msix_set_enable(struct pt_dev *dev, int en)
@@ -50,11 +50,11 @@ static void msix_set_enable(struct pt_dev *dev, int en)
     if (!address)
         return;
 
-    val = pci_read_word(dev->pci_dev, address);
+    val = rpci_read_word(dev->pci_dev, address);
     val &= ~PCI_MSIX_ENABLE;
     if (en)
         val |= PCI_MSIX_ENABLE;
-    pci_write_word(dev->pci_dev, address, val);
+    rpci_write_word(dev->pci_dev, address, val);
 }
 
 /* MSI virtuailization functions */
@@ -574,7 +574,7 @@ int pt_msix_init(struct pt_dev *dev, int pos)
     int fd;
     int err;
 
-    id = pci_read_byte(pd, pos + PCI_CAP_LIST_ID);
+    id = rpci_read_byte(pd, pos + PCI_CAP_LIST_ID);
 
     if ( id != PCI_CAP_ID_MSIX )
     {
@@ -582,7 +582,7 @@ int pt_msix_init(struct pt_dev *dev, int pos)
         return -1;
     }
 
-    control = pci_read_word(pd, pos + 2);
+    control = rpci_read_word(pd, pos + 2);
     total_entries = control & 0x7ff;
     total_entries += 1;
 
@@ -602,7 +602,7 @@ int pt_msix_init(struct pt_dev *dev, int pos)
     dev->msix->mmio_index =
         cpu_register_io_memory(0, pci_msix_read, pci_msix_write, dev);
 
-    table_off = pci_read_long(pd, pos + PCI_MSIX_TABLE);
+    table_off = rpci_read_long(pd, pos + PCI_MSIX_TABLE);
     bar_index = dev->msix->bar_index = table_off & PCI_MSIX_BIR;
     table_off = dev->msix->table_off = table_off & ~PCI_MSIX_BIR;
     dev->msix->table_base = pt_pci_base_addr(dev->pci_dev->base_addr[bar_index]);
diff --git a/hw/xen_acpi_common.c b/hw/xen_acpi_common.c
new file mode 100755
index 0000000..314ef50
--- /dev/null
+++ b/hw/xen_acpi_common.c
@@ -0,0 +1,161 @@
+/*
+ * xen_acpi_common.c
+ *
+ * Copyright (c) 2009 Kamala Narasimhan <kamala.narasimhan@citrix.com>
+ * Copyright (c) 2011 Ross Philipson <ross.philipson@citrix.com>
+ * Copyright (c) 2011 Citrix Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* Xen ACPI Common -
+ * Holds common functionality and facilitates ioemu running in stubdoms.
+ * All routines that need access the dom0 OSPM or file system resources
+ * are sorted out in here.
+ */
+
+#include "hw.h"
+#include "pc.h"
+#include "qemu-log.h"
+#include "qemu-xen.h"
+#include "isa.h"
+#include "xen_acpi_common.h"
+
+#ifndef CONFIG_NO_XEN_ACPI_COMMON
+
+#define ACPI_LOG(fmt, ...) qemu_log("XEN ACPI: " fmt, ## __VA_ARGS__)
+
+/*
+ * xen_acpi_read_file
+ */
+uint32_t xen_acpi_read_file_direct(const char *fname, uint8_t **buf_out)
+{
+    FILE *fs = NULL;
+    struct stat st;
+    uint8_t *buf = NULL;
+    uint32_t length = 0;
+    int read;
+
+    *buf_out = NULL;
+
+    if ( stat(fname, &st) )
+    {
+        ACPI_LOG("%s error, failed to stat file - %s, errno: %d\n",
+                 __func__, fname, errno);
+        goto out;
+    }
+
+    buf = malloc(st.st_size);
+    if ( buf == NULL )
+    {
+        ACPI_LOG("%s error, failed to allocate read buffer for file - %s\n",
+                 __func__, fname);
+        goto out;
+    }
+
+    fs = fopen(fname, "r");
+    if ( fs == NULL )
+    {
+        ACPI_LOG("%s error, failed to open file - %s, errno: %d\n",
+                 __func__, fname, errno);
+        goto out;
+    }
+
+    read = fread(buf, st.st_size, 1, fs);
+    if ( read < 1 )
+    {
+        ACPI_LOG("%s error, failed to read file - %s, error: %d\n",
+                 __func__, fname, errno);
+        goto out;
+    }
+
+    *buf_out = buf;
+    buf = NULL;
+    length = st.st_size;
+
+out:
+    if ( fs != NULL )
+        fclose(fs);
+    if ( buf != NULL )
+        free(buf);
+
+    return length;
+}
+
+uint32_t xen_acpi_read_file(const char *fname, uint8_t **buf_out)
+{
+    return xen_acpi_read_file_direct(fname, buf_out);
+}
+
+int xen_acpi_wmi_invoke_method(struct xenacpi_wmi_invocation_data *inv_block,
+                               void *buffer_in,
+                               uint32_t length_in,
+                               void **buffer_out,
+                               uint32_t *length_out,
+                               int *error_out)
+{
+    return xenacpi_wmi_invoke_method(inv_block,
+                                     buffer_in,
+                                     length_in,
+                                     buffer_out,
+                                     length_out,
+                                     error_out);
+}
+
+int xen_acpi_wmi_query_object(struct xenacpi_wmi_invocation_data *inv_block,
+                              void **buffer_out,
+                              uint32_t *length_out,
+                              int *error_out)
+{
+    return xen_acpi_wmi_query_object(inv_block,                                     
+                                     buffer_out,
+                                     length_out,
+                                     error_out);
+}
+
+int xen_acpi_wmi_set_object(struct xenacpi_wmi_invocation_data *inv_block,
+                            void *buffer_in,
+                            uint32_t length_in,
+                            int *error_out)
+{
+    return xen_acpi_wmi_set_object(inv_block,
+                                   buffer_in,
+                                   length_in,
+                                   error_out);
+}
+
+int xen_acpi_wmi_get_event_data(struct xenacpi_wmi_invocation_data *inv_block,
+                                void **buffer_out,
+                                uint32_t *length_out,
+                                int *error_out)
+{
+    return xen_acpi_wmi_get_event_data(inv_block,
+                                       buffer_out,
+                                       length_out,
+                                       error_out);
+}
+
+int xen_acpi_vid_brightness_levels(struct xenacpi_vid_brightness_levels **levels_out,
+                                   int *error_out)
+{
+    return xenacpi_vid_brightness_levels(levels_out, error_out);
+}
+
+void xen_acpi_free_buffer(void *buffer)
+{
+    xenacpi_free_buffer(buffer);
+}
+
+#endif /* CONFIG_NO_XEN_ACPI_COMMON */
diff --git a/hw/xen_acpi_common.h b/hw/xen_acpi_common.h
index 6c9b98b..6723d60 100644
--- a/hw/xen_acpi_common.h
+++ b/hw/xen_acpi_common.h
@@ -23,6 +23,8 @@
 #ifndef _XEN_ACPI_COMMON_H
 #define _XEN_ACPI_COMMON_H
 
+#include <xenacpi.h>
+
 /* ACPI WMI */
 #ifdef CONFIG_STUBDOM
 #define CONFIG_NO_XEN_ACPI_WMI
@@ -39,5 +41,39 @@ void xen_acpi_wmi_cleanup(void);
 void xen_acpi_video_init(PCIDevice *device);
 void xen_acpi_video_cleanup(void);
 
+/* ACPI Common */
+#ifdef CONFIG_STUBDOM
+#define CONFIG_NO_XEN_ACPI_COMMON
+#endif
+
+uint32_t xen_acpi_read_file(const char *fname, uint8_t **buf_out);
+
+int xen_acpi_wmi_invoke_method(struct xenacpi_wmi_invocation_data *inv_block,
+                               void *buffer_in,
+                               uint32_t length_in,
+                               void **buffer_out,
+                               uint32_t *length_out,
+                               int *error_out);
+
+int xen_acpi_wmi_query_object(struct xenacpi_wmi_invocation_data *inv_block,
+                              void **buffer_out,
+                              uint32_t *length_out,
+                              int *error_out);
+
+int xen_acpi_wmi_set_object(struct xenacpi_wmi_invocation_data *inv_block,
+                            void *buffer_in,
+                            uint32_t length_in,
+                            int *error_out);
+
+int xen_acpi_wmi_get_event_data(struct xenacpi_wmi_invocation_data *inv_block,
+                                void **buffer_out,
+                                uint32_t *length_out,
+                                int *error_out);
+
+int xen_acpi_vid_brightness_levels(struct xenacpi_vid_brightness_levels **levels_out,
+                                   int *error_out);
+
+void xen_acpi_free_buffer(void *buffer);
+
 #endif /* _XEN_ACPI_COMMON_H */
 
diff --git a/hw/xen_acpi_video.c b/hw/xen_acpi_video.c
index ce54424..68c4be4 100644
--- a/hw/xen_acpi_video.c
+++ b/hw/xen_acpi_video.c
@@ -32,8 +32,6 @@
 #include "qemu-xen.h"
 #include "isa.h"
 #include "xen_acpi_common.h"
-#include <sys/ioctl.h>
-#include <xenacpi.h>
 
 #ifndef CONFIG_NO_XEN_ACPI_VIDEO
 
@@ -167,7 +165,7 @@ static void xen_acpi_video_initialize_brightness_info(void)
     /* num_brightness_levels == 0 until levels are safely gotten - this
      * value will cause the BCL ASL code to use the default package.
      */
-    ret = xenacpi_vid_brightness_levels(&brightness_levels, &err);
+    ret = xen_acpi_vid_brightness_levels(&brightness_levels, &err);
     if ( ret == -1 )
     {
         VID_LOG("error, failed to get BCL information from the firmware - %d\n", err);
@@ -176,7 +174,7 @@ static void xen_acpi_video_initialize_brightness_info(void)
     if ( brightness_levels->level_count < 4 )
     {
         VID_LOG("error, invalid BCL count: %d\n", brightness_levels->level_count);
-        xenacpi_free_buffer(brightness_levels);
+        xen_acpi_free_buffer(brightness_levels);
         brightness_levels = NULL;
         return;
     }
@@ -221,7 +219,7 @@ void xen_acpi_video_cleanup(void)
     num_brightness_levels = 0;
     if ( brightness_levels != NULL )
     {
-        xenacpi_free_buffer(brightness_levels);
+        xen_acpi_free_buffer(brightness_levels);
         brightness_levels = NULL;
     }
 }
diff --git a/hw/xen_acpi_wmi.c b/hw/xen_acpi_wmi.c
index dcc7ee1..baa9c95 100644
--- a/hw/xen_acpi_wmi.c
+++ b/hw/xen_acpi_wmi.c
@@ -40,8 +40,6 @@
 #include "qemu-xen.h"
 #include "isa.h"
 #include "xen_acpi_common.h"
-#include <sys/ioctl.h>
-#include <xenacpi.h>
 
 #ifndef CONFIG_NO_XEN_ACPI_WMI
 
@@ -85,63 +83,6 @@ static void xen_acpi_wmi_print_guid(void)
 }
 
 /*
- * xen_acpi_read_file
- */
-static uint32_t xen_acpi_read_file(const char *fname, uint8_t **buf_out)
-{
-    FILE *fs = NULL;
-    struct stat st;
-    uint8_t *buf = NULL;
-    uint32_t length = 0;
-    int read;
-
-    *buf_out = NULL;
-
-    if ( stat(fname, &st) )
-    {
-        WMI_LOG("%s error, failed to stat file - %s, errno: %d\n",
-                __func__, fname, errno);
-        goto out;
-    }
-
-    buf = malloc(st.st_size);
-    if ( buf == NULL )
-    {
-        WMI_LOG("%s error, failed to allocate read buffer for file - %s\n",
-                __func__, fname);
-        goto out;
-    }
-
-    fs = fopen(fname, "r");
-    if ( fs == NULL )
-    {
-        WMI_LOG("%s error, failed to open file - %s, errno: %d\n",
-                __func__, fname, errno);
-        goto out;
-    }
-
-    read = fread(buf, st.st_size, 1, fs);
-    if ( read < 1 )
-    {
-        WMI_LOG("%s error, failed to read file - %s, error: %d\n",
-                __func__, fname, errno);
-        goto out;
-    }
-
-    *buf_out = buf;
-    buf = NULL;
-    length = st.st_size;
-
-out:
-    if ( fs != NULL )
-        fclose(fs);
-    if ( buf != NULL )
-        free(buf);
-
-    return length;
-}
-
-/*
  * xen_acpi_wmi_set_init
  */
 static void xen_acpi_wmi_set_init(uint8_t val)
@@ -359,7 +300,7 @@ static void xen_acpi_wmi_free_output_buffer(void)
         WMI_LOG("%s: freeing output buffer - %p\n",
                 __func__, cmd_info.output_buffer);
 #endif
-        xenacpi_free_buffer(cmd_info.output_buffer);
+        xen_acpi_free_buffer(cmd_info.output_buffer);
         cmd_info.output_buffer = NULL;
     }
     cmd_info.output_length = 0;
@@ -508,33 +449,33 @@ static void xen_acpi_wmi_execute(void)
      * is incorrect, the call will fail. */
     if ( cmd_info.invocation_type == XENACPI_WMI_INV_EXEC_METHOD )
     {
-        ret = xenacpi_wmi_invoke_method(&cmd_info.invocation_data,
-                                        cmd_info.input_buffer,
-                                        cmd_info.input_length,
-                                        (void**)&cmd_info.output_buffer,
-                                        &cmd_info.output_length,
-                                        &err);
+        ret = xen_acpi_wmi_invoke_method(&cmd_info.invocation_data,
+                                         cmd_info.input_buffer,
+                                         cmd_info.input_length,
+                                         (void**)&cmd_info.output_buffer,
+                                         &cmd_info.output_length,
+                                         &err);
     }
     else if ( cmd_info.invocation_type == XENACPI_WMI_INV_QUERY_OBJECT )
     {
-        ret = xenacpi_wmi_query_object(&cmd_info.invocation_data,
-                                       (void**)&cmd_info.output_buffer,
-                                       &cmd_info.output_length,
-                                       &err);
+        ret = xen_acpi_wmi_query_object(&cmd_info.invocation_data,
+                                        (void**)&cmd_info.output_buffer,
+                                        &cmd_info.output_length,
+                                        &err);
     }
     else if ( cmd_info.invocation_type == XENACPI_WMI_INV_SET_OBJECT )
     {
-        ret = xenacpi_wmi_set_object(&cmd_info.invocation_data,
-                                     cmd_info.input_buffer,
-                                     cmd_info.input_length,
-                                     &err);
+        ret = xen_acpi_wmi_set_object(&cmd_info.invocation_data,
+                                      cmd_info.input_buffer,
+                                      cmd_info.input_length,
+                                      &err);
     }
     else if ( cmd_info.invocation_type == XENACPI_WMI_INV_GET_EVENT_DATA )
     {
-        ret = xenacpi_wmi_get_event_data(&cmd_info.invocation_data,
-                                         (void**)&cmd_info.output_buffer,
-                                         &cmd_info.output_length,
-                                         &err);
+        ret = xen_acpi_wmi_get_event_data(&cmd_info.invocation_data,
+                                          (void**)&cmd_info.output_buffer,
+                                          &cmd_info.output_length,
+                                          &err);
     }
     else
     {
diff --git a/hw/xen_machine_fv.c b/hw/xen_machine_fv.c
index a353ee6..70f42db 100644
--- a/hw/xen_machine_fv.c
+++ b/hw/xen_machine_fv.c
@@ -58,6 +58,7 @@ struct map_cache_rev {
     TAILQ_ENTRY(map_cache_rev) next;
 };
 
+extern int running_in_stubdomain;
 static struct map_cache *mapcache_entry;
 static unsigned long nr_buckets;
 TAILQ_HEAD(map_cache_head, map_cache_rev) locked_entries = TAILQ_HEAD_INITIALIZER(locked_entries);
@@ -294,9 +295,6 @@ static void xen_init_fv(ram_addr_t ram_size, int vga_ram_size,
     }
 #endif
 
-#ifdef CONFIG_STUBDOM /* the hvmop is not supported on older hypervisors */
-    xc_set_hvm_param(xc_handle, domid, HVM_PARAM_DM_DOMAIN, DOMID_SELF);
-#endif
     xc_get_hvm_param(xc_handle, domid, HVM_PARAM_IOREQ_PFN, &ioreq_pfn);
     fprintf(logfile, "shared page at pfn %lx\n", ioreq_pfn);
     shared_page = xc_map_foreign_range(xc_handle, domid, XC_PAGE_SIZE,
diff --git a/logging.c b/logging.c
index 6ae51b2..48df2f6 100644
--- a/logging.c
+++ b/logging.c
@@ -1,5 +1,8 @@
 #include "logging.h"
 
+
+extern int running_in_stubdomain;
+
 void cpu_set_log_syslog(const char *ident)
 {
     closelog();
@@ -11,7 +14,10 @@ int __syslog_fprintf(FILE *stream, const char *format, ...)
     va_list ap;
 
     va_start(ap, format);
-    vsyslog(LOG_DAEMON | LOG_NOTICE, format, ap);
+    if (running_in_stubdomain)
+      vprintf(format, ap);
+    else
+      vsyslog(LOG_DAEMON | LOG_NOTICE, format, ap);
     va_end(ap);
 
     return 0;
@@ -19,7 +25,9 @@ int __syslog_fprintf(FILE *stream, const char *format, ...)
 
 int __syslog_vfprintf(FILE *stream, const char *format, va_list ap)
 {
-    vsyslog(LOG_DAEMON | LOG_NOTICE, format, ap);
+    if (running_in_stubdomain)
+      vprintf(format, ap);
+    else
+      vsyslog(LOG_DAEMON | LOG_NOTICE, format, ap);
     return 0;
 }
-
diff --git a/vl.c b/vl.c
index 3ec9dce..70a71e0 100644
--- a/vl.c
+++ b/vl.c
@@ -192,6 +192,7 @@ int main(int argc, char **argv)
 
 void suspend(int sig);
 
+int running_in_stubdomain = 0;
 const char *bios_dir = CONFIG_QEMU_SHAREDIR;
 const char *bios_name = NULL;
 static void *ioport_opaque[MAX_IOPORTS];
@@ -4103,6 +4104,7 @@ static void help(int exitcode)
            "\n"
            "Standard options:\n"
            "-h or -help     display this help and exit\n"
+           "-stubdom        include this if it is running in a stubdomain\n"
            "-M machine      select emulated machine (-M ? for list)\n"
            "-cpu cpu        select CPU (-cpu ? for list)\n"
            "-smp n          set the number of CPUs to 'n' [default=1]\n"
@@ -4316,6 +4318,7 @@ enum {
     /* Standard options: */
     QEMU_OPTION_h,
     QEMU_OPTION_M,
+    QEMU_OPTION_stubdom,
     QEMU_OPTION_cpu,
     QEMU_OPTION_smp,
     QEMU_OPTION_fda,
@@ -4443,6 +4446,7 @@ static const QEMUOption qemu_options[] = {
     /* Standard options: */
     { "h", 0, QEMU_OPTION_h },
     { "help", 0, QEMU_OPTION_h },
+    { "stubdom", 0, QEMU_OPTION_stubdom },
     { "M", HAS_ARG, QEMU_OPTION_M },
     { "cpu", HAS_ARG, QEMU_OPTION_cpu },
     { "smp", HAS_ARG, QEMU_OPTION_smp },
@@ -5213,6 +5217,10 @@ int main(int argc, char **argv, char **envp)
                     exit(*optarg != '?');
                 }
                 break;
+            case QEMU_OPTION_stubdom:
+                running_in_stubdomain = 1;
+                fprintf(stderr, "SSSS qemu: RUNNING in STUBDOMAIN\n");
+                break;
             case QEMU_OPTION_cpu:
                 /* hw initialization will check this */
                 if (*optarg == '?') {
@@ -5332,7 +5340,7 @@ int main(int argc, char **argv, char **envp)
                 drive_add(optarg, CDROM_PT_RO_ALIAS);
                 break;
             case QEMU_OPTION_cdrom_pt_exclusive:
-                drive_add(optarg, CDROM_PT_EXCLUSIVE_ALIAS);
+	        drive_add(optarg, CDROM_PT_EXCLUSIVE_ALIAS);
                 break;
             case QEMU_OPTION_cdrom_pt_ro_exclusive:
                 drive_add(optarg, CDROM_PT_RO_EXCLUSIVE_ALIAS);
diff --git a/xen-hooks.mak b/xen-hooks.mak
index bf876ca..37a23e5 100644
--- a/xen-hooks.mak
+++ b/xen-hooks.mak
@@ -47,6 +47,8 @@ OBJS += vbestate.o
 OBJS += switcher.o
 OBJS += xen_acpi_video.o
 OBJS += dmbus.o
+OBJS += pci-remote.o
+OBJS += xen_acpi_common.o
 
 CONFIG_AUDIO=1
 
diff --git a/xenstore.c b/xenstore.c
index e26d3d8..9c24dc5 100644
--- a/xenstore.c
+++ b/xenstore.c
@@ -454,10 +454,12 @@ void xenstore_parse_domain_config(int hvm_domid)
     char *buf = NULL;
     char *fpath = NULL, *bpath = NULL,
         *dev = NULL, *params = NULL, *drv = NULL;
+    char *my_domid_str = NULL;
     int i, ret;
     unsigned int len, num, hd_index, pci_devid = 0;
     BlockDriverState *bs;
     BlockDriver *format;
+    int pci_dm_domid = -1;
 
     /* Read-only handling for image files */
     char *mode = NULL;
@@ -737,9 +739,22 @@ void xenstore_parse_domain_config(int hvm_domid)
      * hvm_domid is always equal to domid */
     hvm_domid = domid;
 
+    /* if we're in stubdom (have domid node and it's /= 0), read the pci information from stubdom's xs tree, not the
+     * guests */
+    if ( pasprintf(&buf, "domid") == -1 )
+        goto out;
+    pci_dm_domid = hvm_domid;
+    my_domid_str = xs_read( xsh, XBT_NULL, buf, &len );
+    if ( my_domid_str ) {
+        int did = atoi( my_domid_str );
+        if (did) {
+            pci_dm_domid = did;
+        }
+    }
+
     /* get the pci pass-through parameters */
     if (pasprintf(&buf, "/local/domain/0/backend/pci/%u/%u/msitranslate",
-                  hvm_domid, pci_devid) != -1)
+                  pci_dm_domid, pci_devid) != -1)
     {
         free(params);
         params = xs_read(xsh, XBT_NULL, buf, &len);
@@ -750,7 +765,7 @@ void xenstore_parse_domain_config(int hvm_domid)
     }
 
     if (pasprintf(&buf, "/local/domain/0/backend/pci/%u/%u/power_mgmt",
-                  hvm_domid, pci_devid) != -1)
+                  pci_dm_domid, pci_devid) != -1)
     {
         free(params);
         params = xs_read(xsh, XBT_NULL, buf, &len);
